***
!REMOVE_FILE R/manip_cmd.R

!CHANGE_FILE R/t_collapse.R
# Translate Stata 'collapse' command
# Stata: collapse (stat) varlist [name=expr ...] [weight] [if] [in] [, options]
# Often: collapse (stat) varlist, by(groupvars)

t_collapse = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {

  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Split into aggregate definitions part and options part
  parts = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(.*?)(?:,\\s*(.*))?$")
  aggregate_part = stringi::stri_trim_both(parts[1,2])
  options_part = stringi::stri_trim_both(parts[1,3]) # NA if no options

  # Separate potential if/in from aggregate definitions
  stata_if_in_cond = NA_character_
  # Look for `if` or `in` immediately followed by a space
  if_in_match = stringi::stri_match_first_regex(aggregate_part, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      # Remove the if/in part from aggregate_part
      aggregate_part = stringi::stri_replace_last_regex(aggregate_part, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      aggregate_part = stringi::stri_trim_both(aggregate_part)
  }


  # Parse aggregate definitions: "(stat) var [= newvar] (stat) var [= newvar] ..."
  # This regex needs to handle multiple aggregate blocks
  # Find all occurrences of `(stat) var [= newvar]`
  # Let's use stri_match_all_regex
  # Pattern: \( - literal parenthesis
  # ([a-zA-Z_]+) - stat name (group 1)
  # \) - literal parenthesis
  # \s+ - one or more spaces
  # ([a-zA-Z0-9_]+) - source var name (group 2)
  # (?: - non-capturing group for optional assignment
  # \s*=\s* - equals sign with optional spaces
  # ([a-zA-Z0-9_]+) - new var name (group 3)
  # )? - end optional group
  aggregate_matches = stringi::stri_match_all_regex(aggregate_part, "\\(([a-zA-Z_]+)\\)\\s+([a-zA-Z0-9_]+)(?:\\s*=\\s*([a-zA-Z0-9_]+))?")[[1]]
  # aggregate_matches will be a matrix: [match, stat, source_var, new_var]

  if (NROW(aggregate_matches) == 0) {
    return(paste0("# Failed to parse collapse aggregate definitions: ", aggregate_part))
  }

  # Parse options part for `by()`
  by_vars_collapse = NA_character_
  if (!is.na(options_part)) {
    by_opt_match = stringi::stri_match_first_regex(options_part, "\\bby\\s*\\(([^)]+)\\)")
    if (!is.na(by_opt_match[1,1])) {
      by_vars_collapse = stringi::stri_trim_both(by_opt_match[1,2])
    }
  }

  by_vars_r_vec_str = NULL # For collapse group_by: character vector c("var1", "var2")
  if (!is.na(by_vars_collapse)) {
    by_vars_list = stringi::stri_split_regex(by_vars_collapse, "\\s+")[[1]]
    by_vars_list = by_vars_list[by_vars_list != ""]
    by_vars_r_vec_str = paste0('c("', paste0(by_vars_list, collapse='", "'), '")')
  }

  # Translate the if/in condition for subsetting *before* collapse
  # Stata collapse applies if/in *before* grouping and aggregation
  r_subset_cond = NA_character_
  data_source_for_collapse = "data"
  r_code_prefix = "" # Code to create subset if needed

  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      # Assuming if/in condition for collapse applies to original data rows
      # The context for _n/_N here should be the original data, not the group
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group = FALSE))

      # Check if r_subset_cond is valid
      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for collapse: ", stata_if_in_cond))
      }

      # Create a temporary subset variable
      data_subset_varname = paste0("data_subset_L", cmd_obj$line) # Use actual line from cmd_obj
      r_code_prefix = paste0(data_subset_varname, " = base::subset(data, ", r_subset_cond, ")\n")
      data_source_for_collapse = data_subset_varname
  }


  # Build the summarise/aggregate expressions for collapse::fsummarise
  aggregate_exprs = character(NROW(aggregate_matches))
  for (j in 1:NROW(aggregate_matches)) {
    stat = aggregate_matches[j, 2]
    source_var = aggregate_matches[j, 3]
    new_var = aggregate_matches[j, 4]

    # Translate source variable name - usually just the name itself
    r_source_var = translate_stata_expression_with_r_values(source_var, line_num, cmd_df, context)
     if (is.na(r_source_var) || r_source_var == "") {
         return(paste0("# Failed to translate source variable '", source_var, "' for collapse stat '", stat, "'"))
     }


    # Map Stata stats to collapse functions
    collapse_func = switch(stat,
      "mean" = paste0("collapse::fmean(", r_source_var, ", na.rm = TRUE)"),
      "sum" = paste0("collapse::fsum(", r_source_var, ", na.rm = TRUE)"),
      "count" = paste0("collapse::fnobs(", r_source_var, ")"), # counts non-missing
      "N" = paste0("collapse::fnobs(", r_source_var, ")"), # total obs, including missing for the var? No, count() and N() are synonyms, count non-missing.
      "first" = paste0("collapse::ffirst(", r_source_var, ")"),
      "last" = paste0("collapse::flast(", r_source_var, ")"),
      "min" = paste0("collapse::fmin(", r_source_var, ", na.rm = TRUE)"),
      "max" = paste0("collapse::fmax(", r_source_var, ", na.rm = TRUE)"),
      "median" = paste0("collapse::fmedian(", r_source_var, ", na.rm = TRUE)"),
      "sd" = paste0("collapse::fsd(", r_source_var, ", na.rm = TRUE)"),
      "p1" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.01, na.rm = TRUE)"),
      "p5" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.05, na.rm = TRUE)"),
      "p10" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.10, na.rm = TRUE)"),
      "p25" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.25, na.rm = TRUE)"),
      "p75" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.75, na.rm = TRUE)"),
      "p90" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.90, na.rm = TRUE)"),
      "p95" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.95, na.rm = TRUE)"),
      "p99" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.99, na.rm = TRUE)"),
       # Add more stats...
      NULL # Default for unknown stat
    )

    if (is.null(collapse_func)) {
        return(paste0("# Collapse stat '", stat, "' not yet implemented."))
    }

    # Determine the new variable name
    if (is.na(new_var) || new_var == "") {
      # If no newvar specified, Stata uses the source var name.
      # R collapse::fsummarise requires `newvar = func(sourcevar)`.
      # If source_var is `i`, the expression is `i = fmean(i)`.
      r_new_var = r_source_var # Use source_var as the new var name
    } else {
      r_new_var = new_var # Use the specified newvar name
    }

    aggregate_exprs[j] = paste0(r_new_var, " = ", collapse_func)
  }

  # Combine aggregate expressions
  aggregate_exprs_str = paste(aggregate_exprs, collapse = ",\n  ")

  # Build the final R code
  r_code_str = r_code_prefix # Add subsetting code if any

  if (!is.null(by_vars_r_vec_str)) {
    r_code_str = paste0(r_code_str,
                       "data = collapse::fgroup_by(", data_source_for_collapse, ", ", by_vars_r_vec_str, ") %>%\n",
                       "  collapse::fsummarise(", aggregate_exprs_str, ") %>%\n",
                       "  collapse::fungroup()") # Collapse summarise includes ungroup by default, but explicit is safe.
  } else {
     # Collapse without by() aggregates the whole dataset into a single row
     r_code_str = paste0(r_code_str,
                       "data = collapse::fsummarise(", data_source_for_collapse, ", ", aggregate_exprs_str, ")")
  }

  return(r_code_str)
}

!END_CHANGE_FILE R/t_collapse.R

!CHANGE_FILE R/t_egen.R
# Translate Stata 'egen' command
# Stata: egen [type] newvar = fcn(arguments) [if exp] [in range] [, options]

# This is a complex command with many functions.
# We'll implement a few common ones like mean, total, rank.
t_egen = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  # Basic parsing: newvar = function(args) [, by(groupvars)] [if condition]
  # Example: egen mean_i_grp = mean(i), by(group)
  # Example: egen total_i = total(i)
  # Example: bysort group: egen rank_i = rank(i) (Note: bysort handled by cmd_obj$is_by_prefix)

  # Remove type prefix if any (byte, int, long, float, double, str#, etc.)
  # Pattern: ^\s*(byte|int|long|float|double|str\d+)\s+
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^\\s*(?:byte|int|long|float|double|str\\d+)\\s+", "")

  # Regex to get `newvar = func(args)` and optional `if` and `options` (like by())
  # Pattern: ^\s*([^=\s]+)\s*=\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)\)\s*(?:if\s+(.*?))?\s*(?:,(.*))?$
  # G1: newvar, G2: func, G3: args_inside_paren, G4: if_cond, G5: options_str

  main_match = stringi::stri_match_first_regex(rest_of_cmd_no_type,
    "^\\s*([^=\\s]+)\\s*=\\s*([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\(([^)]*)\\)\\s*(?:if\\s+(.*?))?\\s*(?:,(.*))?$")

  if (is.na(main_match[1,1])) {
    return(paste0("# Failed to parse egen command structure: ", rest_of_cmd))
  }

  new_var = stringi::stri_trim_both(main_match[1,2])
  egen_func_name = stringi::stri_trim_both(main_match[1,3])
  egen_args_str = stringi::stri_trim_both(main_match[1,4]) # arguments inside parentheses
  stata_if_cond = stringi::stri_trim_both(main_match[1,5]) # NA if no if
  options_str = stringi::stri_trim_both(main_match[1,6])   # NA if no options like by()

  # Translate expressions/conditions
  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    # Egen's `if` condition is usually applied *before* the function calculation within a group.
    # Example: `bysort group: egen m = mean(x) if y > 0` -> mean is calculated for x where y>0 *within* group.
    # Example: `egen m = mean(x) if y > 0` -> mean is calculated for x over *all* obs where y>0.
    # Example: `egen m = mean(x if y > 0)` -> same as previous.
    # Stata manual says `egen ... if exp` is equivalent to `egen ... = f(expr if exp)`.
    # So the condition should be applied *inside* the function args or via subsetting the source data for the function.
    # The current regex puts `if` condition outside the parentheses. Let's adjust the approach.
    # The regex should match `newvar = fcn(arguments [if exp])`.
    # Let's use a simpler approach: check if `if` is present anywhere after `=` and before `,` or end of string.
    # If `if` is found, extract the condition and assume it applies to the function arguments.
    # This might not be perfectly accurate for all obscure egen cases but covers common patterns.

    # Re-parse rest_of_cmd_no_type looking for `newvar = fcn(args) [if cond] [, options]`
    # Split at the first `=`. Left is `newvar`. Right is `fcn(args) [if cond] [, options]`
    parts_eq = stringi::stri_split_fixed(rest_of_cmd_no_type, "=", n=2)[[1]]
    if(length(parts_eq) != 2) return(paste0("# Failed to parse egen command structure (no =): ", rest_of_cmd))

    new_var = stringi::stri_trim_both(parts_eq[1])
    right_part = stringi::stri_trim_both(parts_eq[2])

    # Split right_part at the first comma (if any) to separate function/args/if from options
    parts_comma = stringi::stri_split_fixed(right_part, ",", n=2)[[1]]
    func_args_if_part = stringi::stri_trim_both(parts_comma[1])
    options_str = if(length(parts_comma) > 1) stringi::stri_trim_both(parts_comma[2]) else NA_character_

    # Now parse func_args_if_part: `fcn(args) [if cond]`
    # Split at the first `(`
    parts_paren = stringi::stri_split_fixed(func_args_if_part, "(", n=2)[[1]]
    if(length(parts_paren) != 2) return(paste0("# Failed to parse egen function call: ", func_args_if_part))

    egen_func_name = stringi::stri_trim_both(parts_paren[1])
    args_and_if_part = stringi::stri_trim_both(stringi::stri_replace_last_fixed(parts_paren[2], ")", "")) # Remove trailing ')'

    # Now parse args_and_if_part: `args [if cond]`
    stata_if_cond_in_args = NA_character_
    # Look for `if` immediately followed by a space within the args part
    if_match_in_args = stringi::stri_match_first_regex(args_and_if_part, "\\s+if\\s+(.*)$")
     if(!is.na(if_match_in_args[1,1])) {
        stata_if_cond_in_args = if_match_in_args[1,2]
        egen_args_str = stringi::stri_replace_last_regex(args_and_if_part, "\\s+if\\s+(.*)$", "")
        egen_args_str = stringi::stri_trim_both(egen_args_str)
     } else {
        egen_args_str = args_and_if_part
     }

    # Now we have: new_var, egen_func_name, egen_args_str, stata_if_cond_in_args, options_str
    # Translate the condition if it exists
    r_if_cond_in_args = NA_character_
    if (!is.na(stata_if_cond_in_args) && stata_if_cond_in_args != "") {
         # Context for _n/_N in the if condition within egen args is usually the group context
        r_if_cond_in_args = translate_stata_expression_with_r_values(stata_if_cond_in_args, line_num, cmd_df, context)
    }

    # Translate arguments if they are complex expressions (not typical for egen simple funcs)
    # Translate args using the main context (could involve _n/_N if inside bysort)
    r_egen_args = translate_stata_expression_with_r_values(egen_args_str, line_num, cmd_df, context)


  } # End of re-parsing block

  # Determine by_vars: either from `cmd_obj$by_vars` (if `bysort group: egen...`) or from `options_str` (if `egen ..., by(group)`)
  by_vars_egen = NA_character_
  if (cmd_obj$is_by_prefix && !is.na(cmd_obj$by_vars)) {
    by_vars_egen = cmd_obj$by_vars
  } else if (!is.na(options_str)) {
    by_opt_match = stringi::stri_match_first_regex(options_str, "\\bby\\s*\\(([^)]+)\\)")
    if (!is.na(by_opt_match[1,1])) {
      by_vars_egen = stringi::stri_trim_both(by_opt_match[1,2])
    }
  }

  by_vars_r_vec_str = NULL # For collapse group_by: c("var1", "var2")
  if (!is.na(by_vars_egen)) {
    by_vars_list = stringi::stri_split_regex(by_vars_egen, "\\s+")[[1]]
    by_vars_list = by_vars_list[by_vars_list != ""]
    by_vars_r_vec_str = paste0('c("', paste0(by_vars_list, collapse='", "'), '")')
  }

  # Translate egen function
  # Resulting expression for mutate: `new_var = R_EQUIVALENT_EXPRESSION`
  mutate_value_expr = ""
  is_row_function = FALSE # Flag for functions like rowtotal, rowmean that don't use group_by

  # Apply if condition within the function call if needed
  # If stata_if_cond_in_args was present, apply r_if_cond_in_args inside the function arguments.
  # Example: mean(x if y>0) -> mean(ifelse(y>0, x, NA), na.rm = TRUE)
  # This requires modifying r_egen_args based on r_if_cond_in_args
  if (!is.na(r_if_cond_in_args) && r_if_cond_in_args != "") {
      r_egen_args_conditional = paste0("base::ifelse(", r_if_cond_in_args, ", ", r_egen_args, ", NA)")
  } else {
      r_egen_args_conditional = r_egen_args
  }


  # Switch for egen functions
  # Common egen functions:
  # mean(var): mean(var, na.rm = TRUE)
  # total(var): sum(var, na.rm = TRUE)
  # count(var): sum(!is.na(var)) or sum(condition)
  # rank(var): min_rank(var)
  # median(var): median(var, na.rm = TRUE)
  # sd(var): sd(var, na.rm = TRUE)
  # group(varlist): collapse::fgroup_rank or dplyr::group_indices
  # tag(varlist): collapse::ftag or !duplicated() after sorting
  # rowtotal(varlist): rowSums for selected vars, NA as 0
  # rowmean(varlist): rowMeans for selected vars, NA ignored

  if (egen_func_name == "mean") {
    mutate_value_expr = paste0("mean(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "total" || egen_func_name == "sum") {
    mutate_value_expr = paste0("sum(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "count") {
    # count(exp) counts non-missing results of exp. If exp is varname, sum(!is.na(varname)).
    # If exp is complex, sum(eval(parse(text=r_egen_args_conditional)) != 0 & !is.na(eval(parse(text=r_egen_args_conditional))))
    # Assuming r_egen_args_conditional results in a numeric or logical vector
    mutate_value_expr = paste0("sum(!is.na(", r_egen_args_conditional, "))")
  } else if (egen_func_name == "rank") {
    mutate_value_expr = paste0("dplyr::min_rank(", r_egen_args_conditional, ")")
  } else if (egen_func_name == "median" || egen_func_name == "p50") {
    mutate_value_expr = paste0("median(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "sd" || egen_func_name == "std") {
    mutate_value_expr = paste0("sd(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "group") {
    # egen id = group(var1 var2) -> var1 and var2 are in r_egen_args, space separated.
    group_vars_for_func_list = stringi::stri_split_regex(r_egen_args_conditional, "\\s+")[[1]]
    group_vars_for_func_list = group_vars_for_func_list[group_vars_for_func_list != ""]
    group_vars_r_vec_str_for_func = paste0('c("', paste(group_vars_for_func_list, collapse='", "'), '")')

    # Using collapse::fgroup_rank
    # fgroup_rank works on a vector of columns
    mutate_value_expr = paste0("collapse::fgroup_rank(dplyr::select(., dplyr::all_of(", group_vars_r_vec_str_for_func, ")))")

  } else if (egen_func_name == "tag") {
      # egen t = tag(v1 v2) implies sorting by v1 v2 first, then tagging first obs in each group defined by v1 v2.
      # If `by group: egen t = tag(v1 v2)`, it's within `group`, then by `v1 v2`.
      # This is complex and depends on whether the bysort prefix or the tag arguments define the "group".
      # Stata manual: `tag(varlist)` marks the first observation in each group defined by `varlist` *within* the current `by` group (if any).
      # So if by_vars_egen is present, the tag is within that group. If not, it's based on the tag arguments.
      # collapse::ftag(v) flags the first observation of each group based on values of v.
      # For `tag(v1 v2)`, it's `collapse::ftag(v1, v2)`.
      tag_vars_list = stringi::stri_split_regex(r_egen_args_conditional, "\\s+")[[1]]
      tag_vars_list = tag_vars_list[tag_vars_list != ""]
      tag_vars_r_vec_str = paste0('c("', paste(tag_vars_list, collapse='", "'), '")')

      if (!is.null(by_vars_r_vec_str)) {
           # If there's a by group, tag is within that group.
           # collapse::ftag can take multiple arguments for grouping.
           # `by A: egen t = tag(B C)` -> `ftag(B, C)` calculated within groups of `A`.
           # `collapse::fgroup_by(data, by_vars) %>% fmutate(t = ftag(tag_vars)) %>% fungroup()`
           # This needs ftag to work on multiple arguments inside fmutate.
           # ftag works on fsubsetted/fgroup_by'd data.
           # Alternative: !duplicated within the grouped data.
           # mutate_value_expr = paste0("!duplicated(dplyr::select(., dplyr::all_of(", tag_vars_r_vec_str, ")))") # This works with dplyr group_by
           # With collapse fgroup_by + fmutate, need to ensure ftag works correctly.
           # ftag is for grouping by *its arguments*. We need grouping by `by_vars_egen` *then* using `tag_vars`.
           # Stata `by A: egen t = tag(B C)` is equivalent to `bysort A B C: gen byte t = _n==1`.
           # So the sorting order is crucial. If bysort prefix is used, Stata guarantees the sort. If `by()` option is used, it implies sorting.
           # The generated R code needs to ensure the correct sort order *before* calculating _n==1.
           # A common translation for `by A: egen t = tag(B C)` could be:
           # `data = data %>% group_by(A) %>% arrange(B, C) %>% mutate(t = row_number() == 1) %>% ungroup()`
           # Using collapse:
           # `data = collapse::setorder(data, ", by_vars_r_vec_str, ", ", paste(tag_vars_list, collapse = ", "), ")`
           # `data = collapse::fgroup_by(data, ", by_vars_r_vec_str, ")`
           # `data = collapse::fmutate(data, ", new_var, " = 1:.N == 1)") # Or row_number() == 1
           # `data = collapse::fungroup(data)`
           # This requires modifying the command sequence, which is complex.
           # Let's stick to a simpler mutate expression, assuming the data is already correctly sorted if `tag` is used with `by`.
           # Use dplyr::row_number() == 1 within the collapse fmutate:
           mutate_value_expr = paste0("dplyr::row_number() == 1") # Assuming data is sorted by by_vars_egen + tag_vars
           # This relies on collapse::fgroup_by + collapse::fmutate providing correct row_number() behavior.
           # dplyr::row_number() works correctly within dplyr::group_by + dplyr::mutate.
           # collapse documentation says `.N` is number of observations *in the group*. `.i` is index *in the group*.
           # So `.i == 1` should be the equivalent of `_n==1` in Stata's by group.
           mutate_value_expr = paste0(".i == 1") # Using collapse group index
      } else {
           # No by group. Tag is based on the tag_vars only.
           # This is equivalent to `bysort tag_vars: gen byte t = _n==1`.
           # Again, requires sorting.
           tag_vars_r_comma_sep = paste(tag_vars_list, collapse = ", ")
           # Need to sort by tag_vars first.
           # Adding sorting code here is tricky. Let's assume the user handles sorting, or add a comment.
           # A simple fmutate based on ftag: ftag(v1, v2, ...) needs to be supported or constructed.
           # ftag takes a vector or list of vectors.
           # `collapse::ftag(dplyr::select(., dplyr::all_of(", tag_vars_r_vec_str, ")))` - this should work.
           mutate_value_expr = paste0("collapse::ftag(dplyr::select(., dplyr::all_of(", tag_vars_r_vec_str, ")))")
           by_vars_r_vec_str = NULL # Tag without BY is not a grouped operation in the same sense for the R code structure.
      }


  } else if (egen_func_name == "rowtotal") {
    vars_for_rowop_list = stringi::stri_split_regex(r_egen_args_conditional, "\\s+")[[1]]
    vars_for_rowop_list = vars_for_rowop_list[vars_for_rowop_list != ""]
    vars_for_rowop_r_vec_str = paste0('c("', paste(vars_for_rowop_list, collapse='", "'), '")')

    # Stata rowtotal treats NA as 0 *before* summing. rowsums in R has na.rm=TRUE (ignores NA) or not (NA if any NA).
    # `rowSums(replace(., is.na(.), 0))` or `rowSums(dplyr::mutate_all(., ~tidyr::replace_na(., 0)))`
    # collapse::frowsums treats NA as 0 by default if `na.rm=FALSE`? Check docs.
    # No, frowsums(x, na.rm=F) gives NA if any NA. Need to replace NA with 0 first.
    # Get relevant columns, replace NA with 0, then rowSums.
    # `rowSums(tidyr::replace_na(dplyr::select(., dplyr::all_of(", vars_for_rowop_r_vec_str, ")), 0))`
    mutate_value_expr = paste0("rowSums(tidyr::replace_na(dplyr::select(., dplyr::all_of(", vars_for_rowop_r_vec_str, ")), 0))")
    is_row_function = TRUE; by_vars_r_vec_str = NULL # Row functions don't use grouping in the same way
  } else if (egen_func_name == "rowmean") {
    vars_for_rowop_list = stringi::stri_split_regex(r_egen_args_conditional, "\\s+")[[1]]
    vars_for_rowop_list = vars_for_rowop_list[vars_for_rowop_list != ""]
    vars_for_rowop_r_vec_str = paste0('c("', paste(vars_for_rowop_list, collapse='", "'), '")')

    mutate_value_expr = paste0("rowMeans(dplyr::select(., dplyr::all_of(", vars_for_rowop_r_vec_str, ")), na.rm = TRUE)")
    is_row_function = TRUE; by_vars_r_vec_str = NULL
  } else {
    return(paste0("# Egen function '", egen_func_name, "' not yet implemented."))
  }

  # Combine into a mutate statement
  full_mutate_expr = paste0(new_var, " = ", mutate_value_expr)

  # Build the R command string using collapse functions
  if (!is.null(by_vars_r_vec_str) && !is_row_function) {
    r_code_str = paste0("data = collapse::fgroup_by(data, ", by_vars_r_vec_str, ") %>%\n",
                        "  collapse::fmutate(", full_mutate_expr, ") %>%\n",
                        "  collapse::fungroup()")
  } else {
    r_code_str = paste0("data = collapse::fmutate(data, ", full_mutate_expr, ")")
  }

  return(r_code_str)
}

!END_CHANGE_FILE R/t_egen.R

!CHANGE_FILE R/t_rename.R
# Translate Stata 'rename' command
# Stata: rename old_var new_var
t_rename = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Split into old_var and new_var
  parts = stringi::stri_split_regex(rest_of_cmd_trimmed, "\\s+", n = 2)[[1]]

  if (length(parts) != 2) {
    return(paste0("# Failed to parse rename command: ", rest_of_cmd))
  }

  old_var = parts[1]
  new_var = parts[2]

  # Using collapse::frename
  # collapse::frename(data, old_name = new_name)
  r_code_str = paste0("data = collapse::frename(data, `", old_var, "` = `", new_var, "`)")
  # Alternative dplyr: data = dplyr::rename(data, new_var = old_var)
  # r_code_str = paste0("data = dplyr::rename(data, `", new_var, "` = `", old_var, "`)")

  return(r_code_str)
}
!END_CHANGE_FILE R/t_rename.R

!CHANGE_FILE R/t_merge.R
# Translate Stata 'merge' command
# Stata: merge 1:1 varlist using filename [, options]
# Stata: merge 1:m varlist using filename [, options]
# Stata: merge m:1 varlist using filename [, options]
# Stata: merge m:m varlist using filename [, options]
# Options: keep(match master using all) nogenerate

t_merge = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse merge type (1:1, 1:m, m:1, m:m), varlist, `using filename`, and options
  # Pattern: ^\s*(\d+:\d+)\s+(.*?)\s+using\s+([^,\s]+)(?:,\\s*(.*))?$
  # G1: type, G2: varlist, G3: filename (can be quoted or macro), G4: options

  merge_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(\\d+:\\d+)\\s+(.*?)\\s+using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")

  if (is.na(merge_match[1,1])) {
      # Check for older syntax without type: `merge varlist using filename` (defaults to 1:1)
      merge_match_old = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(.*?)\\s+using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")
      if (!is.na(merge_match_old[1,1])) {
           merge_type = "1:1" # Assume 1:1 if type not specified
           varlist_str = stringi::stri_trim_both(merge_match_old[1,2])
           filename_part = stringi::stri_trim_both(merge_match_old[1,3])
           options_str = stringi::stri_trim_both(merge_match_old[1,4])
      } else {
           return(paste0("# Failed to parse merge command: ", rest_of_cmd))
      }
  } else {
      merge_type = merge_match[1,2]
      varlist_str = stringi::stri_trim_both(merge_match[1,3])
      filename_part = stringi::stri_trim_both(merge_match[1,4])
      options_str = stringi::stri_trim_both(merge_match[1,5]) # NA if no options
  }

  vars_to_merge_on = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_merge_on = vars_to_merge_on[vars_to_merge_on != ""]
  if (length(vars_to_merge_on) == 0) {
       return(paste0("# merge command requires varlist: ", rest_of_cmd))
  }
  vars_to_merge_on_r_vec_str = paste0('c("', paste(vars_to_merge_on, collapse = '", "'), '")')


  # Resolve the `using filename` - can be a path string or a macro
  using_source_r = NA_character_ # This will hold either a path string or an R variable name

  # Check if filename_part is a macro `macroname`
  if (stringi::stri_startswith_fixed(filename_part, "`") && stringi::stri_endswith_fixed(filename_part, "'")) {
    macro_name = stringi::stri_sub(filename_part, 2, -2)

    # Find definition of this macro (from tempfile or save)
    # Convention: R_tempfile_L<def_line>_<macro>_path OR R_tempdata_L<def_line>_<macro>
    path_r_var = NA_character_
    data_r_var = NA_character_

    # Scan cmd_df backwards for tempfile or save definition
    for (i in (line_num - 1):1) {
        if (cmd_df$stata_cmd[i] %in% c("tempfile", "save") && grepl(paste0("`",macro_name,"'"), cmd_df$rest_of_cmd[i])) {
            # Assume tempfile creates R_tempfile_L..._path
            # Assume save `macro` creates R_tempdata_L..._macro
            def_line = cmd_df$line[i]
            path_r_var = paste0("R_tempfile_L", def_line, "_", macro_name, "_path")
            data_r_var = paste0("R_tempdata_L", def_line, "_", macro_name)
            break
        }
    }

    # Prefer using the R data object if it exists, otherwise use the path
    if (!is.na(data_r_var)) {
        using_source_r = data_r_var
        # Need to ensure this variable name is treated as a dataframe in R code
        # e.g., `collapse::fmerge(data, R_tempdata_LXX_macro, by = ...)`
    } else if (!is.na(path_r_var)) {
        # Need to read the DTA file from this path
        # e.g., `collapse::fmerge(data, haven::read_dta(R_tempfile_LXX_macro_path), by = ...)`
        using_source_r = paste0("haven::read_dta(", path_r_var, ")")
    } else {
         # Fallback: assume macro holds a string path or is a string literal to read
         warning(paste0("Macro ",filename_part, " in 'merge' command at line ",line_num, " not fully resolved. Treating as filename string."))
         using_source_r = filename_part
          using_source_r = paste0("haven::read_dta(", using_source_r, ")")
    }
  } else {
    # Actual filename string, e.g. "mydata.dta"
    using_source_r = filename_part
     using_source_r = paste0("haven::read_dta(", using_source_r, ")")
  }


  # Determine merge type for collapse::fmerge
  # collapse::fmerge(x, y, by, all.x=TRUE/FALSE, all.y=TRUE/FALSE)
  # 1:1: all.x=TRUE, all.y=TRUE (corresponds to R full_join, Stata keep(match master using), or keep(all))
  #      Stata 1:1 requires varlist to uniquely identify observations in *both* datasets.
  #      R merge/join doesn't enforce this uniqueness by default.
  # 1:m: all.x=TRUE, all.y=FALSE (corresponds to R left_join, Stata keep(match master))
  # m:1: all.x=FALSE, all.y=TRUE (corresponds to R right_join, Stata keep(match using))
  # m:m: all.x=TRUE, all.y=TRUE (corresponds to R full_join, Stata keep(match master using))

  all_x = TRUE # Corresponds to keeping all from master
  all_y = TRUE # Corresponds to keeping all from using
  merge_comment = paste0("# Stata merge type: ", merge_type)

  if (merge_type == "1:1") {
       # Stata 1:1 keeps matched observations by default, unmatched dropped unless options used.
       # R full_join keeps all. To match Stata's default (matched only), need inner_join.
       # Stata `merge 1:1` usually implies `keep(match)`. `keep(all)` adds unmatched.
       # Let's aim for inner_join as the most common default equivalent if no `keep` option.
       # If `keep(all)` is specified, use `all.x=TRUE, all.y=TRUE`.
       # If `keep(master)` use `all.x=TRUE, all.y=FALSE`.
       # If `keep(using)` use `all.x=FALSE, all.y=TRUE`.
       # If `keep(match master)` use `all.x=TRUE, all.y=FALSE`.
       # If `keep(match using)` use `all.x=FALSE, all.y=TRUE`.
       # If `keep(match)` use `all.x=FALSE, all.y=FALSE`.

       # Default R join types:
       # inner_join: match only (all.x=F, all.y=F)
       # left_join: match + master unmatched (all.x=T, all.y=F)
       # right_join: match + using unmatched (all.x=F, all.y=T)
       # full_join: match + master unmatched + using unmatched (all.x=T, all.y=T)

       # Stata default for all merge types is to drop observations that do not match in both.
       # So R inner_join (all.x=F, all.y=F) is the closest default.

       all_x = FALSE
       all_y = FALSE

  } else if (merge_type == "1:m") {
      # Default: keep matched + master unmatched. Corresponds to R left_join.
      all_x = TRUE
      all_y = FALSE
  } else if (merge_type == "m:1") {
      # Default: keep matched + using unmatched. Corresponds to R right_join.
      all_x = FALSE
      all_y = TRUE
  } else if (merge_type == "m:m") {
      # Default: keep matched only. Corresponds to R inner_join.
      all_x = FALSE
      all_y = FALSE
  }

  # Handle keep() options if present, overriding defaults
  # This is a simplified parser for keep options within merge
  if (!is.na(options_str)) {
      keep_opt_match = stringi::stri_match_first_regex(options_str, "\\bkeep\\s*\\(([^)]+)\\)")
      if (!is.na(keep_opt_match[1,1])) {
          keep_spec = stringi::stri_trim_both(keep_opt_match[1,2])
          if (grepl("\\ball\\b", keep_spec)) {
              all_x = TRUE; all_y = TRUE
              merge_comment = paste0(merge_comment, ", keep(all)")
          } else if (grepl("\\bmaster\\b", keep_spec)) {
              all_x = TRUE; all_y = FALSE # Keep matched and master unmatched
               if (grepl("\\bmatch\\b", keep_spec)) {
                  # keep(match master) is the default for 1:m, same as keep(master)
               } else {
                   # just keep(master) is unusual, often implies keeping all master regardless of match
                   # which is essentially a left join followed by subsetting for _merge==1 or 2
                   # Let's treat keep(master) as left_join (all.x=T, all.y=F) for now.
               }
              merge_comment = paste0(merge_comment, ", keep(master)")
          } else if (grepl("\\busing\\b", keep_spec)) {
              all_x = FALSE; all_y = TRUE # Keep matched and using unmatched
              if (grepl("\\bmatch\\b", keep_spec)) {
                  # keep(match using) is the default for m:1, same as keep(using)
               } else {
                   # just keep(using) is unusual, treat as right_join (all.x=F, all.y=T) for now.
               }
               merge_comment = paste0(merge_comment, ", keep(using)")
          } else if (grepl("\\bmatch\\b", keep_spec)) {
              all_x = FALSE; all_y = FALSE # Keep matched only (inner join)
              merge_comment = paste0(merge_comment, ", keep(match)")
          }
          # Other complex keep() specs like `keep(_merge==3)` are not handled here.
      }
  }

  # Handle nogenerate option
  has_nogenerate = !is.na(options_str) && stringi::stri_detect_fixed(options_str, "nogenerate")
  # Stata merge creates _merge variable (1 master, 2 using, 3 both).
  # R merge/join doesn't create a merge indicator. `collapse::fmerge` also doesn't.
  # If nogenerate is NOT present, we would need to create a merge indicator variable.
  # This is complex. For now, assume nogenerate or don't generate the indicator.
  # Add a comment if _merge variable is expected but not generated.
  merge_comment = paste0(merge_comment, if(has_nogenerate) ", nogenerate" else " # _merge variable was not generated.")


  # Build the R command string using collapse::fmerge
  # fmerge(x, y, by, all.x, all.y)
  r_code_str = paste0("data = collapse::fmerge(data, ", using_source_r, ", by = ", vars_to_merge_on_r_vec_str, ", all.x = ", toupper(all_x), ", all.y = ", toupper(all_y), ") ", merge_comment)

  return(r_code_str)
}
!END_CHANGE_FILE R/t_merge.R

!CHANGE_FILE R/t_append.R
# Translate Stata 'append' command
# Stata: append using filename [, options]

t_append = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse `using filename` and options
  # Pattern: ^\s*using\s+([^,\s]+)(?:,\\s*(.*))?$
  # G1: filename (can be quoted or macro), G2: options

  append_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")

  if (is.na(append_match[1,1])) {
    return(paste0("# Failed to parse append command: ", rest_of_cmd))
  }

  filename_part = stringi::stri_trim_both(append_match[1,2])
  options_str = stringi::stri_trim_both(append_match[1,3]) # NA if no options

    # Resolve the `using filename` - can be a path string or a macro
  using_source_r = NA_character_ # This will hold either a path string or an R variable name

  # Check if filename_part is a macro `macroname`
  if (stringi::stri_startswith_fixed(filename_part, "`") && stringi::stri_endswith_fixed(filename_part, "'")) {
    macro_name = stringi::stri_sub(filename_part, 2, -2)

    # Find definition of this macro (from tempfile or save)
    # Convention: R_tempfile_L<def_line>_<macro>_path OR R_tempdata_L<def_line>_<macro>
    path_r_var = NA_character_
    data_r_var = NA_character_

    # Scan cmd_df backwards for tempfile or save definition
    for (i in (line_num - 1):1) {
        if (cmd_df$stata_cmd[i] %in% c("tempfile", "save") && grepl(paste0("`",macro_name,"'"), cmd_df$rest_of_cmd[i])) {
            def_line = cmd_df$line[i]
            path_r_var = paste0("R_tempfile_L", def_line, "_", macro_name, "_path")
            data_r_var = paste0("R_tempdata_L", def_line, "_", macro_name)
            break
        }
    }

    # Prefer using the R data object if it exists, otherwise use the path
    if (!is.na(data_r_var)) {
        using_source_r = data_r_var
        # Need to ensure this variable name is treated as a dataframe in R code
        # e.g., `collapse::fbind(data, R_tempdata_LXX_macro)`
    } else if (!is.na(path_r_var)) {
        # Need to read the DTA file from this path
        # e.g., `collapse::fbind(data, haven::read_dta(R_tempfile_LXX_macro_path))`
        using_source_r = paste0("haven::read_dta(", path_r_var, ")")
    } else {
         # Fallback: assume macro holds a string path or is a string literal to read
         warning(paste0("Macro ",filename_part, " in 'append' command at line ",line_num, " not fully resolved. Treating as filename string."))
         using_source_r = filename_part
         using_source_r = paste0("haven::read_dta(", using_source_r, ")")
    }
  } else {
    # Actual filename string, e.g. "mydata.dta"
    using_source_r = filename_part
    using_source_r = paste0("haven::read_dta(", using_source_r, ")")
  }


  # Stata append requires variable names to match or be harmonized.
  # collapse::fbind matches columns by name. Differences are filled with NA. This is similar to Stata.
  # Options like `force` (append even if variable types don't match) are not handled.

  # Using collapse::fbind
  r_code_str = paste0("data = collapse::fbind(data, ", using_source_r, ")")

  # Add comment about options if any were present but not handled
  if (!is.na(options_str) && options_str != "") {
       r_code_str = paste0(r_code_str, paste0(" # Options ignored: ", options_str))
  }


  return(r_code_str)
}
!END_CHANGE_FILE R/t_append.R

!CHANGE_FILE R/t_reshape.R
# Translate Stata 'reshape' command
# Stata: reshape wide/long stubnames, i(varlist) [j(varname) | j(varname) string] [options]
# This is a complex command. Basic translation using tidyr.

t_reshape = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse wide/long, stubnames, options
  # Pattern: ^\s*(wide|long)\s+(.*?)(?:,\\s*(.*))?$
  # G1: type (wide/long), G2: stubnames/varlist, G3: options

  reshape_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(wide|long)\\s+(.*?)(?:,\\s*(.*))?$")

  if (is.na(reshape_match[1,1])) {
    return(paste0("# Failed to parse reshape command: ", rest_of_cmd))
  }

  reshape_type = reshape_match[1,2]
  stubnames_or_varlist_str = stringi::stri_trim_both(reshape_match[1,3])
  options_str = stringi::stri_trim_both(reshape_match[1,4]) # NA if no options

  stubnames_or_varlist = stringi::stri_split_regex(stubnames_or_varlist_str, "\\s+")[[1]]
  stubnames_or_varlist = stubnames_or_varlist[stubnames_or_varlist != ""]
  if (length(stubnames_or_varlist) == 0) {
       return(paste0("# reshape command requires stubnames or varlist: ", rest_of_cmd))
  }


  # Parse required options: i() and j()
  i_vars = NA_character_
  j_var = NA_character_
  j_is_string = FALSE # Stata j() can create numeric or string j variable

  if (!is.na(options_str)) {
      i_opt_match = stringi::stri_match_first_regex(options_str, "\\bi\\s*\\(([^)]+)\\)")
      if (!is.na(i_opt_match[1,1])) {
           i_vars = stringi::stri_trim_both(i_opt_match[1,2])
      }

      j_opt_match = stringi::stri_match_first_regex(options_str, "\\bj\\s*\\(([^)]+)\\)")
      if (!is.na(j_opt_match[1,1])) {
           j_part = stringi::stri_trim_both(j_opt_match[1,2])
           # Check if j part contains 'string' option
           j_string_match = stringi::stri_match_first_regex(j_part, "^\\s*([a-zA-Z_][a-zA-Z0-9_]*)(?:\\s+string)?$")
           if (!is.na(j_string_match[1,1])) {
               j_var = j_string_match[1,2]
               j_is_string = !is.na(stringi::stri_match_first_regex(j_part, "\\s+string$")[1,1])
           }
      }
  }

  if (is.na(i_vars) || i_vars == "") {
      return(paste0("# reshape command requires i() variable(s): ", rest_of_cmd))
  }
  i_vars_list = stringi::stri_split_regex(i_vars, "\\s+")[[1]]
  i_vars_list = i_vars_list[i_vars_list != ""]
  i_vars_r_vec_str = paste0('c("', paste(i_vars_list, collapse = '", "'), '")')

  if (is.na(j_var) || j_var == "") {
       # j() is required unless the data is already structured s.t. it's obvious.
       # Stata infers j if possible, but usually j() is explicitly required.
       # For translation, let's assume j() is required.
       return(paste0("# reshape command requires j() variable: ", rest_of_cmd))
  }


  r_code_str = ""

  if (reshape_type == "wide") {
      # Stata `reshape wide stubnames, i(i) j(j)`
      # R `tidyr::pivot_wider(data, id_cols = i_vars, names_from = j_var, values_from = stubnames)`
      # Multiple stubnames means values_from is a vector of stubnames.
      # If stubnames are `inc limit`, R columns become inc_1990, inc_1991, limit_1990, limit_1991
      # Stata by default creates `stubnamejvalue` columns.
      # tidyr default is `stubname_jvalue`. Can control with `names_sep` or `names_from` + `values_from`.
      # Let's use default `names_sep = "_"` for now.

      stubnames_r_vec_str = paste0('c("', paste(stubnames_or_varlist, collapse = '", "'), '")')

      r_code_str = paste0("data = tidyr::pivot_wider(data, id_cols = dplyr::all_of(", i_vars_r_vec_str, "), names_from = ", j_var, ", values_from = dplyr::all_of(", stubnames_r_vec_str, "))")

  } else if (reshape_type == "long") {
      # Stata `reshape long stubnames, i(i) j(jname)`
      # R `tidyr::pivot_longer(data, cols = c(list of stubnames), names_to = jname, values_to = value_name)`
      # Stata: `reshape long inc limit, i(id) j(year)` -> creates `id`, `year`, `inc`, `limit`
      # tidyr: `pivot_longer(..., names_to = "year", values_to = "value")` default puts all values in 'value'.
      # If multiple stubnames, tidyr can gather them separately.
      # `pivot_longer(..., names_to = c(".value", "year"), names_sep = "_")` if original cols were `inc_1990`, `limit_1990`, etc.

      # The `stubnames_or_varlist` for long format lists the *original* wide variables which become the stubs.
      # Example: `reshape long inc90 inc91 limit90 limit91, i(id) j(year)`
      # Stubnames are `inc` and `limit`. The suffix is `90`, `91`.
      # tidyr needs to know the columns to gather: `c(inc90, inc91, limit90, limit91)`
      # Stata infers the stubs and suffixes. We need to parse the original wide columns.
      # This requires analyzing the `stubnames_or_varlist` and potentially options like `string`.

      # Simple approach: Assume stubnames_or_varlist lists all wide columns to gather.
      # e.g. `reshape long inc90 inc91, i(id) j(year)`
      # cols = c(inc90, inc91).
      # names_to = "year" (this is the j variable name)
      # values_to = ".value" (this tells pivot_longer to use the original column names as value columns)
      # names_pattern = "stub(.*)" captures the part that becomes the j variable value.
      # If stubnames are `inc` and `limit`, and columns are `inc_1990`, `inc_1991`, `limit_1990`, `limit_1991`
      # `pivot_longer(cols = starts_with("inc_") | starts_with("limit_"), names_to = c(".value", j_var), names_sep = "_", values_to = "???")`
      # This mapping is tricky.

      # Let's assume the simplest case first: one set of stubnames.
      # `reshape long inc, i(id) j(year)` means original vars are inc1990, inc1991, etc.
      # stubname="inc", jname="year". Columns to gather are "inc*".
      # `tidyr::pivot_longer(data, cols = starts_with(stubname), names_to = jname, values_pattern = "stubname(.*)", values_to = stubname)`
      # Example: `reshape long inc, i(id) j(year)`
      # `stubnames_or_varlist` = "inc". Let's assume this is the single stubname.
      # The original wide columns implicitly match this stub (e.g., inc1990, inc1991).
      # `cols` should match `inc*`. `names_to` is `j_var`. `values_to` is `inc`. `names_pattern` captures the part after "inc".

      if (length(stubnames_or_varlist) > 1) {
           return(paste0("# reshape long with multiple stubnames not yet fully implemented: ", rest_of_cmd))
      }
      stubname = stubnames_or_varlist[1]
      # Assuming wide variables match `stubname + suffix`
      names_pattern = paste0(stubname, "(.*)") # Capture suffix as j variable value
      # If j is string, the captured part is the string. If numeric, need conversion.
      # Stata j() string means the j variable is stored as string.
      # tidyr names_to + names_pattern creates the j variable value.
      # values_to is the name of the variable that holds the actual data values. Stata uses the stubname.

      r_code_str = paste0("data = tidyr::pivot_longer(data, cols = starts_with(\"", stubname, "\"), names_to = \"", j_var, "\", names_pattern = \"", names_pattern, "\", values_to = \"", stubname, "\")")

      # If j() string option was used, need to convert the resulting j_var to string/factor later if tidyr made it numeric.
      # tidyr's names_pattern captures as string by default. If j_is_string is FALSE, need conversion to numeric.
      if (!j_is_string) {
         # Convert j_var to numeric after reshape
         r_code_str = paste0(r_code_str, " %>%\n  dplyr::mutate(", j_var, " = as.numeric(", j_var, "))")
      }

  } else {
      r_code_str = paste0("# Unknown reshape type: ", reshape_type)
  }

  # Add comment about options if any were present but not handled
  if (!is.na(options_str) && !grepl("\\bi\\s*\\([^)]+\\)", options_str) && !grepl("\\bj\\s*\\([^)]+\\)", options_str)) {
       r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str))
  }


  return(r_code_str)
}
!END_CHANGE_FILE R/t_reshape.R

!CHANGE_FILE R/t_recode.R
# Translate Stata 'recode' command
# Stata: recode varlist (rule1)(rule2)... [if] [in] [, options]
# Example: recode income (0=.) (100 thru 200 = 150) (300 301 305 = 300) (else=copy), gen(newincome)

t_recode = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varlist, rules, if/in, options (especially gen())
  # This parsing is quite complex due to nested parentheses and optional parts.
  # Let's try to split varlist first, then find rules in parentheses.
  # Example: `recode var1 var2 (0=.) (1/10=1) (else=copy) if cond, gen(new1 new2)`

  # Split at first parenthesis to get varlist
  parts_varlist = stringi::stri_split_fixed(rest_of_cmd_trimmed, "(", n=2)[[1]]
  if (length(parts_varlist) != 2) {
      return(paste0("# Failed to parse recode command (missing rules): ", rest_of_cmd))
  }
  varlist_str = stringi::stri_trim_both(parts_varlist[1])
  vars_to_recode = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_recode = vars_to_recode[vars_to_recode != ""]

  if (length(vars_to_recode) == 0) {
      return(paste0("# recode command requires varlist: ", rest_of_cmd))
  }

  rules_and_rest = paste0("(", parts_varlist[2]) # Put the '(' back

  # Separate if/in and options from rules
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Look for `if` or `in` first
  if_in_match = stringi::stri_match_first_regex(rules_and_rest, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rules_and_rest = stringi::stri_replace_last_regex(rules_and_rest, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rules_and_rest = stringi::stri_trim_both(rules_and_rest)
  }

  # Look for options after the if/in part or after rules
  options_match = stringi::stri_match_first_regex(rules_and_rest, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      rules_part = stringi::stri_replace_last_regex(rules_and_rest, ",\\s*(.*)$", "")
      rules_part = stringi::stri_trim_both(rules_part)
  } else {
      rules_part = rules_and_rest
  }

  # Now parse the rules part: (rule1)(rule2)...
  # Find all rules within parentheses
  rule_matches = stringi::stri_match_all_regex(rules_part, "\\(([^)]*)\\)")[[1]] # Match content inside ()
  if (NROW(rule_matches) == 0) {
      return(paste0("# Failed to parse recode rules: ", rules_part))
  }
  recode_rules_raw = rule_matches[,2] # Extract the content within parentheses


  # Parse options, specifically `gen()`
  gen_vars = NA_character_
  if (!is.na(options_str)) {
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgen\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars = stringi::stri_trim_both(gen_opt_match[1,2])
      }
  }

  new_vars = NULL
  if (!is.na(gen_vars)) {
      new_vars = stringi::stri_split_regex(gen_vars, "\\s+")[[1]]
      new_vars = new_vars[new_vars != ""]
      if (length(new_vars) != length(vars_to_recode)) {
          return(paste0("# recode gen() option requires same number of new variables as old variables."))
      }
  } else {
      # If no gen() option, recode is done in place. New vars are the same as old vars.
      new_vars = vars_to_recode
  }


  # Translate the if/in condition for subsetting
  r_subset_cond = NA_character_
  data_source_for_recode = "data"
  r_code_prefix = "" # Code to create subset if needed

  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      # Stata recode applies if/in to select observations *to be recoded*.
      # Observations not meeting if/in condition are left unchanged.
      # This means the R code needs to apply the recoding conditionally.
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for recode: ", stata_if_in_cond))
      }
      # The actual recoding logic (case_when/ifelse) will incorporate this condition.
      # No need for a separate subset dataframe here.
  }


  # Translate rules into R case_when clauses
  # Rule format: old_value = new_value
  # old_value can be: single value, range (val1/val2, val1 thru val2), list (val1 val2), else, missing (.)
  # new_value can be: single value, copy (use original value), missing (.)

  translate_recode_rule = function(rule_str, source_var_r, r_if_cond) {
      rule_str = stringi::stri_trim_both(rule_str)
      parts_eq = stringi::stri_split_fixed(rule_str, "=", n=2)[[1]]
      if (length(parts_eq) != 2) {
          return(paste0("## Error parsing rule: ", rule_str))
      }
      old_part_raw = stringi::stri_trim_both(parts_eq[1])
      new_part_raw = stringi::stri_trim_both(parts_eq[2])

      # Translate old_part into R condition (left side of case_when ~ )
      r_condition = ""
      if (old_part_raw == "else") {
          r_condition = "TRUE" # This rule is the fallback
      } else if (old_part_raw == ".") {
           r_condition = paste0("is.na(", source_var_r, ")") # Missing value rule
      } else if (grepl("\\s+thru\\s+", old_part_raw)) {
           # Range: val1 thru val2
           range_parts = stringi::stri_split_regex(old_part_raw, "\\s+thru\\s+", n=2)[[1]]
           val1 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[1])) # Translate value (e.g. string "A" or number)
           val2 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[2]))
           if (is.na(val1) || is.na(val2)) return(paste0("## Error translating range values in rule: ", rule_str))
           r_condition = paste0(source_var_r, " >= ", val1, " & ", source_var_r, " <= ", val2)
      } else if (grepl("/", old_part_raw)) {
          # Range: val1/val2
           range_parts = stringi::stri_split_regex(old_part_raw, "/", n=2)[[1]]
           val1 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[1])) # Translate value
           val2 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[2]))
           if (is.na(val1) || is.na(val2)) return(paste0("## Error translating range values in rule: ", rule_str))
           r_condition = paste0(source_var_r, " >= ", val1, " & ", source_var_r, " <= ", val2) # Stata / is inclusive range
      }
      else {
          # List of values or single value
          old_values = stringi::stri_split_regex(old_part_raw, "\\s+")[[1]]
          old_values = old_values[old_values != ""]
          r_values = sapply(old_values, function(val) {
               if (val == ".") return("NA") # Stata missing symbol
               translate_stata_expression_to_r(val) # Translate value (e.g. "5", `"string"`)
          })
          r_condition = paste0(source_var_r, " %in% c(", paste(r_values, collapse = ", "), ")")
      }

      # Apply global if/in condition to this specific rule's condition
      if (!is.na(r_if_cond) && r_if_cond != "" && r_condition != "TRUE") { # Don't apply global if to the "else" rule
          r_condition = paste0("(", r_if_cond, ") & (", r_condition, ")")
      } else if (!is.na(r_if_cond) && r_if_cond != "" && r_condition == "TRUE") {
           # If it's the 'else' rule and there's a global if,
           # this rule applies to observations meeting the global if
           # AND not meeting any *previous* rules *for those observations*.
           # This is tricky with case_when. case_when evaluates sequentially.
           # The global if should modify the entire case_when structure, not individual rules.
           # Example: recode x (1=10) (2=20) (else=30) if y>0
           # If y<=0, x is unchanged. If y>0: x=1->10, x=2->20, other x values -> 30.
           # Correct structure: if_else(y>0, case_when(...), x)
           # Let's handle the global if *outside* the rule translation for now.
           # So, return just the rule's condition here.
      }


      # Translate new_part into R value (right side of case_when ~ )
      r_new_value = ""
      if (new_part_raw == "copy") {
          r_new_value = source_var_r # Use the original variable value
      } else if (new_part_raw == ".") {
          r_new_value = "NA" # R missing
      } else {
           r_new_value = translate_stata_expression_to_r(new_part_raw) # Translate the new value
      }

      return(paste0(r_condition, " ~ ", r_new_value))
  }

  # Generate case_when expression for each variable
  mutate_exprs = character(length(vars_to_recode))
  for (k in seq_along(vars_to_recode)) {
      old_var = vars_to_recode[k]
      new_var = new_vars[k]
      source_var_r = old_var # R variable name for the source column

      # Translate all rules for this variable
      r_rules = sapply(recode_rules_raw, translate_recode_rule, source_var_r = source_var_r, r_if_cond = NA_character_) # Global if handled outside

      # Combine rules into a case_when statement
      case_when_expr = paste0("dplyr::case_when(\n    ", paste(r_rules, collapse = ",\n    "), "\n  )")

      # Apply global if/in condition around the case_when
      if (!is.na(r_subset_cond) && r_subset_cond != "") {
          # If condition is met, apply case_when. Otherwise, keep original value.
          final_value_expr = paste0("dplyr::if_else(", r_subset_cond, ",\n",
                                    "    ", case_when_expr, ",\n",
                                    "    ", source_var_r, ")") # Keep original value if condition not met
      } else {
          final_value_expr = case_when_expr
      }


      mutate_exprs[k] = paste0(new_var, " = ", final_value_expr)
  }

  # Combine mutate expressions
  mutate_exprs_str = paste(mutate_exprs, collapse = ",\n  ")

  # Build the final R code using collapse::fmutate
  r_code_str = paste0("data = collapse::fmutate(data, ", mutate_exprs_str, ")")

  # Add comment about options if any were present but not handled (excluding gen)
   if (!is.na(options_str) && !grepl("\\bgen\\s*\\([^)]+\\)", options_str)) {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str))
   }


  return(r_code_str)
}
!END_CHANGE_FILE R/t_recode.R

!CHANGE_FILE R/t_order.R
# Translate Stata 'order' command
# Stata: order varlist [options]
# Changes the order of variables in the dataset.

t_order = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Split varlist from options (like `first`, `last`, `after(var)`)
  # Pattern: ^\s*(.*?)(?:,\\s*(.*))?$
  parts = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(.*?)(?:,\\s*(.*))?$")
  varlist_str = stringi::stri_trim_both(parts[1,2])
  options_str = stringi::stri_trim_both(parts[1,3]) # NA if no options

  vars_to_order = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_order = vars_to_order[vars_to_order != ""]

  if (length(vars_to_order) == 0) {
    return("# order command with no variables specified.")
  }

  # Stata `order varlist` puts varlist at the beginning.
  # Options like `first`, `last`, `after(var)` are not handled here.
  # R equivalent: Select the variables to order, then select all other variables.
  # Using dplyr::select
  # R code: data = dplyr::select(data, var1, var2, ..., dplyr::everything())

  vars_to_order_r_str = paste(vars_to_order, collapse = ", ")

  r_code_str = paste0("data = dplyr::select(data, ", vars_to_order_r_str, ", dplyr::everything())")

  # Add comment about options if any were present but not handled
   if (!is.na(options_str) && options_str != "") {
        r_code_str = paste0(r_code_str, paste0(" # Options ignored: ", options_str))
   }


  return(r_code_str)
}
!END_CHANGE_FILE R/t_order.R

!CHANGE_FILE R/t_expand.R
# Translate Stata 'expand' command
# Stata: expand N [if] [in] [, options]
# Creates N copies of each observation. N can be an expression.
# Example: expand 2
# Example: expand num_copies if condition

t_expand = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse N expression and optional if/in
  # Pattern: ^\s*(.*?)(?:\\s+if\\s+(.*?))?(?:\\s+in\\s+(.*?))?$ # if/in order can vary, simpler regex
  # Let's split at the first space that is *not* inside if/in. This is complex.
  # Simpler: Assume N is the first part, then look for optional `if` or `in`.

  parts_if = stringi::stri_split_regex(rest_of_cmd_trimmed, "\\s+if\\s+", n=2)[[1]]
  expand_n_part = stringi::stri_trim_both(parts_if[1])
  stata_if_cond = if(length(parts_if) > 1) stringi::stri_trim_both(parts_if[2]) else NA_character_

  parts_in = stringi::stri_split_regex(expand_n_part, "\\s+in\\s+", n=2)[[1]]
  expand_n_part = stringi::stri_trim_both(parts_in[1])
  stata_in_range = if(length(parts_in) > 1) stringi::stri_trim_both(parts_in[2]) else NA_character_

  stata_n_expr = expand_n_part
  if (is.na(stata_n_expr) || stata_n_expr == "") {
       return(paste0("# expand command requires N expression: ", rest_of_cmd))
  }

  # Translate N expression (can be variable or number)
  # Context for _n/_N etc. here is the original data.
  r_n_expr = translate_stata_expression_with_r_values(stata_n_expr, line_num, cmd_df, context = list(is_by_group=FALSE))
   if (is.na(r_n_expr) || r_n_expr == "") {
       return(paste0("# Failed to translate N expression for expand: ", stata_n_expr))
   }


  # Translate if condition
  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  # Translate in range (less common with expand, often done with if/in before)
  r_in_range_cond = NA_character_
  if (!is.na(stata_in_range) && stata_in_range != "") {
       # Stata `in f/l` refers to row numbers.
       range_match = stringi::stri_match_first_regex(stata_in_range, "^(\\d+)(?:/(\\d+))?$")
        if (!is.na(range_match[1,1])) {
            start_row = as.integer(range_match[1,2])
            end_row = range_match[1,3]
            if (is.na(end_row)) {
                 r_in_range_cond = paste0("dplyr::row_number() == ", start_row)
            } else {
                 r_in_range_cond = paste0("dplyr::row_number() >= ", start_row, " & dplyr::row_number() <= ", as.integer(end_row))
            }
        } else {
            return(paste0("# expand in range '", stata_in_range, "' not fully translated (f/l specifiers)."))
        }
  }

  # Combine if and in conditions if both exist
  final_r_subset_cond = NA_character_
  if (!is.na(r_if_cond) && !is.na(r_in_range_cond)) {
      final_r_subset_cond = paste0("(", r_if_cond, ") & (", r_in_range_cond, ")")
  } else if (!is.na(r_if_cond)) {
      final_r_subset_cond = r_if_cond
  } else if (!is.na(r_in_range_cond)) {
      final_r_subset_cond = r_in_range_cond
  }


  # R equivalent: use base::rep() on row indices.
  # The index vector will be 1 1 ... 2 2 ... N N ...
  # The number of repetitions for each row depends on the expression N and the if/in condition.
  # For rows where the condition is met, repeat N times. For rows where it's not met, repeat 1 time.
  # The N expression itself can be conditional (e.g., `expand num_copies if group=="A"`).
  # Example: `expand 2` -> `rep(1:NROW(data), each=2)` or `rep(1:NROW(data), times=2)` depending on desired order.
  # Stata `expand N` maintains original sort order by default (like `rep(..., each=N)`).
  # Example: `expand N if condition` -> `rep(1:NROW(data), times = ifelse(condition, N, 1))`

  # Build the `times` argument for rep()
  times_expr = r_n_expr

  if (!is.na(final_r_subset_cond) && final_r_subset_cond != "") {
      # Apply the condition: repeat N if cond, 1 otherwise
       # Need to evaluate the condition and the N expression row-wise on the original data.
       # This is hard to do directly in a single rep() call that operates on row indices.
       # Alternative: Create a temporary variable with the desired repetitions per row.
       # `data = data %>% mutate(__expand_times = ifelse(condition, N, 1))`
       # Then use `data[rep(1:NROW(data), times = data$__expand_times), ]`
       # However, `data` is the dataframe being transformed. We need the old `data` inside mutate.

       # A better approach: evaluate the times vector and the condition vector first, then use rep.
       # Let's generate R code that does this.
       temp_times_var = paste0("__expand_times_L", cmd_obj$line)
       temp_cond_var = paste0("__expand_cond_L", cmd_obj$line)

       r_code_lines = c(
           paste0(temp_times_var, " = (", r_n_expr, ")"), # Evaluate N expression
           paste0(temp_cond_var, " = (", final_r_subset_cond, ")"), # Evaluate condition
           # If condition is met, use temp_times_var. Otherwise, use 1.
           # Handle NA in condition: if condition is NA, row is not expanded.
           paste0(temp_times_final = "ifelse(!is.na(", temp_cond_var, ") & ", temp_cond_var, ", ", temp_times_var, ", 1)"),
           # Handle NA in N expression itself: Stata expand N where N is missing gives error.
           # R rep(..., times=NA) gives error. Need to handle.
           paste0(temp_times_final = "ifelse(is.na(", temp_times_final, "), 1, ", temp_times_final, ")"), # If N is NA, treat as 1? Or error? Stata errors. Let's allow 1 for NA N.
           # Repeat rows using the calculated times
           "data = data[base::rep(1:NROW(data), times = ", temp_times_final, "), ]",
           # Clean up temporary variables if they were created within the environment
           paste0("rm(", temp_times_var, ", ", temp_cond_var, ", ", temp_times_final, ")") # This assumes translation environment is function scope
           # If translation env is global, need to be careful with temp vars. Assume function scope for now.
       )
       r_code_str = paste(r_code_lines, collapse="\n")


  } else {
       # No if/in condition, just expand N times
       # Check if N is a single number or a variable/expression
       # If N is a variable/expression, Stata expands each observation N[i] times.
       # Example: `expand income_value` expands row i income_value[i] times.
       # This is the same logic as the conditional case, but without the condition.
       temp_times_var = paste0("__expand_times_L", cmd_obj$line)
        r_code_lines = c(
           paste0(temp_times_var, " = (", r_n_expr, ")"), # Evaluate N expression
           # Handle NA in N expression itself
           paste0(temp_times_var, " = ifelse(is.na(", temp_times_var, "), 1, ", temp_times_var, ")"),
           # Repeat rows using the calculated times
           "data = data[base::rep(1:NROW(data), times = ", temp_times_var, "), ]",
           # Clean up temporary variables
           paste0("rm(", temp_times_var, ")")
        )
       r_code_str = paste(r_code_lines, collapse="\n")

  }

  # Add comment about options if any were present but not handled
   options_str_cleaned = options_str # No options handled currently

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Options ignored: ", options_str_cleaned))
   }


  return(r_code_str)
}
!END_CHANGE_FILE R/t_expand.R

!CHANGE_FILE R/t_duplicates.R
# Translate Stata 'duplicates' command
# Stata: duplicates drop [varlist] [if] [in] [, options]
# Stata: duplicates tag varlist [if] [in] [, options] gen(newvar)
# Stata: duplicates list [varlist] [if] [in] [, options]

t_duplicates = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse subcommand (drop, tag, list)
  parts_subcmd = stringi::stri_split_regex(rest_of_cmd_trimmed, "\\s+", n=2)[[1]]
  subcommand = stringi::stri_trim_both(parts_subcmd[1])
  rest_after_subcmd = if(length(parts_subcmd) > 1) stringi::stri_trim_both(parts_subcmd[2]) else NA_character_

  if (is.na(subcommand) || !(subcommand %in% c("drop", "tag", "list"))) {
      return(paste0("# Failed to parse duplicates subcommand (drop, tag, or list required): ", rest_of_cmd))
  }

  # Parse varlist, if/in, options from rest_after_subcmd
  # Pattern: `varlist [if] [in] [, options]`
  # This is complex to parse robustly. Let's simplify: assume varlist comes first, then if/in, then options.

  varlist_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Find if/in first
  if_in_match = stringi::stri_match_first_regex(rest_after_subcmd, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rest_after_subcmd_no_if_in = stringi::stri_replace_last_regex(rest_after_subcmd, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rest_after_subcmd_no_if_in = stringi::stri_trim_both(rest_after_subcmd_no_if_in)
  } else {
      rest_after_subcmd_no_if_in = rest_after_subcmd
  }

   # Find options
  options_match = stringi::stri_match_first_regex(rest_after_subcmd_no_if_in, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      varlist_str = stringi::stri_replace_last_regex(rest_after_subcmd_no_if_in, ",\\s*(.*)$", "")
      varlist_str = stringi::stri_trim_both(varlist_str)
  } else {
      varlist_str = rest_after_subcmd_no_if_in
  }

  # Parse varlist (can be empty, means all variables)
  vars_for_duplicates = NA_character_
  if (!is.na(varlist_str) && varlist_str != "") {
      vars_for_duplicates_list = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
      vars_for_duplicates_list = vars_for_duplicates_list[vars_for_duplicates_list != ""]
       if (length(vars_for_duplicates_list) > 0) {
           vars_for_duplicates = paste0('c("', paste(vars_for_duplicates_list, collapse = '", "'), '")')
       }
  }


  # Translate the if/in condition for subsetting *before* duplicates logic
  r_subset_cond = NA_character_
  data_source_for_duplicates = "data"
  r_code_prefix = "" # Code to create subset if needed

  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      # Stata applies if/in condition *before* checking for duplicates.
      # The duplicates check only happens on the subset of data specified by if/in.
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group = FALSE))

      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for duplicates: ", stata_if_in_cond))
      }

      # Create a temporary subset variable
      data_subset_varname = paste0("data_subset_L", cmd_obj$line) # Use actual line from cmd_obj
      r_code_prefix = paste0(data_subset_varname, " = base::subset(data, ", r_subset_cond, ")\n")
      data_source_for_duplicates = data_subset_varname
  }


  r_code_str = ""

  if (subcommand == "drop") {
      # Stata `duplicates drop varlist [if] [in]`
      # Drops all but the first observation of each group defined by varlist (or all vars).
      # R equivalent: `dplyr::distinct(data, varlist, .keep_all = TRUE)`
      # The if/in condition means we only drop duplicates *within the subset* and keep non-subset rows.
      # This is complex. Simpler: apply distinct *after* subsetting if a subset is made.
      # But `duplicates drop if cond` means drop duplicate rows *among those satisfying cond*.
      # The ones NOT satisfying cond are kept, whether they were duplicates or not.
      # R: `data[!duplicated(data[cond, vars_for_duplicates]), ]` ... no, this is not quite right.

      # Let's follow the "subset first" logic for duplicates check.
      # If if/in is present, we check duplicates only within the subset.
      # This is *not* how Stata's `duplicates drop if` works. Stata evaluates `if` on the original data, then drops rows if they are duplicates *within that if-subset*.
      # Correct Stata `duplicates drop if condition, by(varlist)`: Consider only rows satisfying `condition`. Among those rows, drop ones that are duplicates based on `varlist`.
      # R equivalent: `data %>% filter(condition) %>% distinct(varlist, .keep_all = TRUE)` (drops rows). But we need to merge back with rows not satisfying condition.

      # A more accurate translation for `duplicates drop [varlist] [if exp]` would be:
      # 1. Identify duplicates based on varlist (or all vars) in the full dataset.
      # 2. Create a boolean vector `is_duplicate = duplicated(data[, varlist])`
      # 3. Create a boolean vector `satisfies_cond = eval(parse(text=r_if_cond))`. If no cond, all TRUE.
      # 4. Keep row if `!is_duplicate` (it's the first occurrence) OR `!satisfies_cond` (it's outside the subset being checked).
      #    Stata: `keep if !is_duplicate | !satisfies_cond`
      #    This is wrong. Stata `duplicates drop` drops the *later* duplicates.
      #    Stata keeps the first instance. `duplicates drop if cond` keeps the first instance (even if it doesn't meet cond), and subsequent instances *if they meet cond*.
      #    The logic is "Keep if (!is_duplicate) OR (is_duplicate AND !satisfies_cond)".
      #    i.e., Keep the first of any group, AND keep subsequent ones if they don't meet the condition.

      # R base: `!duplicated(data[, vars], fromLast=FALSE)` flags rows after the first.
      # Using `dplyr::distinct` is simpler but drops rows immediately.
      # Let's create the boolean flag first.

      # Vars to use for duplication check
      vars_for_distinct_r = if (is.na(vars_for_duplicates)) "NULL" else paste0("dplyr::all_of(", vars_for_duplicates, ")")

      # Check for duplicates in the data source (either original or subset)
      # `dplyr::distinct(data_source_for_duplicates, vars_for_duplicates)` finds unique rows.
      # To drop duplicates, we need the indices/rows to keep.
      # R base: `!duplicated(data_source_for_duplicates[, vars_list_char])`
      # We need the condition applied first, then duplicates check.
      # `data = data %>% group_by(vars) %>% filter(row_number() == 1)` (if no if/in)
      # `data = data %>% filter(condition) %>% group_by(vars) %>% filter(row_number() == 1)` (subset + drop in subset) - WRONG Stata logic.

      # Let's use the logic: Keep if NOT (is_duplicate AND satisfies_condition)
      # Requires calculating is_duplicate and satisfies_condition row-wise.

      # Calculate the condition vector
      cond_vector_expr = if (!is.na(r_subset_cond) && r_subset_cond != "") r_subset_cond else "TRUE" # TRUE if no condition

      # Calculate the duplicate flag vector
      # Need to handle case where vars_for_duplicates is NA (all columns)
      if (is.na(vars_for_duplicates)) {
          # duplicates drop without varlist uses all columns
          is_duplicate_expr = "base::duplicated(data, fromLast = FALSE)"
      } else {
           is_duplicate_expr = paste0("base::duplicated(data[, ", vars_for_duplicates, ", drop = FALSE], fromLast = FALSE)")
      }

      # R code to calculate and filter
      r_code_lines = c(
          paste0("## Calculate duplicate flag based on ", if(is.na(vars_for_duplicates)) "all variables" else "variables: ", varlist_str),
          paste0("__is_duplicate_L", cmd_obj$line, " = ", is_duplicate_expr),
          paste0("## Calculate condition flag"),
          paste0("__satisfies_cond_L", cmd_obj$line, " = ", cond_vector_expr),
          # Keep if !(__is_duplicate AND __satisfies_cond)
          paste0("data = base::subset(data, !(__is_duplicate_L", cmd_obj$line, " & __satisfies_cond_L", cmd_obj$line, "))"),
          # Clean up temp vars
          paste0("rm(__is_duplicate_L", cmd_obj$line, ", __satisfies_cond_L", cmd_obj$line, ")")
      )
       r_code_str = paste(r_code_lines, collapse="\n")


  } else if (subcommand == "tag") {
      # Stata `duplicates tag varlist [if] [in] , gen(newvar)`
      # Creates newvar (byte 0/1) where 1 indicates the first observation of a duplicate group defined by varlist (or all vars).
      # Only considers observations meeting the if/in condition.
      # The `gen()` option is required for tag.

      gen_var = NA_character_
      if (!is.na(options_str)) {
         gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgen\\s*\\(([^)]+)\\)")
         if (!is.na(gen_opt_match[1,1])) {
             gen_vars_str = stringi::stri_trim_both(gen_opt_match[1,2])
             gen_vars_list = stringi::stri_split_regex(gen_vars_str, "\\s+")[[1]] # Stata allows multiple, but tag generates one var.
             gen_var = gen_vars_list[1] # Take the first name if multiple provided (Stata might error?)
         }
      }

      if (is.na(gen_var)) {
          return(paste0("# duplicates tag requires gen() option: ", rest_of_cmd))
      }

      # Vars to use for duplication check (defaults to all if varlist missing)
      vars_for_distinct_r = if (is.na(vars_for_duplicates)) "NULL" else paste0("dplyr::all_of(", vars_for_duplicates, ")")

      # Calculate the condition vector
      cond_vector_expr = if (!is.na(r_subset_cond) && r_subset_cond != "") r_subset_cond else "TRUE"

      # Calculate the duplicate flag vector (Stata tag wants the *first* observation flagged)
      # R base: `!duplicated(data[, vars], fromLast=FALSE)` gives TRUE for the first, FALSE for subsequent.
       if (is.na(vars_for_duplicates)) {
          is_first_occurrence_expr = "!base::duplicated(data, fromLast = FALSE)"
      } else {
           is_first_occurrence_expr = paste0("!base::duplicated(data[, ", vars_for_duplicates, ", drop = FALSE], fromLast = FALSE)")
      }

      # The newvar is 1 if (is_first_occurrence AND satisfies_condition), otherwise 0.
      # Or missing (.) if the observation does not satisfy the condition? No, Stata sets it to 0 for unmatched.
      # Stata: `gen byte newvar = 0`. Then `replace newvar = 1 if !duplicated(...) & condition`.

      # R code to calculate and assign
       r_code_lines = c(
          paste0("## Calculate first occurrence flag based on ", if(is.na(vars_for_duplicates)) "all variables" else "variables: ", varlist_str),
          paste0("__is_first_L", cmd_obj$line, " = ", is_first_occurrence_expr),
          paste0("## Calculate condition flag"),
          paste0("__satisfies_cond_L", cmd_obj$line, " = ", cond_vector_expr),
          # Generate the new variable
          # Using collapse::fmutate
          paste0("data = collapse::fmutate(data, ", gen_var, " = dplyr::if_else(__is_first_L", cmd_obj$line, " & __satisfies_cond_L", cmd_obj$line, ", 1, 0))"),
           # Clean up temp vars
          paste0("rm(__is_first_L", cmd_obj$line, ", __satisfies_cond_L", cmd_obj$line, ")")
       )
      r_code_str = paste(r_code_lines, collapse="\n")

  } else if (subcommand == "list") {
       # Stata `duplicates list varlist [if] [in] [, options]`
       # Lists all duplicate observations (all copies including the first) based on varlist.
       # If if/in is used, only lists duplicates among those meeting the condition.
       # This means list if cond, by(varlist) - show all rows that are duplicates according to varlist, AND satisfy cond.
       # R: `data %>% group_by(vars) %>% filter(n() > 1) %>% filter(condition)`

       # Calculate the condition vector
      cond_vector_expr = if (!is.na(r_subset_cond) && r_subset_cond != "") r_subset_cond else "TRUE"

       # Calculate duplicate count per group
       # Need to group by vars, then count.
       # Using collapse:
       vars_for_grouping_r_vec_str = if (is.na(vars_for_duplicates)) {
            # Need to get all variable names from data, which is hard without access to `data`.
            # Return a partial translation or error?
            return("# duplicates list without varlist not fully supported (needs all variable names).")
       } else {
           vars_for_duplicates
       }

       # Group the data, filter for group size > 1, then filter by condition.
       # Stata `duplicates list` shows *all* members of duplicate groups, including the first, if *any* member of the group satisfies the condition and is a duplicate.
       # This logic is complex. Simpler: Just list rows where is_duplicate is TRUE (subsequent copies) AND condition is met.
       # Or: Filter data by condition, then identify duplicates within that subset? No, Stata definition is subtle.

       # Let's stick to the interpretation: list rows that are duplicates (not the first occurrence based on varlist) AND satisfy the condition.
       # Calculate the condition vector (already done as cond_vector_expr)
       # Calculate the duplicate flag vector (already done as is_duplicate_expr from `drop`)

       # R code to filter for listing
        if (is.na(vars_for_duplicates)) {
          is_duplicate_expr = "base::duplicated(data, fromLast = FALSE)"
      } else {
           is_duplicate_expr = paste0("base::duplicated(data[, ", vars_for_duplicates, ", drop = FALSE], fromLast = FALSE)")
      }

       r_code_lines = c(
          paste0("## Calculate duplicate flag based on ", if(is.na(vars_for_duplicates)) "all variables" else "variables: ", varlist_str),
          paste0("__is_duplicate_L", cmd_obj$line, " = ", is_duplicate_expr),
          paste0("## Calculate condition flag"),
          paste0("__satisfies_cond_L", cmd_obj$line, " = ", cond_vector_expr),
          # Filter for duplicates meeting the condition
          paste0("data_duplicates_L", cmd_obj$line, " = base::subset(data, __is_duplicate_L", cmd_obj$line, " & __satisfies_cond_L", cmd_obj$line, ")"),
          # Print the filtered data (Stata lists to console)
          paste0("print(data_duplicates_L", cmd_obj$line, ")"),
          # Clean up temp vars
          paste0("rm(__is_duplicate_L", cmd_obj$line, ", __satisfies_cond_L", cmd_obj$line, ", data_duplicates_L", cmd_obj$line, ")")
       )
      r_code_str = paste(r_code_lines, collapse="\n")

      # Note: `duplicates list` doesn't modify the data, but it is often used in a data manipulation context to diagnose issues.
      # `mark_data_manip_cmd` marks it FALSE, so this function might not even be called.
      # However, it *can* set r() values (r(N_dups)).

      # Revisit mark_data_manip_cmd: `duplicates list` should probably be translated if it's setting r() or if it's useful diagnostic output in the translated R.
      # The current `mark_data_manip_cmds` includes "duplicates". `non_manip_display_cmds` includes "list".
      # `duplicates list` is not in `non_manip_display_cmds`, so it *is* marked TRUE by default.
      # So this translation function *will* be called. Printing to console is the correct behavior.

  } else {
      r_code_str = paste0("# Unknown duplicates subcommand: ", subcommand)
  }

  # Add comment about options if any were present but not handled (excluding gen for tag)
   options_str_cleaned = options_str
   if (subcommand == "tag" && !is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bgen\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ",")) # Clean up multiple commas
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }


  return(r_code_str)
}
!END_CHANGE_FILE R/t_duplicates.R

!CHANGE_FILE R/t_encode.R
# Translate Stata 'encode' command
# Stata: encode varname [if] [in] , gen(newvar) [options]
# Converts string varname into numeric newvar with value labels.

t_encode = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varname, if/in, options (especially gen())
  # Pattern: `varname [if] [in] , options`

  varname_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Find if/in first
  if_in_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rest_no_if_in = stringi::stri_replace_last_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rest_no_if_in = stringi::stri_trim_both(rest_no_if_in)
  } else {
      rest_no_if_in = rest_of_cmd_trimmed
  }

   # Find options
  options_match = stringi::stri_match_first_regex(rest_no_if_in, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      varname_str = stringi::stri_replace_last_regex(rest_no_if_in, ",\\s*(.*)$", "")
      varname_str = stringi::stri_trim_both(varname_str)
  } else {
      varname_str = rest_no_if_in
  }

   if (is.na(varname_str) || varname_str == "") {
       return(paste0("# encode command requires varname: ", rest_of_cmd))
   }

  # Parse options, specifically `gen()`
  gen_var = NA_character_
  if (!is.na(options_str)) {
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgen\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars_str = stringi::stri_trim_both(gen_opt_match[1,2])
           gen_vars_list = stringi::stri_split_regex(gen_vars_str, "\\s+")[[1]]
           gen_var = gen_vars_list[1] # encode generates a single variable
       }
  }

  if (is.na(gen_var)) {
      return(paste0("# encode requires gen() option: ", rest_of_cmd))
  }

  # Translate if/in condition
  r_if_in_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
       r_if_in_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group=FALSE))
       if (is.na(r_if_in_cond) || r_if_in_cond == "") {
           return(paste0("# Failed to translate if/in condition for encode: ", stata_if_in_cond))
       }
  }

  # R equivalent: factor() or as.integer(factor())
  # Stata encode assigns integer codes (1, 2, ...) based on sorted unique values of the string variable.
  # R factor() does this by default. as.integer() retrieves the integer codes.
  # Value labels in R factor() correspond to Stata's encoded values.
  # Stata encode applies the gen option only to the variables listed before the comma.
  # If if/in is used, Stata encodes values *only for rows meeting the condition*.
  # For rows not meeting the condition, the new variable is set to missing.
  # This is similar to `gen newvar = .` followed by `replace newvar = ... if condition`.

   r_code_lines = c(
      # Generate the new variable initialized to NA (Stata missing)
      # Using collapse::fmutate
      paste0("data = collapse::fmutate(data, ", gen_var, " = NA_integer_)"),
      # Apply encode logic only to rows meeting the condition (or all rows if no condition)
      # Need to select relevant rows and the variable, calculate encoded values, then replace.

      # Calculate encoded values: factor() on the source variable
      paste0("__encoded_values_L", cmd_obj$line, " = as.integer(base::factor(data$", varname_str, ", levels = base::unique(data$", varname_str, "[base::order(data$", varname_str, ")])))")
      # Note: base::factor default levels are sorted unique values, matching Stata behavior.

   )

  # Apply the if/in condition for replacement
  if (!is.na(r_if_in_cond) && r_if_in_cond != "") {
      # Replace values in gen_var where condition is true
       r_code_lines = c(r_code_lines,
           paste0("## Calculate condition flag"),
           paste0("__satisfies_cond_L", cmd_obj$line, " = ", r_if_in_cond),
           paste0("data = collapse::fmutate(data, ", gen_var, " = dplyr::if_else(__satisfies_cond_L", cmd_obj$line, ", __encoded_values_L", cmd_obj$line, ", ", gen_var, "))"),
           paste0("rm(__satisfies_cond_L", cmd_obj$line, ")")
       )
  } else {
      # Replace values in gen_var for all rows
      r_code_lines = c(r_code_lines,
           paste0("data = collapse::fmutate(data, ", gen_var, " = __encoded_values_L", cmd_obj$line, ")")
      )
  }

  # Clean up temporary variable
  r_code_lines = c(r_code_lines, paste0("rm(__encoded_values_L", cmd_obj$line, ")"))

  # Add value labels to the new factor column for completeness/diagnostics if using haven/labelled
  # This requires retrieving the original labels/levels.
  # R factor stores levels. haven::labelled can store value labels.
  # For now, just perform the numeric conversion.

  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about options if any were present but not handled (excluding gen)
   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bgen\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ",")) # Clean up multiple commas
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }


  return(r_code_str)
}
!END_CHANGE_FILE R/t_encode.R

!CHANGE_FILE R/t_decode.R
# Translate Stata 'decode' command
# Stata: decode varname [if] [in] , gen(newvar) [options]
# Converts numeric varname with value labels into string newvar.

t_decode = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varname, if/in, options (especially gen())
  # Pattern: `varname [if] [in] , options`

  varname_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Find if/in first
  if_in_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rest_no_if_in = stringi::stri_replace_last_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rest_no_if_in = stringi::stri_trim_both(rest_no_if_in)
  } else {
      rest_no_if_in = rest_of_cmd_trimmed
  }

   # Find options
  options_match = stringi::stri_match_first_regex(rest_no_if_in, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      varname_str = stringi::stri_replace_last_regex(rest_no_if_in, ",\\s*(.*)$", "")
      varname_str = stringi::stri_trim_both(varname_str)
  } else {
      varname_str = rest_no_if_in
  }

   if (is.na(varname_str) || varname_str == "") {
       return(paste0("# decode command requires varname: ", rest_of_cmd))
   }

  # Parse options, specifically `gen()`
  gen_var = NA_character_
  if (!is.na(options_str)) {
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgen\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars_str = stringi::stri_trim_both(gen_opt_match[1,2])
           gen_vars_list = stringi::stri_split_regex(gen_vars_str, "\\s+")[[1]]
           gen_var = gen_vars_list[1] # decode generates a single variable
       }
  }

  if (is.na(gen_var)) {
      return(paste0("# decode requires gen() option: ", rest_of_cmd))
  }

  # Translate if/in condition
  r_if_in_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
       r_if_in_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group=FALSE))
       if (is.na(r_if_in_cond) || r_if_in_cond == "") {
           return(paste0("# Failed to translate if/in condition for decode: ", stata_if_in_cond))
       }
  }

  # R equivalent: as.character(labelled::to_factor(varname)) or similar
  # Stata decode uses value labels attached to the numeric variable (often created by encode).
  # haven package reads value labels into a "labelled" class. labelled::to_factor converts this.
  # as.character() converts the factor to strings.

  # Generate the new variable initialized to NA_character_ (Stata missing string is "")
  # Stata missing numeric decodes to missing string.
   r_code_lines = c(
      paste0("data = collapse::fmutate(data, ", gen_var, " = NA_character_)") # Initialize with NA string
   )

  # Calculate decoded values
  # Use haven::as_factor or labelled::to_factor to respect value labels, then as.character.
  # haven::as_factor handles labelled class from read_dta.
  # Need to handle potential errors if the source variable isn't labelled correctly.
   r_code_lines = c(r_code_lines,
      paste0("## Decode values using haven::as_factor"),
      paste0("__decoded_values_L", cmd_obj$line, " = as.character(haven::as_factor(data$", varname_str, ", levels = 'labels'))") # 'labels' uses value labels
   )

  # Apply the if/in condition for replacement
  if (!is.na(r_if_in_cond) && r_if_in_cond != "") {
      # Replace values in gen_var where condition is true
       r_code_lines = c(r_code_lines,
           paste0("## Calculate condition flag"),
           paste0("__satisfies_cond_L", cmd_obj$line, " = ", r_if_in_cond),
           # Need to be careful with types in if_else. If gen_var is character, __decoded_values_L must be character.
           paste0("data = collapse::fmutate(data, ", gen_var, " = dplyr::if_else(__satisfies_cond_L", cmd_obj$line, ", __decoded_values_L", cmd_obj$line, ", ", gen_var, "))"),
           paste0("rm(__satisfies_cond_L", cmd_obj$line, ")")
       )
  } else {
      # Replace values in gen_var for all rows
      r_code_lines = c(r_code_lines,
           paste0("data = collapse::fmutate(data, ", gen_var, " = __decoded_values_L", cmd_obj$line, ")")
      )
  }

  # Clean up temporary variable
  r_code_lines = c(r_code_lines, paste0("rm(__decoded_values_L", cmd_obj$line, ")"))


  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about options if any were present but not handled (excluding gen)
   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bgen\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ",")) # Clean up multiple commas
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }


  return(r_code_str)
}
!END_CHANGE_FILE R/t_decode.R

!CHANGE_FILE R/t_destring.R
# Translate Stata 'destring' command
# Stata: destring varlist [if] [in] , {generate(newvarlist) | replace} [options]
# Converts string variables into numeric variables.

t_destring = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varlist, if/in, options (generate() or replace)
  # Pattern: `varlist [if] [in] , options`

  varlist_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Find if/in first
  if_in_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rest_no_if_in = stringi::stri_replace_last_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rest_no_if_in = stringi::stri_trim_both(rest_no_if_in)
  } else {
      rest_no_if_in = rest_of_cmd_trimmed
  }

   # Find options (required)
  options_match = stringi::stri_match_first_regex(rest_no_if_in, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      varlist_str = stringi::stri_replace_last_regex(rest_no_if_in, ",\\s*(.*)$", "")
      varlist_str = stringi::stri_trim_both(varlist_str)
  } else {
      return(paste0("# destring command requires options (, gen() or , replace): ", rest_of_cmd))
  }

   if (is.na(varlist_str) || varlist_str == "") {
       return(paste0("# destring command requires varlist: ", rest_of_cmd))
   }

  vars_to_destring = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_destring = vars_to_destring[vars_to_destring != ""]
   if (length(vars_to_destring) == 0) {
       return(paste0("# destring command requires non-empty varlist: ", rest_of_cmd))
   }


  # Parse options, specifically `generate()` or `replace`
  is_replace = stringi::stri_detect_fixed(options_str, "replace")
  gen_vars = NA_character_
  if (!is_replace) {
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgenerate\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars = stringi::stri_trim_both(gen_opt_match[1,2])
       }
  }

  new_vars = NULL
  if (!is_replace) {
      if (is.na(gen_vars)) {
           return(paste0("# destring requires generate() option or replace option: ", rest_of_cmd))
      }
      new_vars = stringi::stri_split_regex(gen_vars, "\\s+")[[1]]
      new_vars = new_vars[new_vars != ""]
      if (length(new_vars) != length(vars_to_destring)) {
          return(paste0("# destring generate() option requires same number of new variables as old variables."))
      }
  } else {
      # If replace option, new vars are the same as old vars.
      new_vars = vars_to_destring
  }


  # Translate if/in condition
  r_if_in_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
       r_if_in_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group=FALSE))
       if (is.na(r_if_in_cond) || r_if_in_cond == "") {
           return(paste0("# Failed to translate if/in condition for destring: ", stata_if_in_cond))
       }
  }

  # R equivalent: readr::parse_number() or as.numeric()
  # readr::parse_number is better at handling non-numeric parts and commas/$, results in NA on failure.
  # as.numeric() often results in warnings/errors or NA on failure.
  # Stata destring option `ignore()` can specify characters to ignore. `force` allows unconvertible values to become missing.
  # `readr::parse_number` handles some of this.

  mutate_exprs = character(length(vars_to_destring))
  for (k in seq_along(vars_to_destring)) {
      old_var = vars_to_destring[k]
      new_var = new_vars[k]
      source_var_r = old_var # R variable name for the source column

      # Calculate destrung values
      # Using readr::parse_number
      destrung_value_expr = paste0("readr::parse_number(as.character(data$", source_var_r, "))")
      # as.character needed in case the variable is factor/labelled etc.

      # Apply the if/in condition for replacement
      if (!is.na(r_if_in_cond) && r_if_in_cond != "") {
          # For rows meeting condition, use destrung value. Otherwise, keep original (or NA if new var).
           if (is_replace) {
               # Replace in place: use destrung if condition, old value otherwise
               final_value_expr = paste0("dplyr::if_else(", r_if_in_cond, ", ", destrung_value_expr, ", ", source_var_r, ")")
           } else {
               # Generate new var: use destrung if condition, NA otherwise
               final_value_expr = paste0("dplyr::if_else(", r_if_in_cond, ", ", destrung_value_expr, ", NA_real_)") # Assuming numeric result
           }
      } else {
          # Apply to all rows
           final_value_expr = destrung_value_expr
      }

      mutate_exprs[k] = paste0(new_var, " = ", final_value_expr)
  }

   # Combine mutate expressions
  mutate_exprs_str = paste(mutate_exprs, collapse = ",\n  ")

  # Build the final R code using collapse::fmutate
  r_code_str = paste0("data = collapse::fmutate(data, ", mutate_exprs_str, ")")

  # Add comment about options if any were present but not handled (excluding generate/replace)
   options_str_cleaned = options_str
   # Remove generate() or replace from options string
   if (is_replace) {
       options_str_cleaned = stringi::stri_replace_first_fixed(options_str_cleaned, "replace", "")
   } else {
       options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bgenerate\\s*\\([^)]+\\)", "")
   }
   options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ",")) # Clean up multiple commas
   options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma


   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }


  return(r_code_str)
}
!END_CHANGE_FILE R/t_destring.R

!CHANGE_FILE R/t_egen.R
# Translate Stata 'egen' command
# Stata: egen [type] newvar = fcn(arguments) [if exp] [in range] [, options]

# This is a complex command with many functions.
# We'll implement a few common ones like mean, total, rank.
t_egen = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  # Basic parsing: newvar = function(args) [, by(groupvars)] [if condition]
  # Example: egen mean_i_grp = mean(i), by(group)
  # Example: egen total_i = total(i)
  # Example: bysort group: egen rank_i = rank(i) (Note: bysort handled by cmd_obj$is_by_prefix)

  # Remove type prefix if any (byte, int, long, float, double, str#, etc.)
  # Pattern: ^\s*(byte|int|long|float|double|str\d+)\s+
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^\\s*(?:byte|int|long|float|double|str\\d+)\\s+", "")

  # Re-parse rest_of_cmd_no_type looking for `newvar = fcn(args) [if cond] [, options]`
  # Split at the first `=`. Left is `newvar`. Right is `fcn(args) [if cond] [, options]`
  parts_eq = stringi::stri_split_fixed(rest_of_cmd_no_type, "=", n=2)[[1]]
  if(length(parts_eq) != 2) return(paste0("# Failed to parse egen command structure (no =): ", rest_of_cmd))

  new_var = stringi::stri_trim_both(parts_eq[1])
  right_part = stringi::stri_trim_both(parts_eq[2])

  # Split right_part at the first comma (if any) to separate function/args/if from options
  parts_comma = stringi::stri_split_fixed(right_part, ",", n=2)[[1]]
  func_args_if_part = stringi::stri_trim_both(parts_comma[1])
  options_str = if(length(parts_comma) > 1) stringi::stri_trim_both(parts_comma[2]) else NA_character_

  # Now parse func_args_if_part: `fcn(args) [if cond]`
  # Split at the first `(`
  parts_paren = stringi::stri_split_fixed(func_args_if_part, "(", n=2)[[1]]
  if(length(parts_paren) != 2) return(paste0("# Failed to parse egen function call: ", func_args_if_part))

  egen_func_name = stringi::stri_trim_both(parts_paren[1])
  args_and_if_part = stringi::stri_trim_both(stringi::stri_replace_last_fixed(parts_paren[2], ")", "")) # Remove trailing ')'

  # Now parse args_and_if_part: `args [if cond]` or `args [in range]`
  stata_if_cond_in_args = NA_character_
  stata_in_range_in_args = NA_character_
  egen_args_str = args_and_if_part

  # Look for `if` or `in` within the args part
  # Check for `if` first
  if_match_in_args = stringi::stri_match_first_regex(egen_args_str, "\\s+if\\s+(.*)$")
   if(!is.na(if_match_in_args[1,1])) {
      stata_if_cond_in_args = if_match_in_args[1,2]
      egen_args_str = stringi::stri_replace_last_regex(egen_args_str, "\\s+if\\s+(.*)$", "")
      egen_args_str = stringi::stri_trim_both(egen_args_str)
   }

  # Check for `in`
  in_match_in_args = stringi::stri_match_first_regex(egen_args_str, "\\s+in\\s+(.*)$")
   if(!is.na(in_match_in_args[1,1])) {
      stata_in_range_in_args = in_match_in_args[1,2]
      egen_args_str = stringi::stri_replace_last_regex(egen_args_str, "\\s+in\\s+(.*)$", "")
      egen_args_str = stringi::stri_trim_both(egen_args_str)
   }

  # Now we have: new_var, egen_func_name, egen_args_str, stata_if_cond_in_args, stata_in_range_in_args, options_str

  # Translate the condition/range if it exists
  r_if_cond_in_args = NA_character_
  if (!is.na(stata_if_cond_in_args) && stata_if_cond_in_args != "") {
       # Context for _n/_N in the if condition within egen args is usually the group context (if by_prefix used)
      r_if_cond_in_args = translate_stata_expression_with_r_values(stata_if_cond_in_args, line_num, cmd_df, context)
       if (is.na(r_if_cond_in_args) || r_if_cond_in_args == "") {
           return(paste0("# Failed to translate if condition in egen args: ", stata_if_cond_in_args))
       }
  }

   r_in_range_cond_in_args = NA_character_
  if (!is.na(stata_in_range_in_args) && stata_in_range_in_args != "") {
       # Context for _n/_N etc. in range is group context if by_prefix used.
       # Stata `in f/l` in egen refers to observation numbers *within the group* if bysort prefix is used.
       # Otherwise, it refers to global observation numbers.
       # The `context$is_by_group` flag from parse_stata_command_line indicates bysort prefix.
       context_for_range = list(is_by_group = cmd_obj$is_by_prefix)

       range_match = stringi::stri_match_first_regex(stata_in_range_in_args, "^(\\d+)(?:/(\\d+))?$")
        if (!is.na(range_match[1,1])) {
            start_row = as.integer(range_match[1,2])
            end_row = range_match[1,3]
            # Use _n R equivalent (dplyr::row_number() or .i in collapse)
            row_number_r_expr = if(context_for_range$is_by_group) ".i" else "dplyr::row_number()"

            if (is.na(end_row)) {
                 r_in_range_cond_in_args = paste0(row_number_r_expr, " == ", start_row)
            } else {
                 r_in_range_cond_in_args = paste0(row_number_r_expr, " >= ", start_row, " & ", row_number_r_expr, " <= ", as.integer(end_row))
            }
        } else {
            return(paste0("# egen in range '", stata_in_range_in_args, "' not fully translated (f/l specifiers)."))
        }
  }


  # Combine if and in conditions within args if both exist
  final_r_subset_cond_in_args = NA_character_
  if (!is.na(r_if_cond_in_args) && !is.na(r_in_range_cond_in_args)) {
      final_r_subset_cond_in_args = paste0("(", r_if_cond_in_args, ") & (", r_in_range_cond_in_args, ")")
  } else if (!is.na(r_if_cond_in_args)) {
      final_r_subset_cond_in_args = r_if_cond_in_args
  } else if (!is.na(r_in_range_cond_in_args)) {
      final_r_subset_cond_in_args = r_in_range_cond_in_args
  }


  # Translate arguments (usually variable names)
  # Context for _n/_N etc. in arguments is the group context if by_prefix is used.
  r_egen_args = translate_stata_expression_with_r_values(egen_args_str, line_num, cmd_df, context)
   if (is.na(r_egen_args) || r_egen_args == "") {
        # This might be ok if the function takes no arguments e.g. egen group_id = group()
        if (egen_func_name != "group") { # group() takes implicit args from by() or option
             warning(paste0("Failed to translate egen arguments: ", egen_args_str))
        }
   }


  # Apply if/in condition within the function call if needed
  # Example: mean(x if y>0) -> mean(ifelse(y>0, x, NA), na.rm = TRUE)
  # This requires modifying r_egen_args based on final_r_subset_cond_in_args
  if (!is.na(final_r_subset_cond_in_args) && final_r_subset_cond_in_args != "") {
      r_egen_args_conditional = paste0("base::ifelse(", final_r_subset_cond_in_args, ", ", r_egen_args, ", NA)")
  } else {
      r_egen_args_conditional = r_egen_args
  }


  # Determine by_vars: either from `cmd_obj$by_vars` (if `bysort group: egen...`) or from `options_str` (if `egen ..., by(group)`)
  by_vars_egen = NA_character_
  if (cmd_obj$is_by_prefix && !is.na(cmd_obj$by_vars)) {
    by_vars_egen = cmd_obj$by_vars
  } else if (!is.na(options_str)) {
    by_opt_match = stringi::stri_match_first_regex(options_str, "\\bby\\s*\\(([^)]+)\\)")
    if (!is.na(by_opt_match[1,1])) {
      by_vars_egen = stringi::stri_trim_both(by_opt_match[1,2])
    }
  }

  by_vars_r_vec_str = NULL # For collapse group_by: c("var1", "var2")
  if (!is.na(by_vars_egen)) {
    by_vars_list = stringi::stri_split_regex(by_vars_egen, "\\s+")[[1]]
    by_vars_list = by_vars_list[by_vars_list != ""]
    by_vars_r_vec_str = paste0('c("', paste0(by_vars_list, collapse='", "'), '")')
  }

  # Translate egen function
  # Resulting expression for mutate: `new_var = R_EQUIVALENT_EXPRESSION`
  mutate_value_expr = ""
  is_row_function = FALSE # Flag for functions like rowtotal, rowmean that don't use group_by


  # Switch for egen functions
  if (egen_func_name == "mean") {
    mutate_value_expr = paste0("mean(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "total" || egen_func_name == "sum") {
    mutate_value_expr = paste0("sum(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "count") {
    # count(exp) counts non-missing results of exp. If exp is varname, sum(!is.na(varname)).
    # If exp is complex, sum(eval(parse(text=r_egen_args_conditional)) != 0 & !is.na(eval(parse(text=r_egen_args_conditional))))
    # Assuming r_egen_args_conditional results in a numeric or logical vector
    mutate_value_expr = paste0("sum(!is.na(", r_egen_args_conditional, "))")
  } else if (egen_func_name == "rank") {
    mutate_value_expr = paste0("dplyr::min_rank(", r_egen_args_conditional, ")")
  } else if (egen_func_name == "median" || egen_func_name == "p50") {
    mutate_value_expr = paste0("median(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "sd" || egen_func_name == "std") {
    mutate_value_expr = paste0("sd(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "group") {
    # egen id = group(var1 var2) -> var1 and var2 are in egen_args_str, space separated.
    # If by_vars_egen is present, Stata `by group: egen id = group(a b)` implies grouping by group, then within groups by a and b for the ID.
    # Stata: group(varlist) assigns unique group codes based on varlist values *within* the by group.
    # Equivalent to sorting by by_vars then varlist, then using a cumulative counter or rank.
    # If by_vars_egen is present, the actual grouping for the ID is by_vars_egen + egen_args_str.
    # If by_vars_egen is NOT present, grouping is only by egen_args_str.
    # The sorting requirement for `tag` also applies to `group`.
    # Let's use collapse::fgroup_rank which works on a vector of columns within a group.
    # The columns to group by for fgroup_rank are the arguments in egen_args_str.
    # We need to pass these as quoted variable names or expressions.
    group_vars_for_func_list = stringi::stri_split_regex(r_egen_args, "\\s+")[[1]] # Use r_egen_args (translated)
    group_vars_for_func_list = group_vars_for_func_list[group_vars_for_func_list != ""]
    group_vars_r_vec_str_for_func = paste0('c("', paste(group_vars_for_func_list, collapse='", "'), '")') # Needs to be quoted vector for select/ftag/fgroup_rank

    # The `fgroup_rank` function should be applied within the grouping defined by `by_vars_egen`.
    # mutate_value_expr = paste0("collapse::fgroup_rank(dplyr::select(., dplyr::all_of(", group_vars_r_vec_str_for_func, ")))")
    # Using `dplyr::row_number()` within a grouped mutate is simpler and common.
    # Stata `egen id = group(v)` is like `bysort v: gen id = _n`. But it also handles value labels and sorts levels.
    # A simple integer sequence per group is `1:.N` or `dplyr::row_number()`.
    # `fgroup_rank` provides the overall group rank across observations, not row number within group.
    # `dplyr::group_indices` is also for overall group rank.
    # `Stata egen group` is closer to a unique identifier for each combination of `varlist` values *within* the `by` group.
    # `by A: egen id = group(B)` means id is unique for each combination of A and B.
    # R: `data %>% group_by(A) %>% mutate(id = group_indices(.)) %>% ungroup()` or `dplyr::group_indices(., A, B)`.
    # The `group()` arguments in Stata should be added to the `by_vars_egen` for R grouping purposes.
    # Let's combine by_vars_egen and egen_args_str for grouping in R.
    all_group_vars_list = c(stringi::stri_split_regex(by_vars_egen, "\\s+")[[1]], group_vars_for_func_list)
    all_group_vars_list = all_group_vars_list[!is.na(all_group_vars_list) & all_group_vars_list != ""]
    all_group_vars_r_vec_str = paste0('c("', paste(all_group_vars_list, collapse='", "'), '")')

    # Use collapse::fgroup_rank on the combined grouping variables
    mutate_value_expr = paste0("collapse::fgroup_rank(dplyr::select(., dplyr::all_of(", all_group_vars_r_vec_str, ")))")
    by_vars_r_vec_str = NULL # The grouping for this function is handled by the argument itself, not the by_vars_egen prefix in the typical summarize sense.

  } else if (egen_func_name == "tag") {
      # egen t = tag(v1 v2) implies sorting by v1 v2 first, then tagging first obs in each group defined by v1 v2.
      # If `by group: egen t = tag(v1 v2)`, it's within `group`, then by `v1 v2`.
      # This is complex and depends on whether the bysort prefix or the tag arguments define the "group".
      # Stata manual: `tag(varlist)` marks the first observation in each group defined by `varlist` *within* the current `by` group (if any).
      # So if by_vars_egen is present, the tag is within that group. If not, it's based on the tag arguments.
      # collapse::ftag(v) flags the first observation of each group based on values of v.
      # For `tag(v1 v2)`, it's `collapse::ftag(v1, v2)`.
      tag_vars_list = stringi::stri_split_regex(r_egen_args_conditional, "\\s+")[[1]] # Use conditional args? No, tag is based on original values. Use r_egen_args.
      tag_vars_list = stringi::stri_split_regex(r_egen_args, "\\s+")[[1]]
      tag_vars_list = tag_vars_list[tag_vars_list != ""]
      tag_vars_r_vec_str = paste0('c("', paste(tag_vars_list, collapse='", "'), '")')

      if (!is.null(by_vars_r_vec_str)) {
           # If there's a by group, tag is within that group.
           # Stata `by A: egen t = tag(B C)` is equivalent to `bysort A B C: gen byte t = _n==1`.
           # We need to ensure the correct sort order *before* calculating the first observation flag.
           # The code should sort by by_vars_egen THEN tag_vars_list before calculating the flag.
           # Sorting logic should ideally be a separate step if not guaranteed by `bysort` prefix.
           # If `bysort` prefix is used, data is already sorted. If `by()` option is used, Stata implies sort.
           # Let's assume the sorting is handled and use the row number within the group.
           # `.i == 1` in collapse within fmutate and fgroup_by gives the first observation *within* the group defined by fgroup_by.
           mutate_value_expr = paste0("as.integer(.i == 1)") # Using collapse group index, converted to integer (Stata byte 0/1)

      } else {
           # No by group. Tag is based on the tag_vars only.
           # Equivalent to `bysort tag_vars: gen byte t = _n==1`.
           # Use collapse::ftag which works on selecting columns.
           mutate_value_expr = paste0("as.integer(collapse::ftag(dplyr::select(., dplyr::all_of(", tag_vars_r_vec_str, "))))")
           by_vars_r_vec_str = NULL # Tag without BY is not a grouped operation in the same sense for the R code structure.
      }


  } else if (egen_func_name == "rowtotal") {
    vars_for_rowop_list = stringi::stri_split_regex(r_egen_args, "\\s+")[[1]] # Use non-conditional args here
    vars_for_rowop_list = vars_for_rowop_list[vars_for_rowop_list != ""]
    vars_for_rowop_r_vec_str = paste0('c("', paste(vars_for_rowop_list, collapse='", "'), '")')

    # Stata rowtotal treats NA as 0 *before* summing.
    # Using rowSums on a selection of columns after replacing NA with 0.
    # `rowSums(tidyr::replace_na(dplyr::select(., dplyr::all_of(", vars_for_rowop_r_vec_str, ")), 0))`
    mutate_value_expr = paste0("rowSums(tidyr::replace_na(dplyr::select(., dplyr::all_of(", vars_for_rowop_r_vec_str, ")), 0), na.rm = FALSE)") # na.rm=FALSE because we replaced NA with 0
    is_row_function = TRUE; by_vars_r_vec_str = NULL # Row functions don't use grouping in the same way
  } else if (egen_func_name == "rowmean") {
    vars_for_rowop_list = stringi::stri_split_regex(r_egen_args, "\\s+")[[1]] # Use non-conditional args here
    vars_for_rowop_list = vars_for_rowop_list[vars_for_rowop_list != ""]
    vars_for_rowop_r_vec_str = paste0('c("', paste(vars_for_rowop_list, collapse='", "'), '")')

    mutate_value_expr = paste0("rowMeans(dplyr::select(., dplyr::all_of(", vars_for_rowop_r_vec_str, ")), na.rm = TRUE)")
    is_row_function = TRUE; by_vars_r_vec_str = NULL
  } else {
    return(paste0("# Egen function '", egen_func_name, "' not yet implemented."))
  }

  # Combine into a mutate statement
  full_mutate_expr = paste0(new_var, " = ", mutate_value_expr)

  # Build the R command string using collapse functions
  if (!is.null(by_vars_r_vec_str) && !is_row_function) {
    r_code_str = paste0("data = collapse::fgroup_by(data, ", by_vars_r_vec_str, ") %>%\n",
                        "  collapse::fmutate(", full_mutate_expr, ") %>%\n",
                        "  collapse::fungroup()")
  } else {
    r_code_str = paste0("data = collapse::fmutate(data, ", full_mutate_expr, ")")
  }

   # Add comment about options if any were present but not handled (excluding by)
   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bby\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ",")) # Clean up multiple commas
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }


  return(r_code_str)
}

!END_CHANGE_FILE R/t_egen.R
***
