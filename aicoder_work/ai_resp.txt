!CHANGE_FILE R/t_collapse.R
```
# Translate Stata 'collapse' command
# Stata: collapse (stat) varlist [name=expr ...] [weight] [if] [in] [, options]
# Often: collapse (stat) varlist, by(groupvars)

t_collapse = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {

  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Split into aggregate definitions part and options part
  parts = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(.*?)(?:,\\s*(.*))?$")
  aggregate_part = stringi::stri_trim_both(parts[1,2])
  options_part = stringi::stri_trim_both(parts[1,3]) # NA if no options

  # Separate potential if/in from aggregate definitions
  stata_if_in_cond = NA_character_
  # Look for `if` or `in` immediately followed by a space
  if_in_match = stringi::stri_match_first_regex(aggregate_part, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      # Remove the if/in part from aggregate_part
      aggregate_part = stringi::stri_replace_last_regex(aggregate_part, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      aggregate_part = stringi::stri_trim_both(aggregate_part)
  }


  # Parse aggregate definitions: "(stat) var [= newvar] (stat) var [= newvar] ..."
  # Regex: \(stat_word\)\s+(target_var_word)(?:\s*=\s*(source_var_word))?  -- This is for form (stat) target = source
  # OR    \(stat_word\)\s+(source_and_target_var_word)                     -- This is for form (stat) source
  # The current regex is: \\(([a-zA-Z_]+)\\)\\s+([a-zA-Z0-9_]+)(?:\\s*=\s*([a-zA-Z0-9_]+))?
  # G1: stat (stat_from_regex)
  # G2: varname1 (g2_val_from_regex)
  # G3: varname2 (g3_val_from_regex) - optional
  # If G3 is NA: Stata form is (stat) G2. Here, G2 is source and target.
  # If G3 is not NA: Stata form is (stat) G2 = G3. Here, G2 is target, G3 is source.

  aggregate_matches = stringi::stri_match_all_regex(aggregate_part, "\\(([a-zA-Z_]+)\\)\\s+([a-zA-Z0-9_]+)(?:\\s*=\\s*([a-zA-Z0-9_]+))?")[[1]]
  # aggregate_matches will be a matrix: [match, stat, g2_val, g3_val]

  if (NROW(aggregate_matches) == 0) {
    return(paste0("# Failed to parse collapse aggregate definitions: ", aggregate_part))
  }

  # Parse options part for `by()`
  by_vars_collapse = NA_character_
  if (!is.na(options_part)) {
    by_opt_match = stringi::stri_match_first_regex(options_part, "\\bby\\s*\\(([^)]+)\\)")
    if (!is.na(by_opt_match[1,1])) {
      by_vars_collapse = stringi::stri_trim_both(by_opt_match[1,2])
    }
  }

  by_vars_r_vec_str = NULL # For collapse group_by: character vector c("var1", "var2")
  if (!is.na(by_vars_collapse)) {
    by_vars_list = stringi::stri_split_regex(by_vars_collapse, "\\s+")[[1]]
    by_vars_list = by_vars_list[by_vars_list != ""]
    by_vars_r_vec_str = paste0('c("', paste0(by_vars_list, collapse='", "'), '")')
  }

  # Translate the if/in condition for subsetting *before* collapse
  r_subset_cond = NA_character_
  data_source_for_collapse = "data"
  r_code_prefix = "" # Code to create subset if needed

  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for collapse: ", stata_if_in_cond))
      }
      data_subset_varname = paste0("data_subset_L", cmd_obj$line)
      r_code_prefix = paste0(data_subset_varname, " = base::subset(data, ", r_subset_cond, ")\n")
      data_source_for_collapse = data_subset_varname
  }


  # Build the summarise/aggregate expressions for collapse::fsummarise
  aggregate_exprs = character(NROW(aggregate_matches))
  for (j in 1:NROW(aggregate_matches)) {
    stat_from_regex = aggregate_matches[j, 2]
    g2_val_from_regex = aggregate_matches[j, 3]
    g3_val_from_regex = aggregate_matches[j, 4]

    actual_stata_source_var_name = ""
    actual_stata_target_var_name = ""

    if (is.na(g3_val_from_regex)) { # Matched (stat) g2_val_from_regex
        actual_stata_source_var_name = g2_val_from_regex
        actual_stata_target_var_name = g2_val_from_regex
    } else { # Matched (stat) g2_val_from_regex = g3_val_from_regex
        actual_stata_source_var_name = g3_val_from_regex    # G3 is source
        actual_stata_target_var_name = g2_val_from_regex    # G2 is target
    }

    # Translate actual Stata source variable name
    r_source_var = translate_stata_expression_with_r_values(actual_stata_source_var_name, line_num, cmd_df, context)
     if (is.na(r_source_var) || r_source_var == "") {
         return(paste0("# Failed to translate source variable '", actual_stata_source_var_name, "' for collapse stat '", stat_from_regex, "'"))
     }

    # Map Stata stats to collapse functions
    collapse_func = switch(stat_from_regex,
      "mean" = paste0("collapse::fmean(", r_source_var, ", na.rm = TRUE)"),
      "sum" = paste0("collapse::fsum(", r_source_var, ", na.rm = TRUE)"),
      "count" = paste0("collapse::fnobs(", r_source_var, ")"),
      "N" = paste0("collapse::fnobs(", r_source_var, ")"),
      "first" = paste0("collapse::ffirst(", r_source_var, ")"),
      "last" = paste0("collapse::flast(", r_source_var, ")"),
      "min" = paste0("collapse::fmin(", r_source_var, ", na.rm = TRUE)"),
      "max" = paste0("collapse::fmax(", r_source_var, ", na.rm = TRUE)"),
      "median" = paste0("collapse::fmedian(", r_source_var, ", na.rm = TRUE)"),
      "sd" = paste0("collapse::fsd(", r_source_var, ", na.rm = TRUE)"),
      "p1" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.01, na.rm = TRUE)"),
      "p5" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.05, na.rm = TRUE)"),
      "p10" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.10, na.rm = TRUE)"),
      "p25" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.25, na.rm = TRUE)"),
      "p75" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.75, na.rm = TRUE)"),
      "p90" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.90, na.rm = TRUE)"),
      "p95" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.95, na.rm = TRUE)"),
      "p99" = paste0("collapse::fquantile(", r_source_var, ", probs = 0.99, na.rm = TRUE)"),
      NULL
    )

    if (is.null(collapse_func)) {
        return(paste0("# Collapse stat '", stat_from_regex, "' not yet implemented."))
    }

    # The new variable name for R code is the actual_stata_target_var_name
    r_new_var_name = actual_stata_target_var_name
    aggregate_exprs[j] = paste0(r_new_var_name, " = ", collapse_func)
  }

  # Combine aggregate expressions
  aggregate_exprs_str = paste(aggregate_exprs, collapse = ",\n  ")

  # Build the final R code
  r_code_str = r_code_prefix # Add subsetting code if any

  if (!is.null(by_vars_r_vec_str)) {
    r_code_str = paste0(r_code_str,
                       "data = collapse::fgroup_by(", data_source_for_collapse, ", ", by_vars_r_vec_str, ") %>%\n",
                       "  collapse::fsummarise(", aggregate_exprs_str, ") %>%\n",
                       "  collapse::fungroup()")
  } else {
     r_code_str = paste0(r_code_str,
                       "data = collapse::fsummarise(", data_source_for_collapse, ", ", aggregate_exprs_str, ")")
  }

  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_collapse.R

!CHANGE_FILE R/t_expand.R
```
# Translate Stata 'expand' command
# Stata: expand N [if] [in] [, options]
# Creates N copies of each observation. N can be an expression.
# Example: expand 2
# Example: expand num_copies if condition

t_expand = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  parts_if = stringi::stri_split_regex(rest_of_cmd_trimmed, "\\s+if\\s+", n=2)[[1]]
  expand_n_part_or_cond = stringi::stri_trim_both(parts_if[1])
  stata_if_cond = if(length(parts_if) > 1) stringi::stri_trim_both(parts_if[2]) else NA_character_

  parts_in = stringi::stri_split_regex(expand_n_part_or_cond, "\\s+in\\s+", n=2)[[1]]
  stata_n_expr = stringi::stri_trim_both(parts_in[1])
  stata_in_range = if(length(parts_in) > 1) stringi::stri_trim_both(parts_in[2]) else NA_character_

  if (is.na(stata_n_expr) || stata_n_expr == "") {
       return(paste0("# expand command requires N expression: ", rest_of_cmd))
  }

  r_n_expr = translate_stata_expression_with_r_values(stata_n_expr, line_num, cmd_df, context = list(is_by_group=FALSE))
   if (is.na(r_n_expr) || r_n_expr == "") {
       return(paste0("# Failed to translate N expression for expand: ", stata_n_expr))
   }

  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  r_in_range_cond = NA_character_
  if (!is.na(stata_in_range) && stata_in_range != "") {
       range_match = stringi::stri_match_first_regex(stata_in_range, "^(\\d+)(?:/(\\d+))?$")
        if (!is.na(range_match[1,1])) {
            start_row = as.integer(range_match[1,2])
            end_row = range_match[1,3]
            if (is.na(end_row)) {
                 r_in_range_cond = paste0("dplyr::row_number() == ", start_row)
            } else {
                 r_in_range_cond = paste0("dplyr::row_number() >= ", start_row, " & dplyr::row_number() <= ", as.integer(end_row))
            }
        } else {
            return(paste0("# expand in range '", stata_in_range, "' not fully translated (f/l specifiers)."))
        }
  }

  final_r_subset_cond = NA_character_
  if (!is.na(r_if_cond) && !is.na(r_in_range_cond)) {
      final_r_subset_cond = paste0("(", r_if_cond, ") & (", r_in_range_cond, ")")
  } else if (!is.na(r_if_cond)) {
      final_r_subset_cond = r_if_cond
  } else if (!is.na(r_in_range_cond)) {
      final_r_subset_cond = r_in_range_cond
  }

  r_code_str = ""
  line_id = cmd_obj$line # Actual line number from the do-file for unique temp var names

  if (!is.na(final_r_subset_cond) && final_r_subset_cond != "") {
       temp_n_values_var = paste0("__expand_n_values_L", line_id)
       temp_cond_values_var = paste0("__expand_cond_values_L", line_id)
       final_times_calc_var = paste0("__final_expand_times_L", line_id)

       r_code_lines = c(
           paste0(temp_n_values_var, " = ", r_n_expr),
           paste0(temp_cond_values_var, " = ", final_r_subset_cond),
           paste0(final_times_calc_var, " = ifelse(!is.na(", temp_cond_values_var, ") & ", temp_cond_values_var, ", ",
                                             "ifelse(is.na(", temp_n_values_var, "), 1, pmax(0, as.integer(", temp_n_values_var, "))), ", # ensure N is non-negative integer, 1 if NA
                                             "1)"), # if condition not met, expand 1 time (keep original)
           paste0(final_times_calc_var, " = ifelse(is.na(", final_times_calc_var, "), 1, ", final_times_calc_var, ")"), # Ensure final times is not NA
           paste0("data = data[base::rep(1:NROW(data), times = ", final_times_calc_var, "), ]"),
           paste0("if (exists('", temp_n_values_var, "')) rm(", temp_n_values_var, ", ", temp_cond_values_var, ", ", final_times_calc_var, ")")
       )
       r_code_str = paste(r_code_lines, collapse="\n")
  } else {
       temp_n_values_var = paste0("__expand_n_values_L", line_id)
       final_times_calc_var = paste0("__final_expand_times_L", line_id)
        r_code_lines = c(
           paste0(temp_n_values_var, " = (", r_n_expr, ")"),
           paste0(final_times_calc_var, " = ifelse(is.na(", temp_n_values_var, "), 1, pmax(0, as.integer(", temp_n_values_var, ")))"), # ensure N is non-negative integer, 1 if NA
           paste0("data = data[base::rep(1:NROW(data), times = ", final_times_calc_var, "), ]"),
           paste0("if (exists('", temp_n_values_var, "')) rm(", temp_n_values_var, ", ", final_times_calc_var, ")")
        )
       r_code_str = paste(r_code_lines, collapse="\n")
  }

  options_str_cleaned = NA_character_ # expand has few options, not handled yet.
  # If options_str was parsed from original cmd:
  # options_str_cleaned = options_str

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Options ignored: ", options_str_cleaned))
   }

  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_expand.R
