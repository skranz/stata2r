The primary issue causing the `do2` test failure was a `missing value where TRUE/FALSE needed` error originating from the `if (any(base::duplicated(...)))` checks within the `t_merge` function for `1:1` merges. This occurs when the `any()` function receives a logical vector containing `NA`s but no `TRUE`s, causing `any()` to return `NA`, which is invalid for an `if` condition. The fix involves wrapping these conditions with `isTRUE()`.

Additionally, the `mark_data_manip_cmd` function was overly broad in its initial marking of commands for translation, including commands like `summarize` and `regress` that do not inherently modify the dataset but might produce results (`e()` or `r()`) that are used by *subsequent* data manipulation commands. To align with the project's goal of only translating data-modifying commands or those that produce *needed* results, the `stata_cmd_utils.R` file has been updated to refine the categorization of Stata commands. Consequently, `mark_data_manip_cmd` has been revised to leverage these new categories and correctly identify which commands should be translated based on whether their results are actively consumed later in the script.

Finally, the `t_summarize` function has been updated to only calculate and store `r()` results if they are explicitly marked as `needed` by the `mark_data_manip_cmd` function, further optimizing the generated R code.

!CHANGE_FILE R/stata_cmd_utils.R
```R
# Stata command utilities

# Main Stata commands and their abbreviations
# This list is not exhaustive but covers many common commands.
stata_cmd_abbreviations = list(
  "a" = "append",
  "br" = "browse",
  "by" = "bysort", # 'by' is often a prefix, but can be 'bysort'
  "cap" = "capture",
  "cd" = "cd",
  "cl" = "clear", # clear all
  "co" = "collapse",
  "comp" = "compress",
  "conf" = "confirm",
  "cons" = "constraint",
  "contr" = "contrast",
  "cop" = "copy",
  "cor" = "correlate",
  "cou" = "count",
  "d" = "describe",
  "de" = "decode",
  "dest" = "destring",
  "di" = "display",
  "dir" = "dir",
  "do" = "do",
  "dr" = "drop",
  "du" = "duplicates",
  "e" = "edit",
  "eg" = "egen",
  "en" = "encode",
  "er" = "erase",
  "est" = "estimates", # estimates command group
  "ex" = "expand",
  "f" = "fillin",
  "g" = "generate",
  "gr" = "graph",
  "gs" = "gsort",
  "h" = "help",
  "i" = "inspect",
  "ins" = "insheet",
  "k" = "keep",
  "l" = "list",
  "la" = "label",
  "logi" = "logit", # Example statistical procedure
  "m" = "merge",
  "mark" = "marksample",
  "markout" = "markout",
  "mat" = "matrix",
  "mem" = "memory",
  "mkdir" = "mkdir",
  "mo" = "more",
  "mov" = "move",
  "mv" = "mvdecode", # mvdecode is a command
  "n" = "notes",
  "o" = "order",
  "ou" = "outsheet",
  "p" = "predict", # predict for generating variables from models
  "pres" = "preserve",
  # "q" = "quietly", # Quietly is a prefix, handled differently
  "r" = "recode",
  "reg" = "regress", # Example statistical procedure
  "ren" = "rename",
  "res" = "reshape",
  "rest" = "restore",
  "ret" = "return", # For return values from programs
  "rm" = "rmdir",
  "ru" = "run", # alias for do
  "sa" = "save",
  "sc" = "scalar",
  "se" = "set", # set memory, set type, etc.
  "sh" = "shell",
  "sig" = "signestim",
  "so" = "sort",
  "st" = "stata", # invoke Stata
  "su" = "summarize",
  "sy" = "sysuse",
  "t" = "tabulate", # tabulate can set r() values
  "te" = "test", # For hypotheses tests
  "temp" = "tempfile", # tempfile, tempvar, tempname
  "ty" = "type", # list content of a file
  "u" = "use",
  "v" = "version", # version control
  "w" = "which", # find file
  "xi" = "xi" # For indicator variable generation
  # "x" = "xtile" # egen function typically
)

# Function to get the full Stata command name from a token (could be an abbreviation)
get_stata_full_cmd_name = function(cmd_token) {
  restore.point("get_stata_full_cmd_name")
  if (is.na(cmd_token) || cmd_token == "") { # Defensive check
    return(NA_character_)
  }
  cmd_token_lower = tolower(cmd_token)
  # Use isTRUE to handle potential NA from %in% (though unlikely for this context)
  if (isTRUE(cmd_token_lower %in% names(stata_cmd_abbreviations))) {
    return(stata_cmd_abbreviations[[cmd_token_lower]])
  }
  # If not in abbreviations, assume it's already a full (or unrecognized) command
  return(cmd_token_lower)
}


# List of Stata commands considered to modify the dataset
stata_data_manip_cmds = c(
  "append", "collapse", "compress", "contract", "decode", "destring", "drop",
  "duplicates", "egen", "encode", "expand", "fillin",
  "generate", "gen", "gsort", "input", "insheet", "keep", "label",
  "merge", "modify", "move", "mvdecode", "mvrecode", "order", "pctile",
  "predict",
  "preserve", "recode", "rename", "reshape", "restore", "sample", "set",
  "sort", "stack", "statsby", "stsplit",
  "svar", "sysuse",
  "tempfile", "tempvar", "tempname",
  "total",
  "use", "xtile",
  "replace", "clear"
)

# Commands that primarily display info or control program flow, and *never* modify data or produce e()/r() results for later use.
stata_non_data_manip_cmds = c(
  "assert", "browse", "capture", "cd", "confirm", "constraint", "display", "di", "do", "edit", "erase", "error",
  "exit", "findit", "format", "graph", "gr", "help", "h", "if", "inspect", "i", "list", "l", "log", "lookup", "marksample",
  "matrix", "mat", "memory", "mem", "mkdir", "more", "mo", "notes", "n", "outfile", "outsheet", "ou", "pause", "plot",
  "print", "program", "pwd", "query",
  "return", "ret", "rmdir", "run", "ru", "scalar", "sc", "search", "shell", "sh", "signestim", "sleep",
  "stata", "st", "tabdisp", "table", "test", "te", "timer", "translate", "truncate",
  "tutorials", "type", "ty", "view", "version", "v", "webuse", "w", "which", "while", "window", "winexec", "xmlsav"
)

# List of estimation commands that can produce e() results
stata_estimation_cmds = c(
  "regress", "logit", "probit", "ivregress", "xtreg", "areg", "sem", "asmixlogit", "gmm", "xi"
)

# List of commands that can produce r() results
stata_r_result_cmds = c(
  "summarize", "su", "tabulate", "tab", "count", "correlate"
)


# Helper to parse basic Stata command line: cmd + rest
# Tries to handle `by varlist : command` and `quietly command` prefixes.
# Returns:
#   stata_cmd_original: original first token of the effective command (e.g. "g" for "gen")
#   stata_cmd: full command name of the effective command (e.g. "generate")
#   rest_of_cmd: string after effective command token
#   is_by_prefix: logical, TRUE if "by/bysort prefix:" was found
#   by_group_vars: character vector of grouping variables from by/bysort prefix
#   by_sort_vars: character vector of sort-only variables (in parentheses) from by/bysort prefix
#   is_quietly_prefix: logical, TRUE if "quietly" prefix was found
parse_stata_command_line = function(line_text) {
  restore.point("parse_stata_command_line")
  trimmed_line = stringi::stri_trim_both(line_text)

  is_by_prefix_val = FALSE
  by_group_vars = character(0)
  by_sort_vars = character(0)
  raw_by_string_from_prefix = NA_character_
  rest_of_line_for_cmd_parse = trimmed_line

  # Check for "by ... :" or "bysort ... :" prefix
  if (dplyr::coalesce(stringi::stri_startswith_fixed(trimmed_line, "by "), FALSE) ||
      dplyr::coalesce(stringi::stri_startswith_fixed(trimmed_line, "bysort "), FALSE)) {
    prefix_match = stringi::stri_match_first_regex(trimmed_line, "^(?:by|bysort)\\s+([^:]+?)\\s*:\\s*(.*)$")
    if (!is.na(prefix_match[1,1])) {
      raw_by_string_from_prefix = stringi::stri_trim_both(prefix_match[1,2])
      rest_of_line_for_cmd_parse = stringi::stri_trim_both(prefix_match[1,3])
      is_by_prefix_val = TRUE

      by_tokens = character(0)
      if (!is.na(raw_by_string_from_prefix) && raw_by_string_from_prefix != "") {
          match_result = stringi::stri_match_all_regex(raw_by_string_from_prefix, "\\s*(\\([^)]+\\)|[^\\s()]+)\\s*")
          if (!is.null(match_result[[1]]) && NROW(match_result[[1]]) > 0) {
              by_tokens = match_result[[1]][,2]
          }
      }

      for (token in by_tokens) {
        if (dplyr::coalesce(stringi::stri_startswith_fixed(token, "(") && stringi::stri_endswith_fixed(token, ")"), FALSE)) {
          sort_vars_in_paren = stringi::stri_sub(token, 2, -2)
          by_sort_vars = c(by_sort_vars, stringi::stri_split_regex(stringi::stri_trim_both(sort_vars_in_paren), "\\s+")[[1]])
        } else {
          by_group_vars = c(by_group_vars, token)
        }
      }
      by_group_vars = by_group_vars[!is.na(by_group_vars) & by_group_vars != ""]
      by_sort_vars = by_sort_vars[!is.na(by_sort_vars) & by_sort_vars != ""]
    }
  }

  # Check for "quietly" prefix on the (potentially by-prefixed) command part
  is_quietly_prefix_val = FALSE
  # Regex to match "quietly" or "qui" or "q" as a whole word prefix followed by space
  quietly_prefix_regex = "^(?:quietly|qui|q)\\s+(.*)$"
  quietly_match = stringi::stri_match_first_regex(rest_of_line_for_cmd_parse, quietly_prefix_regex)

  if (!is.na(quietly_match[1,1])) {
      # Check if the matched prefix is indeed "quietly" or its abbreviation
      # and not just a command starting with "q" that isn't "quietly" (e.g. "query").
      # The first token before the space:
      first_token_before_space = stringi::stri_extract_first_words(rest_of_line_for_cmd_parse)
      if (tolower(first_token_before_space) %in% c("quietly", "qui", "q")) {
        is_quietly_prefix_val = TRUE
        rest_of_line_for_cmd_parse = stringi::stri_trim_both(quietly_match[1,2]) # The part after "quietly "
      }
  }


  # Extract command token from the (now prefix-stripped) line
  parts = stringi::stri_split_fixed(rest_of_line_for_cmd_parse, " ", n = 2)
  cmd_token_original = stringi::stri_trim_both(parts[[1]][1])

  if (is.na(cmd_token_original) || cmd_token_original == "") {
      return(list(
        stata_cmd_original = NA_character_,
        stata_cmd = NA_character_,
        rest_of_cmd = NA_character_,
        is_by_prefix = is_by_prefix_val,
        by_group_vars = character(0),
        by_sort_vars = character(0),
        is_quietly_prefix = is_quietly_prefix_val # Added
      ))
  }

  stata_cmd = get_stata_full_cmd_name(cmd_token_original)
  rest_of_cmd = if (length(parts[[1]]) > 1 && !is.na(parts[[1]][2])) stringi::stri_trim_both(parts[[1]][2]) else NA_character_

  # Refine is_by_prefix: it's a prefix if by_vars were parsed AND command is not 'bysort'
  if (stata_cmd == "bysort" || stata_cmd == "by") {
      is_by_prefix_val = FALSE
      by_group_vars = character(0)
      by_sort_vars = character(0)
      if (stata_cmd == "by") stata_cmd = "bysort"
  }

  return(list(
    stata_cmd_original = cmd_token_original, # First token of effective command
    stata_cmd = stata_cmd,                   # Full name of effective command
    rest_of_cmd = rest_of_cmd,
    is_by_prefix = is_by_prefix_val,
    by_group_vars = by_group_vars,
    by_sort_vars = by_sort_vars,
    is_quietly_prefix = is_quietly_prefix_val # Added
  ))
}

# Helper function to get macro names from a tempfile command's rest_of_cmd
get_tempfile_macros = function(rest_of_cmd_for_tempfile) {
    restore.point("get_tempfile_macros")
    if (is.na(rest_of_cmd_for_tempfile) || rest_of_cmd_for_tempfile == "") return(character(0))
    stringi::stri_split_regex(rest_of_cmd_for_tempfile, "\\s+")[[1]] %>%
        stringi::stri_trim_both() %>%
        .[. != ""]
}

# Helper function to unquote Stata string literals
unquote_stata_string_literal = function(s) {
  restore.point("unquote_stata_string_literal")
  if (is.na(s) || s == "") return(s)
  # Remove outer double quotes
  if (dplyr::coalesce(stringi::stri_startswith_fixed(s, '"') && stringi::stri_endswith_fixed(s, '"'), FALSE)) {
    return(stringi::stri_sub(s, 2, -2))
  }
  # Remove outer single quotes
  if (dplyr::coalesce(stringi::stri_startswith_fixed(s, "'") && stringi::stri_endswith_fixed(s, "'"), FALSE)) {
    return(stringi::stri_sub(s, 2, -2))
  }
  # If not quoted, return as is
  return(s)
}

# Helper function to ensure a string is quoted for R literal use if not already
# This function expects an already UNQUOTED string (no Stata-style quotes)
quote_for_r_literal = function(s) {
  restore.point("quote_for_r_literal")
  if (is.na(s)) return("NA_character_")
  if (s == "") return('""')
  # Check if already quoted with " or '
  if (dplyr::coalesce(stringi::stri_startswith_fixed(s, '"') && stringi::stri_endswith_fixed(s, '"'), FALSE)) return(s)
  if (dplyr::coalesce(stringi::stri_startswith_fixed(s, "'") && stringi::stri_endswith_fixed(s, "'"), FALSE)) return(s)
  # Add double quotes
  paste0('"', s, '"')
}

# Helper function to resolve Stata filenames (literal or macro) to R path expressions
# default_base_dir_var: name of the variable in stata2r_env (e.g., "working_dir", "data_dir")
resolve_stata_filename = function(raw_filename_token, cmd_df, line_num, default_base_dir_var = "working_dir") {
  restore.point("resolve_stata_filename")
  unquoted_content = unquote_stata_string_literal(raw_filename_token)

  # Check if it's a Stata local macro reference `macroname'`
  if (dplyr::coalesce(stringi::stri_startswith_fixed(unquoted_content, "`") && stringi::stri_endswith_fixed(unquoted_content, "'"), FALSE)) {
    macro_name = stringi::stri_sub(unquoted_content, 2, -2)

    found_def_line = NA_integer_
    for (i in (line_num - 1):1) {
        if (cmd_df$stata_cmd[i] == "tempfile") {
            defined_macros = get_tempfile_macros(cmd_df$rest_of_cmd[i])
            if (macro_name %in% defined_macros) {
                found_def_line = cmd_df$line[i]
                break
            }
        }
    }

    if (!is.na(found_def_line)) {
        return(paste0("R_tempfile_L", found_def_line, "_", macro_name, "_path"))
    } else {
        warning(paste0("Macro ", unquoted_content, " in command at line ", line_num, " not resolved from tempfile. Treating as literal string."))
        return(quote_for_r_literal(unquoted_content))
    }
  } else {
    # It's a regular path string
    is_absolute_path = dplyr::coalesce(stringi::stri_startswith_fixed(unquoted_content, "/"), FALSE) ||
                       dplyr::coalesce(stringi::stri_detect_regex(unquoted_content, "^[A-Za-z]:[\\\\/]"), FALSE)

    if (is_absolute_path) {
      return(quote_for_r_literal(unquoted_content))
    } else {
      return(paste0("file.path(stata2r_env$", default_base_dir_var, ", ", quote_for_r_literal(unquoted_content), ")"))
    }
  }
}

get_xi_base_name = function(varname) {
  # Stata's xi naming convention for base variable part is complex and heuristic.
  # This function attempts to replicate some observed behaviors from `do3.log`.
  if (base::endsWith(varname, "_factor")) {
    return(stringi::stri_replace_last_fixed(varname, "_factor", "_f"))
  } else if (varname == "region_cat") {
    # Specific truncation observed in do3.log: region_cat (10 chars) -> region_ca (8 chars)
    return("region_ca")
  } else {
    # For other variables like "group_cat" (9 chars), it seems to keep the full name.
    # This rule is a heuristic based on limited test cases.
    return(varname)
  }
}

get_xi_interaction_basename = function(var1, var2) {
  # Heuristic for Stata's xi interaction naming (e.g., region_cat*group_cat -> regXgro)
  # Takes first 3 characters of each variable's *original* name, concatenates with 'X'.
  short_var1 = stringi::stri_sub(var1, 1, min(stringi::stri_length(var1), 3))
  short_var2 = stringi::stri_sub(var2, 1, min(stringi::stri_length(var2), 3))
  return(paste0(short_var1, "X", short_var2))
}

```
!END_CHANGE_FILE R/stata_cmd_utils.R

!CHANGE_FILE R/mark_data_manip_cmd.R
```R
mark_data_manip_cmd = function(cmd_df) {
  restore.point("mark_data_manip_cmd")

  if (NROW(cmd_df) == 0) {
    cmd_df$do_translate = logical(0)
    # Ensure e_results_needed and r_results_needed exist if cmd_df is empty but structured
    if (!("e_results_needed" %in% names(cmd_df))) cmd_df$e_results_needed = I(vector("list", 0))
    if (!("r_results_needed" %in% names(cmd_df))) cmd_df$r_results_needed = I(vector("list", 0))
    return(cmd_df)
  }

  cmd_df$do_translate = rep(FALSE, NROW(cmd_df))
  # Ensure list columns are initialized if not present (e.g. from older cmd_df structure)
  if (!("e_results_needed" %in% names(cmd_df))) {
    cmd_df$e_results_needed = I(replicate(nrow(cmd_df), character(0), simplify = FALSE))
  }
  if (!("r_results_needed" %in% names(cmd_df))) {
     cmd_df$r_results_needed = I(replicate(nrow(cmd_df), character(0), simplify = FALSE))
  }


  # --- First pass: Mark commands that are inherently data-modifying ---
  # These commands *always* modify the dataset directly.
  cmd_df$do_translate = cmd_df$stata_cmd %in% stata_data_manip_cmds
  # Ensure 'save' is always translated. (It already is in stata_data_manip_cmds)


  # --- Second pass: Determine which commands produce e() or r() results that are *actually used* ---
  # Iterate backwards to find the *last* command producing a needed result.
  active_needed_e_results = character(0) # e.g., "e(sample)", "e(b)"
  active_needed_r_results = character(0) # e.g., "r(N)", "r(mean)"

  for (i in NROW(cmd_df):1) {
    current_cmd = cmd_df$stata_cmd[i]
    rest_of_cmd = dplyr::coalesce(cmd_df$rest_of_cmd[i], "")

    # Identify e() and r() usage in the current command's `rest_of_cmd`
    used_e_macros = character(0)
    matches_e_used = stringi::stri_match_all_regex(rest_of_cmd, "e\\(([^)]+)\\)")[[1]]
    if (NROW(matches_e_used) > 0) {
        used_e_macros = unique(paste0("e(", matches_e_used[,2], ")"))
    }

    used_r_macros = character(0)
    matches_r_used = stringi::stri_match_all_regex(rest_of_cmd, "r\\(([^)]+)\\)")[[1]]
    if (NROW(matches_r_used) > 0) {
        used_r_macros = unique(paste0("r(", matches_r_used[,2], ")"))
    }

    # If any of these used macros are currently needed from a *previous* producer, mark this command for translation
    if (any(used_e_macros %in% active_needed_e_results) || any(used_r_macros %in% active_needed_r_results)) {
        cmd_df$do_translate[i] = TRUE
    }

    # Add results that this command *would produce* to active_needed_e/r_results if they are not already.
    # And mark this command to translate if it produces a needed result.

    # Commands producing e() results (e.g., regress, xi)
    if (current_cmd %in% stata_estimation_cmds) {
      # List all e() results that this type of command can produce.
      # This list should be comprehensive for the command's potential outputs.
      potential_e_results_produced = c("e(sample)", "e(N)", "e(r2)", "e(df_r)", "e(rmse)", "e(b)", "e(V)") # Example for regress/xi
      
      # If any of these potential results are currently needed, then this command is the producer.
      if (any(potential_e_results_produced %in% active_needed_e_results)) {
          cmd_df$do_translate[i] = TRUE
          # Store which results this command should actually produce
          cmd_df$e_results_needed[[i]] = union(cmd_df$e_results_needed[[i]], intersect(potential_e_results_produced, active_needed_e_results))
          # Remove these from active_needed_e_results as we've found their producer
          active_needed_e_results = setdiff(active_needed_e_results, potential_e_results_produced)
      }
    }

    # Commands producing r() results (e.g., summarize, tabulate, count)
    if (current_cmd %in% stata_r_result_cmds) {
      # For now, only common r() values are tracked. Extend as needed.
      potential_r_results_produced = c("r(N)", "r(mean)", "r(sd)", "r(min)", "r(max)", "r(sum)", "r(p50)") # Example for summarize
      
      if (any(potential_r_results_produced %in% active_needed_r_results)) {
          cmd_df$do_translate[i] = TRUE
          cmd_df$r_results_needed[[i]] = union(cmd_df$r_results_needed[[i]], intersect(potential_r_results_produced, active_needed_r_results))
          active_needed_r_results = setdiff(active_needed_r_results, potential_r_results_produced)
      }
    }
    
    # Add any results used by *this* command to `active_needed_e/r_results` for prior commands to produce.
    # This must be done *after* checking if current command is a producer of these results.
    active_needed_e_results = union(active_needed_e_results, used_e_macros)
    active_needed_r_results = union(active_needed_r_results, used_r_macros)
  }

  # --- Final explicit overrides ---
  # Commands that are definitely not data manipulation (e.g. `list`, `display` for scalars)
  # If a command is in stata_non_data_manip_cmds, it should be FALSE unless its r() or e() results are *explicitly* needed.
  for (k in seq_len(NROW(cmd_df))) {
      if (cmd_df$stata_cmd[k] %in% stata_non_data_manip_cmds) {
          # Only set to FALSE if it was not marked TRUE because its r() or e() results are needed.
          if (! (isTRUE(cmd_df$do_translate[k]) &&
                 (length(unlist(cmd_df$r_results_needed[k])) > 0 || length(unlist(cmd_df$e_results_needed[k])) > 0) ) ) {
              cmd_df$do_translate[k] = FALSE
          }
      }
  }

  # If stata_cmd is NA (e.g. empty line or parse error), don't translate
  cmd_df$do_translate[is.na(cmd_df$stata_cmd)] = FALSE

  # `clear` as a command clears memory. `use "file", clear` is different.
  # `clear` option is handled by `t_use`.
  # Standalone `clear` command should be translated.
  if ("clear" %in% cmd_df$stata_cmd) {
      cmd_df$do_translate[cmd_df$stata_cmd == "clear" & (is.na(cmd_df$rest_of_cmd) | cmd_df$rest_of_cmd == "")] = TRUE # standalone clear
  }
  
  return(cmd_df)
}

```
!END_CHANGE_FILE R/mark_data_manip_cmd.R

!CHANGE_FILE R/t_merge.R
```R
# Translate Stata 'merge' command
# Stata: merge 1:1 varlist using filename [, options]
# Stata: merge 1:m varlist using filename [, options]
# Stata: merge m:1 varlist using filename [, options]
# Stata: merge m:m varlist using filename [, options]
# Options: keep(match master using all) nogenerate

t_merge = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_merge") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Define a temporary indicator column name for dplyr::join
  indicator_col_name = paste0("stata_merge_indicator_L", line_num)

  # Parse merge type (1:1, 1:m, m:1, m:m), varlist, `using filename`, and options
  merge_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*([1m]:[1m])\\s+(.*?)\\s+using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")
  merge_type = NA_character_
  varlist_str = NA_character_
  raw_filename_token = NA_character_
  options_str = NA_character_


  if (is.na(merge_match[1,1])) {
      # Check for older syntax without type: `merge varlist using filename` (defaults to 1:1)
      merge_match_old = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(.*?)\\s+using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")
      if (!is.na(merge_match_old[1,1])) {
           merge_type = "1:1" # Assume 1:1 if type not specified
           varlist_str = stringi::stri_trim_both(merge_match_old[1,2])
           raw_filename_token = stringi::stri_trim_both(merge_match_old[1,3])
           options_str = stringi::stri_trim_both(merge_match_old[1,4])
      } else {
           return(paste0("# Failed to parse merge command: ", rest_of_cmd))
      }
  } else {
      merge_type = merge_match[1,2]
      varlist_str = stringi::stri_trim_both(merge_match[1,3])
      raw_filename_token = stringi::stri_trim_both(merge_match[1,4])
      options_str = stringi::stri_trim_both(merge_match[1,5]) # NA if no options
  }

  vars_to_merge_on = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_merge_on = vars_to_merge_on[vars_to_merge_on != ""]
  if (length(vars_to_merge_on) == 0) {
       return(paste0("# merge command requires varlist: ", rest_of_cmd))
  }
  # For dplyr::join, by argument can be a character vector of column names
  # Create a temporary R variable to hold the character vector of merge keys
  merge_keys_r_var = paste0("stata_merge_keys_L", line_num)
  vars_to_merge_on_r_vec_str = paste0('c("', paste(vars_to_merge_on, collapse = '", "'), '")')


  using_source_r_expr = resolve_stata_filename(raw_filename_token, cmd_df, line_num, default_base_dir_var = "working_dir")

  # Determine if nogenerate option is present (for comments later)
  has_nogenerate = dplyr::coalesce(stringi::stri_detect_regex(options_str, "\\bno(?:generate|gen)\\b"), FALSE)
  
  # Determine keep_spec_for_comment and also the dplyr join function
  actual_keep_spec_from_options = NA_character_
  if (!is.na(options_str)) {
      keep_opt_match = stringi::stri_match_first_regex(options_str, "\\bkeep\\s*\\(([^)]+)\\)")
      if (!is.na(keep_opt_match[1,1])) {
          actual_keep_spec_from_options = stringi::stri_trim_both(keep_opt_match[1,2])
      }
  }

  # Set initial defaults based on merge_type
  if (merge_type == "m:m") {
      dplyr_join_func = "dplyr::full_join"
      keep_spec_for_comment = "match master using"
  } else { # For 1:1, 1:m, m:1 (default is "match master" i.e. left_join)
      dplyr_join_func = "dplyr::left_join"
      keep_spec_for_comment = "match master"
  }

  # Override default if specific keep() option is provided
  if (!is.na(actual_keep_spec_from_options)) {
      if (stringi::stri_detect_regex(actual_keep_spec_from_options, "\\ball\\b")) {
          dplyr_join_func = "dplyr::full_join"
          keep_spec_for_comment = "all"
      } else if (stringi::stri_detect_regex(actual_keep_spec_from_options, "\\bmatch\\b")) {
          dplyr_join_func = "dplyr::inner_join"
          keep_spec_for_comment = "match"
      } else if (stringi::stri_detect_regex(actual_keep_spec_from_options, "\\bmaster\\b")) {
          dplyr_join_func = "dplyr::left_join"
          keep_spec_for_comment = "master"
      } else if (stringi::stri_detect_regex(actual_keep_spec_from_options, "\\busing\\b")) {
          dplyr_join_func = "dplyr::right_join"
          keep_spec_for_comment = "using"
      }
  }

  # Adjusted for Stata's `keep(match master)` for any merge type, which often implies inner_join.
  # Stata's `keep(match master)` means "keep all observations from the master dataset that have a match in the using dataset".
  # This is equivalent to an inner join, as it only keeps rows present in both.
  if (actual_keep_spec_from_options == "match master") {
      dplyr_join_func = "dplyr::inner_join"
      keep_spec_for_comment = "match master (inner_join)"
  }


  # --- Start building R code lines ---
  r_code_lines = c()
  temp_using_data_var = paste0("stata_tmp_using_data_L", line_num)

  # Define the merge keys as an R variable
  r_code_lines = c(r_code_lines, paste0(merge_keys_r_var, " = ", vars_to_merge_on_r_vec_str))


  # Read using data
  r_code_lines = c(r_code_lines, paste0(temp_using_data_var, " = haven::read_dta(", using_source_r_expr, ")"))

  # Strip haven attributes from both master and using dataframes before joining
  # And normalize string NAs
  r_code_lines = c(r_code_lines, paste0("data = sfun_strip_stata_attributes(data)"))
  r_code_lines = c(r_code_lines, paste0("data = sfun_normalize_string_nas(data)")) # Added
  r_code_lines = c(r_code_lines, paste0(temp_using_data_var, " = sfun_strip_stata_attributes(", temp_using_data_var, ")"))
  r_code_lines = c(r_code_lines, paste0(temp_using_data_var, " = sfun_normalize_string_nas(", temp_using_data_var, ")")) # Added

  # Ensure merge keys are plain numeric for robustness against haven-specific types
  # Use the merge_keys_r_var for dynamic selection
  r_code_lines = c(r_code_lines,
      paste0("data = dplyr::mutate(data, dplyr::across(dplyr::all_of(", merge_keys_r_var, "), as.numeric))"),
      paste0(temp_using_data_var, " = dplyr::mutate(", temp_using_data_var, ", dplyr::across(dplyr::all_of(", merge_keys_r_var, "), as.numeric))")
  )

  # Logic for 1:1 merge strictness
  if (merge_type == "1:1") {
      r_code_lines = c(r_code_lines,
          paste0("if (isTRUE(any(base::duplicated(dplyr::select(data, dplyr::all_of(", merge_keys_r_var, ")))))) { stop('Merge 1:1 failed: Duplicate keys found in master dataset (data).') }"),
          paste0("if (isTRUE(any(base::duplicated(dplyr::select(", temp_using_data_var, ", dplyr::all_of(", merge_keys_r_var, ")))))) { stop('Merge 1:1 failed: Duplicate keys found in using dataset (', ", using_source_r_expr, ", ').') }")
      )
  }

  # Identify common columns that are NOT merge keys
  r_code_lines = c(r_code_lines,
    paste0("common_cols = intersect(names(data), names(", temp_using_data_var, "))"),
    paste0("common_cols_not_by = setdiff(common_cols, ", merge_keys_r_var, ")")
  )

  # Conditional dropping of columns from the using dataset
  # Stata's merge logic: if a variable exists in both, the master's version is kept.
  # So, columns in `using` data that conflict with `master` data should be dropped from `using` before join.
  r_code_lines = c(r_code_lines,
    paste0("if (length(common_cols_not_by) > 0) { ", temp_using_data_var, " = dplyr::select(", temp_using_data_var, ", -dplyr::all_of(common_cols_not_by)) }")
  )

  # Perform the chosen join
  r_code_lines = c(r_code_lines,
    paste0("data = ", dplyr_join_func, "(data, ", temp_using_data_var, ", by = ", merge_keys_r_var, ", indicator = \"", indicator_col_name, "\")")
  )

  # No further filter needed based on `keep_spec_for_comment` because the chosen join function
  # already implements the desired keep logic (e.g., left_join for master, inner_join for match).
  # The `indicator` column will correctly reflect the join outcome.

  r_code_lines = c(r_code_lines, paste0("data = sfun_normalize_string_nas(data)"))


  # Generate _merge variable unless nogenerate option is present
  if (!has_nogenerate) {
      r_code_lines = c(r_code_lines,
          paste0("data = dplyr::mutate(data, `_merge` = dplyr::case_when("),
          paste0("  data[['", indicator_col_name, "']] == \"left_only\" ~ 1L,"),
          paste0("  data[['", indicator_col_name, "']] == \"right_only\" ~ 2L,"),
          paste0("  data[['", indicator_col_name, "']] == \"both\" ~ 3L,"),
          paste0("  TRUE ~ NA_integer_"), # Fallback for any unexpected values or NAs (shouldn't happen with indicator)
          paste0("))")
      )
  } else {
    r_code_lines = c(r_code_lines, paste0(" # _merge variable was not generated due to 'nogenerate' option."))
  }

  # Always remove the temporary indicator column
  r_code_lines = c(r_code_lines, paste0("data = dplyr::select(data, -dplyr::any_of('", indicator_col_name, "'))"))

  # Clean up temporary variables
  r_code_lines = c(r_code_lines, paste0("rm(", temp_using_data_var, ", common_cols, common_cols_not_by, ", merge_keys_r_var, ")"))
  

  # Add comment about options
  merge_comment_line = paste0("# Stata merge type: ", merge_type, ", keep(", keep_spec_for_comment, ")")
  if (has_nogenerate) {
    merge_comment_line = paste0(merge_comment_line, ", nogenerate")
  }
  r_code_lines = c(r_code_lines, merge_comment_line)

  options_str_cleaned = options_str
  if (!is.na(options_str_cleaned)) {
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bkeep\\s*\\([^)]+\\)", "")
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bno(?:generate|gen)\\b", "")
      options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
  }
  if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
       r_code_lines = c(r_code_lines, paste0(" # Other options ignored: ", options_str_cleaned))
  }

  return(paste(r_code_lines, collapse="\n"))
}

```
!END_CHANGE_FILE R/t_merge.R

!CHANGE_FILE R/t_summarize.R
```R
# Translate Stata 'summarize' or 'su' command
t_summarize = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_summarize")
  # Stata: summarize varlist [if] [in] [weight] [, options]
  # Options: detail, meanonly, format, separator(#), nolabel
  # Stores results in r()

  # Check if any r() results are actually needed by a subsequent command
  needed_r_results = unlist(cmd_obj$r_results_needed)

  if (length(needed_r_results) == 0) {
    # If no r() results are needed, this summarize command doesn't need to produce any R output.
    return(paste0("# summarize command at line ", line_num, " translated to no-op as no r() results used later."))
  }

  parts = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*([^,]*?)(?:,\\s*(.*))?$")
  varlist_and_cond_str = stringi::stri_trim_both(parts[1,2]) # This may contain "var1 var2 if condition"
  options_str = stringi::stri_trim_both(parts[1,3]) # NA if no options

  # Separate varlist from if condition
  stata_if_cond_expr = NA_character_
  varlist_str = varlist_and_cond_str
  if_cond_match = stringi::stri_match_first_regex(varlist_and_cond_str, "\\s+if\\s+(.*)$")
  if(!is.na(if_cond_match[1,1])) {
      stata_if_cond_expr = if_cond_match[1,2]
      varlist_str = stringi::stri_replace_all_fixed(varlist_and_cond_str, if_cond_match[1,1], "")
      varlist_str = stringi::stri_trim_both(varlist_str)
  }

  vars_to_summarize = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_summarize = vars_to_summarize[vars_to_summarize != ""]

  # Determine the variable for r() values.
  # If varlist is empty, r(N) is total observations in the sample. Other r() are usually for the first variable.
  # If varlist is present, r(N), r(mean), etc. are for the *last* variable in the varlist.
  var_for_r_vals = NA_character_
  if (length(vars_to_summarize) > 0) {
      var_for_r_vals = vars_to_summarize[length(vars_to_summarize)] # Last variable in varlist
  } else {
      # If no variables are specified, summarize just counts observations.
      # r(N) is the only relevant r() value.
      if (!("r(N)" %in% needed_r_results)) {
          return(paste0("# summarize command at line ", line_num, " translated to no-op as no r() results used later and no variables specified."))
      }
  }

  r_code_lines = c()
  line_prefix = paste0("stata_r_val_L", cmd_obj$line, "_") # Use cmd_obj$line

  # Prepare data subset if "if condition" is present
  data_source_for_summary = "data"
  if (!is.na(stata_if_cond_expr)) {
    r_subset_cond = translate_stata_expression_with_r_values(stata_if_cond_expr, cmd_obj$line, cmd_df, context = list(is_by_group = FALSE))
    data_subset_varname = paste0("data_subset_L", cmd_obj$line)
    r_code_lines = c(r_code_lines, paste0(data_subset_varname, " = collapse::fsubset(data, (dplyr::coalesce(as.numeric(", r_subset_cond, "), 0) != 0))")) # Used fsubset
    data_source_for_summary = data_subset_varname
  }

  # Calculate r(N) if needed
  if ("r(N)" %in% needed_r_results) {
      if (is.na(var_for_r_vals)) {
          r_code_lines = c(r_code_lines, paste0(line_prefix, "N = NROW(", data_source_for_summary, ")"))
      } else {
          r_code_lines = c(r_code_lines, paste0(line_prefix, "N = sum(!is.na(", data_source_for_summary, "[['", var_for_r_vals, "']]))"))
      }
  }

  if (!is.na(var_for_r_vals)) {
      if ("r(mean)" %in% needed_r_results) {
          r_code_lines = c(r_code_lines, paste0(line_prefix, "mean = collapse::fmean(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"))
      }
      if ("r(sd)" %in% needed_r_results) {
          r_code_lines = c(r_code_lines, paste0(line_prefix, "sd = collapse::fsd(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"))
      }
      if ("r(min)" %in% needed_r_results) {
          r_code_lines = c(r_code_lines, paste0(line_prefix, "min = collapse::fmin(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"))
      }
      if ("r(max)" %in% needed_r_results) {
          r_code_lines = c(r_code_lines, paste0(line_prefix, "max = collapse::fmax(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"))
      }
      if ("r(sum)" %in% needed_r_results) {
          r_code_lines = c(r_code_lines, paste0(line_prefix, "sum = collapse::fsum(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"))
      }
      if ("r(p50)" %in% needed_r_results) {
          r_code_lines = c(r_code_lines, paste0(line_prefix, "p50 = collapse::fmedian(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"))
      }
  }

  if (data_source_for_summary != "data") {
      r_code_lines = c(r_code_lines, paste0("rm(", data_subset_varname, ")"))
  }

  # Add comment about options (no longer used for logic, but for informative comment)
  options_str_cleaned = options_str
  if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
      r_code_lines = c(r_code_lines, paste0(" # Other options ignored: ", options_str_cleaned))
  }

  if (length(r_code_lines) == 0) {
    return(paste0("# summarize command at line ", line_num, " translated to no-op as no r() results needed for later steps."))
  }

  return(paste(r_code_lines, collapse="\n"))
}

```
!END_CHANGE_FILE R/t_summarize.R
