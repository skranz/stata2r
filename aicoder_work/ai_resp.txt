!CHANGE_FILE R/do_cmd_to_r.R
```
  # r_obj will be a single row tibble
  # at least with the field r_code
do_cmd_to_r = function(cmd_obj, line, cmd_df) { # Corrected signature: added cmd_obj
  # cmd_obj is already the current line's data from cmd_df
  # line is the index, cmd_df is the full parsed do-file dataframe

  # ignore do commands that are flagged not to
  # be translated (because they don't manipulate the data set)
  if (!cmd_obj$do_translate || is.na(cmd_obj$stata_cmd)) {
    # Still return a structure that bind_rows expects, but with NA r_code
     return(data.frame(line=line, r_code = NA_character_, do_code = cmd_obj$do_code, stringsAsFactors = FALSE))
  }

  r_code = NA_character_

  # Context for expression translation (e.g. _n, _N behavior)
  translation_context = list(
    is_by_group = cmd_obj$is_by_prefix
    # can add more context like current data name if it changes from 'data'
  )

  # Dispatch to specific translation functions
  # These functions should take (cmd_obj, cmd_df, line_num, translation_context)
  # and return a string of R code.

  # Remove NA from rest_of_cmd for cleaner passing
  rest_of_cmd_clean = ifelse(is.na(cmd_obj$rest_of_cmd), "", cmd_obj$rest_of_cmd)

  # Use a switch for command dispatch
  # Each t_ function is responsible for parsing `rest_of_cmd_clean`
  # and using `translation_context`, `cmd_obj`, `cmd_df` as needed.
  # They should return a string of R code.
  stata_command = cmd_obj$stata_cmd

  # Store generated R variable names for tempfiles or r() values if needed to pass state
  # This is tricky with main.R's lapply. For now, variable names are deterministically generated.

  r_code = switch(stata_command,
    "use" = t_use(rest_of_cmd_clean, cmd_obj, cmd_df, line),
    "generate" = t_generate(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
    "gen" = t_generate(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context), # Alias
    "replace" = t_replace(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
    "summarize" = t_summarize(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
    "su" = t_summarize(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context), # Alias
    "egen" = t_egen(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
    "sort" = t_sort(rest_of_cmd_clean, cmd_obj, cmd_df, line, type="sort"),
    "gsort" = t_sort(rest_of_cmd_clean, cmd_obj, cmd_df, line, type="gsort"),
    "drop" = t_drop(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
    "keep" = t_keep(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
    "collapse" = t_collapse(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
    "rename" = t_rename(rest_of_cmd_clean, cmd_obj, cmd_df, line),
    "save" = t_save(rest_of_cmd_clean, cmd_obj, cmd_df, line),
    "tempfile" = t_tempfile(rest_of_cmd_clean, cmd_obj, cmd_df, line),
    "merge" = t_merge(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
    "append" = t_append(rest_of_cmd_clean, cmd_obj, cmd_df, line),
    "reshape" = t_reshape(rest_of_cmd_clean, cmd_obj, cmd_df, line),
    "recode" = t_recode(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
    "order" = t_order(rest_of_cmd_clean, cmd_obj, cmd_df, line),
    "expand" = t_expand(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
    "duplicates" = t_duplicates(rest_of_cmd_clean, cmd_obj, cmd_df, line),
    "encode" = t_encode(rest_of_cmd_clean, cmd_obj, cmd_df, line),
    "decode" = t_decode(rest_of_cmd_clean, cmd_obj, cmd_df, line),
    "destring" = t_destring(rest_of_cmd_clean, cmd_obj, cmd_df, line),
    "preserve" = t_preserve_restore(cmd_obj, type = "preserve"),
    "restore" = t_preserve_restore(cmd_obj, type = "restore"),
    # Add more commands here...
    # Fallback for unhandled but translatable commands:
    paste0("# Stata command '", cmd_obj$stata_cmd_original, " ", rest_of_cmd_clean, "' not yet fully translated.")
  )

  # If r_code is NULL (function not implemented), use default message
  if (is.null(r_code)) {
      r_code = paste0("# Stata command '", cmd_obj$stata_cmd_original, " ", rest_of_cmd_clean, "' (",stata_command,") translation not implemented.")
  }


  # Result object
  r_obj = data.frame(line=line, r_code = r_code, do_code = cmd_obj$do_code, stringsAsFactors = FALSE)
  return(r_obj)
}

```
!END_CHANGE_FILE R/do_cmd_to_r.R

!CHANGE_FILE R/do_parse.R
```
do_parse = function(do_code) {
  # do_code is a list of character vectors, each vector is a line
  # Ensure do_code is a simple character vector
  if (is.list(do_code) && length(do_code) == 1 && is.character(do_code[[1]])){
      do_code = do_code[[1]]
  } else if (is.list(do_code)) {
      # If multiple elements in list, try to unlist if structure is simple
      # This might happen if stri_split_fixed returns a list of single strings
      do_code = unlist(do_code)
  }


  num_lines = length(do_code)
  if (num_lines == 0) {
    return(data.frame(
      line = integer(0),
      do_code = character(0),
      stata_cmd_original = character(0),
      stata_cmd = character(0),
      rest_of_cmd = character(0),
      by_vars = character(0),
      is_by_prefix = logical(0)
    ))
  }

  cmd_list = lapply(seq_along(do_code), function(i) {
    line_text = do_code[i]
    parsed_info = parse_stata_command_line(line_text)
    data.frame(
      line = i,
      do_code = line_text,
      stata_cmd_original = parsed_info$stata_cmd_original,
      stata_cmd = parsed_info$stata_cmd,
      rest_of_cmd = parsed_info$rest_of_cmd,
      by_vars = ifelse(is.na(parsed_info$by_vars), NA_character_, parsed_info$by_vars),
      is_by_prefix = parsed_info$is_by_prefix,
      stringsAsFactors = FALSE
    )
  })

  cmd_df = dplyr::bind_rows(cmd_list)
  return(cmd_df)
}

```
!END_CHANGE_FILE R/do_parse.R

!CHANGE_FILE R/mark_data_manip_cmd.R
```
mark_data_manip_cmd = function(cmd_df) {
  # Determine commands that actually can transform the Stata data
  # set or generate scalars/temp files that will be used in later
  # commands that change the data set.

  if (NROW(cmd_df) == 0) {
    cmd_df$do_translate = logical(0)
    return(cmd_df)
  }

  cmd_df$do_translate = rep(FALSE, NROW(cmd_df))

  # Simple case: command is in stata_data_manip_cmds list
  cmd_df$do_translate = cmd_df$stata_cmd %in% stata_data_manip_cmds

  # Special handling for commands like `summarize`
  # If `summarize` produces `r()` results, and a later command uses them,
  # then `summarize` should be translated.
  # This is complex. For now, assume `summarize` that is not just for display (e.g. has options like meanonly, or is followed by r() usage)
  # For a first pass, mark all `summarize` as TRUE if it's in stata_data_manip_cmds.
  # A more sophisticated approach would involve checking for subsequent `r()` usage.

  # For commands like `tempfile`, they don't change `data` but set up for later changes.
  # These are already in `stata_data_manip_cmds`.

  # Commands that are definitely not data manipulation (e.g. `list`, `display` for scalars)
  # `display` can be used to show `r()` results. If those results are not part of data manip chain, ignore.
  # Non-data modifying commands or pure display commands.
  # These are marked FALSE even if they slip through the stata_data_manip_cmds list logic.
  non_manip_display_cmds = c("list", "display", "describe", "help", "about", "query", "set more off", "set rmsg on") # etc.
  cmd_df$do_translate[cmd_df$stata_cmd %in% non_manip_display_cmds] = FALSE

  # If stata_cmd is NA (e.g. empty line or parse error), don't translate
  cmd_df$do_translate[is.na(cmd_df$stata_cmd)] = FALSE

  # `clear` as a command clears memory, can be translated to `rm(list=ls())` or `data = NULL`
  # but `use "file", clear` is different. `clear` option is handled by `t_use`.
  # if `clear` is a standalone command and `stata_cmd` becomes "clear"
  if ("clear" %in% cmd_df$stata_cmd) {
      cmd_df$do_translate[cmd_df$stata_cmd == "clear" & is.na(cmd_df$rest_of_cmd)] = TRUE # standalone clear
  }


  # Example refinement for `summarize`:
  # Only translate `summarize` if it seems to be for `r()` values.
  # A simple proxy: if it has options (like `meanonly`, `detail`).
  # Or if a subsequent command refers to `r(...)`. (This lookahead is complex here).
  # For now, this is simplified. If `summarize` is in stata_data_manip_cmds, it's TRUE.

  return(cmd_df)
}

```
!END_CHANGE_FILE R/mark_data_manip_cmd.R

!CHANGE_FILE R/t_egen.R
```
# Translate Stata 'egen' command
# Stata: egen [type] newvar = fcn(arguments) [if exp] [in range] [, options]
# Options: by(varlist), etc.

# This is a complex command with many functions.
# We'll implement a few common ones like mean, total, rank.
t_egen = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  # Basic parsing: newvar = function(args) [, by(groupvars)] [if condition]
  # Example: egen mean_i_grp = mean(i), by(group)
  # Example: egen total_i = total(i)
  # Example: bysort group: egen rank_i = rank(i) (Note: bysort handled by cmd_obj$is_by_prefix)

  # Remove type prefix if any
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^(?:byte|int|long|float|double)\\s+", "")

  # Regex to get `newvar = func(args)` and optional `if` and `options` (like by())
  # Pattern: newvar = func(var) [if cond] [, options]
  # `^\s*([^=\s]+)\s*=\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)\)\s*(?:if\s+(.*?))?\s*(?:,\s*(.*))?$`
  # G1: newvar, G2: func, G3: args_inside_paren, G4: if_cond, G5: options_str

  main_match = stringi::stri_match_first_regex(rest_of_cmd_no_type,
    "^\\s*([^=\\s]+)\\s*=\s*([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\(([^)]*)\\)\\s*(?:if\\s+(.*?))?\\s*(?:,(.*))?$")

  if (is.na(main_match[1,1])) {
    return(paste0("# Failed to parse egen command structure: ", rest_of_cmd))
  }

  new_var = stringi::stri_trim_both(main_match[1,2])
  egen_func_name = stringi::stri_trim_both(main_match[1,3])
  egen_args_str = stringi::stri_trim_both(main_match[1,4]) # arguments inside parentheses
  stata_if_cond = stringi::stri_trim_both(main_match[1,5]) # NA if no if
  options_str = stringi::stri_trim_both(main_match[1,6])   # NA if no options like by()

  # Translate expressions/conditions
  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group=FALSE)) # Egen if condition typically outside group
  }

  # Determine by_vars: either from `cmd_obj$by_vars` (if `bysort group: egen...`) or from `options_str` (if `egen ..., by(group)`)
  by_vars_egen = NA_character_
  if (cmd_obj$is_by_prefix && !is.na(cmd_obj$by_vars)) {
    by_vars_egen = cmd_obj$by_vars
  } else if (!is.na(options_str)) {
    by_opt_match = stringi::stri_match_first_regex(options_str, "\\bby\\s*\\(([^)]+)\\)")
    if (!is.na(by_opt_match[1,1])) {
      by_vars_egen = stringi::stri_trim_both(by_opt_match[1,2])
    }
  }

  by_vars_r_list_str = NULL # For dplyr group_by: "var1, var2" or collapse c("var1", "var2")
  if (!is.na(by_vars_egen)) {
    by_vars_list = stringi::stri_split_regex(by_vars_egen, "\\s+")[[1]]
    by_vars_list = by_vars_list[by_vars_list != ""]
    # For dplyr: paste0(by_vars_list, collapse=", ")
    # For collapse:
    by_vars_r_list_str = paste0('c("', paste0(by_vars_list, collapse='", "'), '")')
  }

  # Translate egen function
  # egen_args_str might be "var1", "var1 var2", or empty for funcs like group()
  # For functions like mean(var1), args_str is "var1". For rowtotal(var1 var2), it's "var1 var2".
  # Translate arguments if they are complex expressions (not typical for egen simple funcs)
  # For now, assume egen_args_str are variable names or simple expressions.
  # `translate_stata_expression_with_r_values` can handle simple variable names too.
  r_egen_args = translate_stata_expression_with_r_values(egen_args_str, line_num, cmd_df, context) # context for _n, _N in args


  # Switch for egen functions
  # Resulting expression for mutate: `new_var = R_EQUIVALENT_EXPRESSION`
  mutate_value_expr = ""

  is_row_function = FALSE

  if (egen_func_name == "mean") {
    mutate_value_expr = paste0("mean(", r_egen_args, ", na.rm = TRUE)")
  } else if (egen_func_name == "total" || egen_func_name == "sum") {
    mutate_value_expr = paste0("sum(", r_egen_args, ", na.rm = TRUE)")
  } else if (egen_func_name == "count") {
    mutate_value_expr = paste0("sum(!is.na(", r_egen_args, "))")
  } else if (egen_func_name == "rank") {
    mutate_value_expr = paste0("dplyr::min_rank(", r_egen_args, ")")
  } else if (egen_func_name == "median" || egen_func_name == "p50") {
    mutate_value_expr = paste0("median(", r_egen_args, ", na.rm = TRUE)")
  } else if (egen_func_name == "sd" || egen_func_name == "std") {
    mutate_value_expr = paste0("sd(", r_egen_args, ", na.rm = TRUE)")
  } else if (egen_func_name == "group") {
    group_vars_for_func_list = stringi::stri_split_regex(r_egen_args, "\\s+")[[1]]
    group_vars_for_func_list = group_vars_for_func_list[group_vars_for_func_list != ""]
    # dplyr::group_indices needs bare var names or across()
    # Using collapse approach for group IDs:
    # mutate_value_expr = paste0("collapse::groupid(list(", paste(group_vars_for_func_list, collapse = ", "), "))")
    # Or dplyr's approach:
    cols_for_group_indices = paste0("dplyr::all_of(c('", paste(group_vars_for_func_list, collapse = "','"), "'))")
    mutate_value_expr = paste0("dplyr::group_indices(dplyr::across(", cols_for_group_indices, "))")
  } else if (egen_func_name == "tag") {
      tag_vars_list = stringi::stri_split_regex(r_egen_args, "\\s+")[[1]]
      tag_vars_list = tag_vars_list[tag_vars_list != ""]
      cols_for_tag = paste0("dplyr::all_of(c('", paste(tag_vars_list, collapse = "','"), "'))")
      mutate_value_expr = paste0("!duplicated(dplyr::select(data.frame(dplyr::across(", cols_for_tag, "))))") # Simplified
  } else if (egen_func_name == "rowtotal") {
    vars_for_rowop_list = stringi::stri_split_regex(r_egen_args, "\\s+")[[1]]
    vars_for_rowop_list = vars_for_rowop_list[vars_for_rowop_list != ""]
    vars_for_rowop_dplyr = paste0(vars_for_rowop_list, collapse=", ")
    # Using collapse::rowNA() and rowSums() from base R for clarity with NA handling.
    # dplyr::select(., dplyr::all_of(c('var1','var2')))
    selected_cols_expr = paste0("dplyr::select(., dplyr::all_of(c('", paste(vars_for_rowop_list, collapse="','"), "')))")
    mutate_value_expr = paste0("base::rowSums(collapse::na_insert(", selected_cols_expr, ", fill = 0), na.rm = FALSE)")
    is_row_function = TRUE; # Row functions don't use grouping in the same way
    effective_by_vars_r_list_str = NULL # Override by_vars for row functions
  } else if (egen_func_name == "rowmean") {
    vars_for_rowop_list = stringi::stri_split_regex(r_egen_args, "\\s+")[[1]]
    vars_for_rowop_list = vars_for_rowop_list[vars_for_rowop_list != ""]
    selected_cols_expr = paste0("dplyr::select(., dplyr::all_of(c('", paste(vars_for_rowop_list, collapse="','"), "')))")
    mutate_value_expr = paste0("base::rowMeans(", selected_cols_expr, ", na.rm = TRUE)")
    is_row_function = TRUE;
    effective_by_vars_r_list_str = NULL
  } else {
    return(paste0("# Egen function '", egen_func_name, "' not yet implemented."))
  }

  # Determine effective by_vars for R code generation (null for row functions)
  effective_by_vars_r_list_str = if (is_row_function) NULL else by_vars_r_list_str


  # Combine into a mutate statement
  # If condition applies to assignment (Stata: egen x = mean(y) if z > 0)
  if (!is.na(r_if_cond) && r_if_cond != "") {
    # collapse::fifelse correctly handles type promotion for NA
    full_mutate_expr = paste0(new_var, " = collapse::fifelse(", r_if_cond, ", ", mutate_value_expr, ", NA)")
  } else {
    full_mutate_expr = paste0(new_var, " = ", mutate_value_expr)
  }

  # Build the R command string
  if (!is.null(effective_by_vars_r_list_str)) {
    # Using collapse for grouped mutation:
    r_code_str = paste0("data = collapse::fgroup_by(data, ", effective_by_vars_r_list_str, ")")
    r_code_str = paste0(r_code_str, "\ndata = collapse::fmutate(data, ", full_mutate_expr, ")")
    r_code_str = paste0(r_code_str, "\ndata = collapse::fungroup(data)")
    # dplyr alternative shown in original comments, but collapse is preferred:
    # by_vars_dplyr_str = gsub('c\\("', '', gsub('"\\)', '', gsub('", "', ',', effective_by_vars_r_list_str))) # for dplyr group_by
    # r_code_str = paste0("data = data %>%\n  dplyr::group_by(", by_vars_dplyr_str, ") %>%\n  dplyr::mutate(", full_mutate_expr, ") %>%\n  dplyr::ungroup()")
  } else {
    # Using collapse:
    r_code_str = paste0("data = collapse::fmutate(data, ", full_mutate_expr, ")")
    # dplyr alternative:
    # r_code_str = paste0("data = dplyr::mutate(data, ", full_mutate_expr, ")")
  }

  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_egen.R

!CHANGE_FILE R/t_generate.R
```
# Translate Stata 'generate' or 'gen' command

# Example Stata: gen newvar = oldvar * 2 if condition
# Example Stata: by group: gen seq = _n
t_generate = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  # Parse `rest_of_cmd` for new variable name, expression, and if condition
  # Example: "newvar = expression [if condition]"

  # Strip type if present (e.g. gen double newvar = ...)
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^(?:byte|int|long|float|double)\\s+", "")

  match = stringi::stri_match_first_regex(rest_of_cmd_no_type, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  if (is.na(match[1,1])) {
    return(paste0("# Failed to parse generate command: ", rest_of_cmd))
  }

  new_var = stringi::stri_trim_both(match[1,2])
  stata_expr = stringi::stri_trim_both(match[1,3])
  stata_if_cond = stringi::stri_trim_both(match[1,4]) # Might be NA

  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, context)

  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    # For 'if' condition on generate/replace, _n and _N refer to overall dataset, not by-group
    # However, if the expression *itself* inside `if` needs by-group context (rare for `if` part), this might need adjustment
    # Stata default: `if` condition is evaluated on the whole dataset context for _n/_N.
    if_context = context; if_context$is_by_group = FALSE # Typically, if condition _n/_N are global
    # If `cmd_obj$is_by_prefix` is TRUE, it implies the *assignment* is by group.
    # The evaluation of _n/_N within the main r_expr respects `context$is_by_group`.
    # The evaluation of _n/_N within r_if_cond should respect global context, unless Stata implies otherwise for `if`.
    # Standard Stata: `by x: gen y = _n if some_global_cond_involving_N` -> _N in global_cond is total N.
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = if_context)
  }

  by_vars_r_vec_str = NULL
  if (cmd_obj$is_by_prefix && !is.na(cmd_obj$by_vars)) {
    by_vars_list = stringi::stri_split_fixed(cmd_obj$by_vars, " ")[[1]]
    by_vars_list = by_vars_list[by_vars_list != ""] # Remove empty strings if any
    by_vars_r_vec_str = paste0('c("', paste0(by_vars_list, collapse='", "'), '")')
  }

  # Base mutate string
  if (!is.na(r_if_cond) && r_if_cond != "") {
    # Using collapse::fifelse for type flexibility of NA and performance.
    # NA in fifelse will be coerced to the appropriate NA type (e.g. NA_character_, NA_real_).
    mutate_expr = paste0(new_var, " = collapse::fifelse(", r_if_cond, ", ", r_expr, ", NA)")
  } else {
    mutate_expr = paste0(new_var, " = ", r_expr)
  }

  if (!is.null(by_vars_r_vec_str)) {
    # Using collapse for grouped mutation:
    r_code_str = paste0("data = collapse::fgroup_by(data, ", by_vars_r_vec_str, ")")
    r_code_str = paste0(r_code_str, "\ndata = collapse::fmutate(data, ", mutate_expr, ")") # fmutate adds or replaces
    r_code_str = paste0(r_code_str, "\ndata = collapse::fungroup(data)")
  } else {
    # Using collapse:
    r_code_str = paste0("data = collapse::fmutate(data, ", mutate_expr, ")")
  }

  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_generate.R

!CHANGE_FILE R/t_replace.R
```
# Translate Stata 'replace' command
# Stata: replace oldvar = expression [if condition]
t_replace = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  match = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  if (is.na(match[1,1])) {
    return(paste0("# Failed to parse replace command: ", rest_of_cmd))
  }

  var_to_replace = stringi::stri_trim_both(match[1,2])
  stata_expr = stringi::stri_trim_both(match[1,3])
  stata_if_cond = stringi::stri_trim_both(match[1,4]) # Might be NA

  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, context)

  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    # For 'if' condition on generate/replace, _n and _N refer to overall dataset, not by-group
    if_context = context; if_context$is_by_group = FALSE # Typically, if condition _n/_N are global
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = if_context)
  }

  by_vars_r_vec_str = NULL
  if (cmd_obj$is_by_prefix && !is.na(cmd_obj$by_vars)) {
    by_vars_list = stringi::stri_split_fixed(cmd_obj$by_vars, " ")[[1]]
    by_vars_list = by_vars_list[by_vars_list != ""]
    by_vars_r_vec_str = paste0('c("', paste0(by_vars_list, collapse='", "'), '")')
  }

  # For replace, the structure is: var = ifelse(condition, new_value, old_value)
  # Using collapse::fifelse for performance and type handling.
  if (!is.na(r_if_cond) && r_if_cond != "") {
    mutate_expr = paste0(var_to_replace, " = collapse::fifelse(", r_if_cond, ", ", r_expr, ", ", var_to_replace, ")")
  } else {
    mutate_expr = paste0(var_to_replace, " = ", r_expr)
  }

  if (!is.null(by_vars_r_vec_str)) {
    # Using collapse for grouped mutation:
    r_code_str = paste0("data = collapse::fgroup_by(data, ", by_vars_r_vec_str, ")")
    r_code_str = paste0(r_code_str, "\ndata = collapse::fmutate(data, ", mutate_expr, ")") # fmutate replaces existing var
    r_code_str = paste0(r_code_str, "\ndata = collapse::fungroup(data)")
  } else {
    # Using collapse:
    r_code_str = paste0("data = collapse::fmutate(data, ", mutate_expr, ")")
  }

  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_replace.R
