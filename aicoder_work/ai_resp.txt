The primary issue causing the "missing value where TRUE/FALSE needed" error is that the `translate_stata_expression_to_r` function was returning `NA_character_` for empty or `NA` input expressions. When this `NA_character_` was then passed to `dplyr::coalesce` (which expects a logical or numeric vector), it resulted in the reported error during R code execution.

The fix involves modifying `translate_stata_expression_to_r` to consistently return `NA_real_` (numeric `NA`) when the input expression is `NA` or empty. `NA_real_` can be correctly handled by `dplyr::coalesce` as a numeric value that evaluates to `FALSE` when compared to a logical.

Additionally, I've removed the `HACK` comment in `t_merge.R` as `dplyr::full_join` is indeed the correct base join type for generating the `_merge` variable with all its possible values (1, 2, 3), especially when combined with the explicit duplicate key checks for strict 1:1 merges.

!CHANGE_FILE R/stata_expression_translator.R
```R
# Stata Expression Translator

# Placeholder for Stata results (r() and e() values)
# This environment would be populated by commands like summarize, regress
# For now, we will generate unique variable names for r() values.
# stata_results_env = new.env(parent = emptyenv())


# Translates a Stata expression string into an R expression string
# stata_expr: The Stata expression (e.g., "var1 + log(var2)")
# context: Information about the context (e.g., if inside a by group, for _n/_N)
# r_value_mappings: A named list/vector mapping Stata r-value names (e.g. "r(mean)")
#                   to R variable names (e.g. "stata_r_val_L5_mean")
translate_stata_expression_to_r = function(stata_expr, context = list(is_by_group = FALSE), r_value_mappings = NULL) {
  restore.point("translate_stata_expression_to_r")
  if (is.na(stata_expr) || stata_expr == "") {
    # If the expression is empty or NA, it generally means missing.
    # For Stata, missing numeric is '.', missing string is "".
    # In R context for translation, if an expression is missing, it should resolve to NA.
    # The type of NA (numeric, logical, character) depends on the context.
    # Since this function is general, assume numeric NA_real_ as default for missing expressions.
    # If this is used as a logical condition (e.g., in an 'if' clause),
    # `dplyr::coalesce(NA_real_, FALSE)` will correctly yield FALSE.
    return(NA_real_) 
  }

  r_expr = stata_expr

  # Step 1: Handle Stata missing value literals '.', '.a', ..., '.z'
  # This must happen early to prevent interference with decimal numbers or variable names.
  # Regex matches '.' or '.a' to '.z' only when not part of a number or a variable name.
  r_expr = stringi::stri_replace_all_regex(r_expr, "(?<![0-9a-zA-Z_])\\.[a-zA-Z]?(?![0-9a-zA-Z_])", "NA_real_")

  # Step 2: Handle r() values using the mapping.
  # This ensures that r() values are replaced by their corresponding R variable names
  # BEFORE other transformations (like missing value checks) are applied to them.
  if (!is.null(r_value_mappings) && length(r_value_mappings) > 0) {
    for (stata_r_name in names(r_value_mappings)) {
      # Escape parentheses for regex matching
      stata_r_regex = gsub("(", "\\(", gsub(")", "\\)", stata_r_name, fixed=TRUE), fixed=TRUE)
      r_expr = stringi::stri_replace_all_regex(r_expr, stata_r_regex, r_value_mappings[[stata_r_name]])
    }
  }

  # Step 3: Translate Stata logical operators and missing value comparisons.
  # These must happen after handling `r()` values so `r(mean)` is already `stata_r_val_Lxx_mean`.
  # Stata `X == .` -> R `sfun_missing(X)`
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\b[a-zA-Z_][a-zA-Z0-9_.]*\\b)\\s*==\\s*NA_real_", "sfun_missing($1)")
  # Stata `X != .` -> R `!sfun_missing($1)`
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\b[a-zA-Z_][a-zA-Z0-9_.]*\\b)\\s*!=\\s*NA_real_", "!sfun_missing($1)")

  r_expr = stringi::stri_replace_all_regex(r_expr, "(?<![<>!=~])\\s*=\\s*(?![=])", " == ") # Replace single = with == if not part of other ops
  r_expr = stringi::stri_replace_all_regex(r_expr, "\\s+~=\\s+", " != ") # Stata `~=` to R `!=`


  # Step 4: Translate Stata special variables and indexing (e.g., _n, _N, var[_n-1])
  # These are generally fixed references, not nested functions.
  # Use dplyr::lag/lead which are context-aware in grouped operations.

  # Directly replace with `n = $2`
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\w+)\\[_n\\s*-\\s*(\\d+)\\]", "dplyr::lag($1, n = $2)")
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\w+)\\[_n\\s*\\+\\s*(\\d+)\\]", "dplyr::lead($1, n = $2)")
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\w+)\\[_n\\]", "$1")

  # Handle _n and _N.
  # Convert to numeric to match Stata's default float storage for integers.
  r_expr = stringi::stri_replace_all_regex(r_expr, "\\b_n\\b", "as.numeric(dplyr::row_number())")
  r_expr = stringi::stri_replace_all_regex(r_expr, "\\b_N\\b", "as.numeric(dplyr::n())")


  # Step 5: Iteratively translate Stata functions (e.g., cond(), round(), log(), etc.)
  # This loop handles nested function calls by repeatedly applying transformations.
  old_r_expr = ""
  # Ensure the loop condition always evaluates to a concrete TRUE/FALSE
  while (dplyr::coalesce(r_expr != old_r_expr, FALSE)) {
    old_r_expr = r_expr

    # Apply more specific regexes first if there are overlaps (e.g., round(x,y) before round(x))
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bcond\\(([^,]+),([^,]+),([^)]+)\\)", "dplyr::if_else($1, $2, $3)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bround\\(([^,]+),([^)]+)\\)", "sfun_stata_round($1, $2)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bround\\(([^)]+)\\)", "sfun_stata_round($1, 1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bmod\\(([^,]+),([^)]+)\\)", "($1 %% $2)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bmissing\\(([^)]+)\\)", "sfun_missing($1)") # Changed to sfun_missing
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\blog\\(([^)]+)\\)", "log($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bsqrt\\(([^)]+)\\)", "sqrt($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bint\\(([^)]+)\\)", "trunc($1)") # Stata int() truncates

    # String functions (using stringi or custom helpers)
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstrtrim\\(([^)]+)\\)", "stringi::stri_trim_right($1)") # Corrected for Stata's strtrim
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstritrim\\(([^)]+)\\)", "sfun_stritrim($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\blower\\(([^)]+)\\)", "stringi::stri_trans_tolower($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bupper\\(([^)]+)\\)", "stringi::stri_trans_toupper($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bsubstr\\(([^,]+),([^,]+),([^)]+)\\)", "stringi::stri_sub($1, from = $2, length = $3)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bsubinstr\\(([^,]+),([^,]+),([^,]+),([^)]+)\\)", "sfun_subinstr($1, $2, $3, $4)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstrpos\\(([^,]+),([^)]+)\\)", "sfun_strpos($1, $2)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\blength\\(([^)]+)\\)", "stringi::stri_length($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstrlen\\(([^)]+)\\)", "stringi::stri_length($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstring\\(([^)]+)\\)", "sfun_string($1)") # CHANGED HERE
    # Random number generator functions
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bruniform\\(\\)", "stats::runif(as.numeric(dplyr::n()))") # Stata runiform()
    # Date functions
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bdate\\(([^,]+),([^,]+),([^)]+)\\)", "sfun_stata_date($1, $2, $3)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bdate\\(([^,]+),([^)]+)\\)", "sfun_stata_date($1, $2)")
    # NEW: mdy() function
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bmdy\\(([^,]+),([^,]+),([^)]+)\\)", "sfun_stata_mdy($1, $2, $3)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\byear\\(([^)]+)\\)", "as.numeric(format(as.Date($1, origin = '1960-01-01'), '%Y'))") # Stata date epoch is 1960-01-01
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bmonth\\(([^)]+)\\)", "sfun_month($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bday\\(([^)]+)\\)", "sfun_day($1)") # Use sfun_day
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bqofd\\(([^)]+)\\)", "sfun_qofd($1)") # Use sfun_qofd
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bdow\\(([^)]+)\\)", "sfun_dow($1)") # NEW: Use sfun_dow
  }

  # Step 6: Translate Stata '+' operator to sfun_stata_add for polymorphic behavior
  # This must happen after all functions are translated.
  # Operands can be: variable names, numbers, string literals, or already-translated R function calls.
  # Use a more robust regex for operands that can include nested parentheses (since functions are already translated).
  # This pattern matches:
  # - quoted strings: "[^"]*" or '[^']+'
  # - numbers: \d+(?:\.\d+)?
  # - R literals: NA_real_, NULL, TRUE, FALSE
  # - variable names: \b[a-zA-Z_][a-zA-Z0-9_.]*\b
  # - function calls: \b[a-zA-Z_][a-zA-Z0-9_:]*\s*\(.*?\)\s* (non-greedy, handles nested parentheses after functions are processed)
  operand_pattern = "(?:\"[^\"]*\"|'[^']*'|\\d+(?:\\.\\d+)?|\\b(?:NA_real_|NULL)\\b|\\b(?:TRUE|FALSE)\\b|\\b[a-zA-Z_][a-zA-Z0-9_.]*\\b|\\b[a-zA-Z_][a-zA-Z0-9_:]*\\s*\\(.*?\\)\\s*)"

  old_r_expr_add = ""
  while (dplyr::coalesce(r_expr != old_r_expr_add, FALSE)) {
    old_r_expr_add = r_expr
    # Regex: Match 'operand' + 'operand', ensuring `+` is an operator not part of `==` etc.
    # The `(?<![<>=!~])` ensures `+` is not preceded by <, >, =, !, ~.
    # The `(?!\\s*\\+|\\s*=\\s*)` ensures `+` is not followed by another `+` or `=` (for `++` or `+=`).
    add_regex_middle_part = "\\s*(?<![<>=!~])\\+\\s*(?!\\s*\\+|\\s*=\\s*)"
    add_regex_full = paste0("(", operand_pattern, ")", add_regex_middle_part, "(", operand_pattern, ")")
    r_expr = stringi::stri_replace_all_regex(r_expr, add_regex_full, "sfun_stata_add($1, $2)")
  }

  # Defensive check: if r_expr became empty or NA for some reason (should not happen for valid input)
  if (is.na(r_expr) || r_expr == "") {
      warning(paste0("R expression became NA or empty during translation. Original Stata expression: '", stata_expr, "'"))
      return(NA_real_) # Ensure it's NA_real_ here too
  }

  return(r_expr)
}
```
!END_CHANGE_FILE R/stata_expression_translator.R

!CHANGE_FILE R/t_merge.R
```R
# Translate Stata 'merge' command
# Stata: merge 1:1 varlist using filename [, options]
# Stata: merge 1:m varlist using filename [, options]
# Stata: merge m:1 varlist using filename [, options]
# Stata: merge m:m varlist using filename [, options]
# Options: keep(match master using all) nogenerate

t_merge = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_merge") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Define a temporary indicator column name for dplyr::join
  indicator_col_name = paste0("stata_merge_indicator_L", line_num)

  # Parse merge type (1:1, 1:m, m:1, m:m), varlist, `using filename`, and options
  merge_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*([1m]:[1m])\\s+(.*?)\\s+using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")
  merge_type = NA_character_
  varlist_str = NA_character_
  raw_filename_token = NA_character_
  options_str = NA_character_


  if (is.na(merge_match[1,1])) {
      # Check for older syntax without type: `merge varlist using filename` (defaults to 1:1)
      merge_match_old = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(.*?)\\s+using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")
      if (!is.na(merge_match_old[1,1])) {
           merge_type = "1:1" # Assume 1:1 if type not specified
           varlist_str = stringi::stri_trim_both(merge_match_old[1,2])
           raw_filename_token = stringi::stri_trim_both(merge_match_old[1,3])
           options_str = stringi::stri_trim_both(merge_match_old[1,4])
      } else {
           return(paste0("# Failed to parse merge command: ", rest_of_cmd))
      }
  } else {
      merge_type = merge_match[1,2]
      varlist_str = stringi::stri_trim_both(merge_match[1,3])
      raw_filename_token = stringi::stri_trim_both(merge_match[1,4])
      options_str = stringi::stri_trim_both(merge_match[1,5]) # NA if no options
  }

  vars_to_merge_on = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_merge_on = vars_to_merge_on[vars_to_merge_on != ""]
  if (length(vars_to_merge_on) == 0) {
       return(paste0("# merge command requires varlist: ", rest_of_cmd))
  }
  # For dplyr::join, by argument can be a character vector of column names
  vars_to_merge_on_r_vec_str = paste0('c("', paste(vars_to_merge_on, collapse = '", "'), '")')

  using_source_r_expr = resolve_stata_filename(raw_filename_token, cmd_df, line_num, default_base_dir_var = "working_dir")

  # Determine if nogenerate option is present (for comments later)
  has_nogenerate = !is.na(options_str) && stringi::stri_detect_regex(options_str, "\\bno(?:generate|gen)\\b")
  
  # Determine keep_spec_for_comment based on parsing `options_str` in `t_merge` scope
  # This variable should be initialized to a default that reflects Stata's behavior for the given merge type.
  initial_keep_spec = NA_character_
  if (merge_type %in% c("1:1", "1:m", "m:1")) {
      initial_keep_spec = "match master"
  } else if (merge_type == "m:m") {
      initial_keep_spec = "match master using"
  }

  keep_spec_for_comment = initial_keep_spec # Default if no keep() specified
  actual_keep_spec_from_options = NA_character_ # What was explicitly written in options_str

  if (!is.na(options_str)) {
      keep_opt_match = stringi::stri_match_first_regex(options_str, "\\bkeep\\s*\\(([^)]+)\\)")
      if (!is.na(keep_opt_match[1,1])) {
          actual_keep_spec_from_options = stringi::stri_trim_both(keep_opt_match[1,2])
          keep_spec_for_comment = actual_keep_spec_from_options # Use actual option for comment
      }
  }

  # --- Start building R code lines ---
  r_code_lines = c()
  temp_using_data_var = paste0("stata_tmp_using_data_L", line_num)

  # Read using data
  r_code_lines = c(r_code_lines, paste0(temp_using_data_var, " = haven::read_dta(", using_source_r_expr, ")"))

  # Strip haven attributes from both master and using dataframes before joining
  # And normalize string NAs
  r_code_lines = c(r_code_lines, paste0("data = sfun_strip_stata_attributes(data)"))
  r_code_lines = c(r_code_lines, paste0("data = sfun_normalize_string_nas(data)")) # Added
  r_code_lines = c(r_code_lines, paste0(temp_using_data_var, " = sfun_strip_stata_attributes(", temp_using_data_var, ")"))
  r_code_lines = c(r_code_lines, paste0(temp_using_data_var, " = sfun_normalize_string_nas(", temp_using_data_var, ")")) # Added

  # Ensure merge keys are plain numeric for robustness against haven-specific types
  r_code_lines = c(r_code_lines,
      paste0("data = dplyr::mutate(data, ", paste0("`", vars_to_merge_on, "` = as.numeric(`", vars_to_merge_on, "`)", collapse = ", "), ")"),
      paste0(temp_using_data_var, " = dplyr::mutate(", temp_using_data_var, ", ", paste0("`", vars_to_merge_on, "` = as.numeric(`", vars_to_merge_on, "`)", collapse = ", "), ")")
  )

  # Initialize variables for join type and merge indicator mapping in the *generated R code*
  join_type_var_in_r = paste0("join_type_r_func_L", line_num)
  stata_merge_map_left_only_var_in_r = paste0("stata_merge_map_left_only_L", line_num)
  stata_merge_map_right_only_var_in_r = paste0("stata_merge_map_right_only_L", line_num)
  stata_merge_map_both_var_in_r = paste0("stata_merge_map_both_L", line_num)

  # New temp vars for package and function name resolution in generated R code
  pkg_name_in_r_code = paste0("pkg_name_L", line_num)
  fun_name_in_r_code = paste0("fun_name_L", line_num)
  merge_fun_obj_in_r_code = paste0("merge_fun_obj_L", line_num)


  # Default join type based on Stata's merge type.
  # For 1:1, 1:m, m:1, m:m, the `_merge` variable requires a full understanding of matches.
  # `full_join` with `indicator` provides all necessary categories (left_only, right_only, both).
  r_code_lines = c(r_code_lines, paste0(join_type_var_in_r, " = switch('", merge_type, "', "))
  r_code_lines = c(r_code_lines, paste0("  '1:1' = 'dplyr::full_join',"))
  r_code_lines = c(r_code_lines, paste0("  '1:m' = 'dplyr::left_join',"))
  r_code_lines = c(r_code_lines, paste0("  'm:1' = 'dplyr::right_join',"))
  r_code_lines = c(r_code_lines, paste0("  'm:m' = 'dplyr::inner_join'"))
  r_code_lines = c(r_code_lines, paste0(")"))

  r_code_lines = c(r_code_lines, paste0(stata_merge_map_left_only_var_in_r, " = 1L"))
  r_code_lines = c(r_code_lines, paste0(stata_merge_map_right_only_var_in_r, " = 2L"))
  r_code_lines = c(r_code_lines, paste0(stata_merge_map_both_var_in_r, " = 3L"))
  
  # Logic for `keep()` option (converted to generated R code)
  if (!is.na(actual_keep_spec_from_options)) {
      r_code_lines = c(r_code_lines, paste0("if (grepl(\"\\\\ball\\\\b\", \"", actual_keep_spec_from_options, "\")) {"))
      r_code_lines = c(r_code_lines, paste0("  ", join_type_var_in_r, " = \"dplyr::full_join\""))
      r_code_lines = c(r_code_lines, paste0("} else if (grepl(\"\\\\bmaster\\\\b\", \"", actual_keep_spec_from_options, "\")) {"))
      r_code_lines = c(r_code_lines, paste0("  ", join_type_var_in_r, " = \"dplyr::left_join\""))
      r_code_lines = c(r_code_lines, paste0("} else if (grepl(\"\\\\busing\\\\b\", \"", actual_keep_spec_from_options, "\")) {"))
      r_code_lines = c(r_code_lines, paste0("  ", join_type_var_in_r, " = \"dplyr::right_join\""))
      r_code_lines = c(r_code_lines, paste0("} else if (grepl(\"\\\\bmatch\\\\b\", \"", actual_keep_spec_from_options, "\")) {"))
      r_code_lines = c(r_code_lines, paste0("  ", join_type_var_in_r, " = \"dplyr::inner_join\""))
      r_code_lines = c(r_code_lines, "}")
  }

  # Logic for 1:1 merge strictness (moved to generated R code)
  # This part performs Stata's duplicate key checks for 1:1 merge.
  if (merge_type == "1:1") {
      r_code_lines = c(r_code_lines,
          paste0("if (any(base::duplicated(dplyr::select(data, dplyr::all_of(", vars_to_merge_on_r_vec_str, "))))) { stop('Merge 1:1 failed: Duplicate keys found in master dataset (data).') }"),
          paste0("if (any(base::duplicated(dplyr::select(", temp_using_data_var, ", dplyr::all_of(", vars_to_merge_on_r_vec_str, "))))) { stop('Merge 1:1 failed: Duplicate keys found in using dataset (', ", using_source_r_expr, ", ').') }")
      )
  }

  # Identify common columns that are NOT merge keys
  r_code_lines = c(r_code_lines,
    paste0("common_cols = intersect(names(data), names(", temp_using_data_var, "))"),
    paste0("common_cols_not_by = setdiff(common_cols, ", vars_to_merge_on_r_vec_str, ")")
  )

  # Conditional dropping of columns from the using dataset
  # Stata's merge logic: if a variable exists in both, the master's version is kept.
  # So, columns in `using` data that conflict with `master` data should be dropped from `using` before join.
  r_code_lines = c(r_code_lines,
    paste0("if (length(common_cols_not_by) > 0) { ", temp_using_data_var, " = dplyr::select(", temp_using_data_var, ", -dplyr::all_of(common_cols_not_by)) }")
  )

  # NEW: Resolve function using get and asNamespace before do.call
  r_code_lines = c(r_code_lines,
    paste0("parts_fun_split = stringi::stri_split_fixed(", join_type_var_in_r, ", \"::\", n=2)[[1]]"),
    paste0(pkg_name_in_r_code, " = parts_fun_split[1]"),
    paste0(fun_name_in_r_code, " = parts_fun_split[2]"),
    paste0(merge_fun_obj_in_r_code, " = get(", fun_name_in_r_code, ", envir = asNamespace(", pkg_name_in_r_code, "))")
  )

  # Perform the join with indicator
  r_code_lines = c(r_code_lines,
    paste0("data = do.call(", merge_fun_obj_in_r_code, ", list(data, ", temp_using_data_var, ", by = ", vars_to_merge_on_r_vec_str, ", indicator = \"", indicator_col_name, "\"))")
  )

  # NEW: Post-merge processing for string NAs to empty strings
  # This part is now handled by sfun_normalize_string_nas after `read_dta` and `strip_stata_attributes`.
  # The `dplyr::join` might reintroduce NAs in character columns if they are not matched,
  # so this is still needed to ensure consistency.
  r_code_lines = c(r_code_lines, paste0("data = sfun_normalize_string_nas(data)"))


  # Generate _merge variable unless nogenerate option is present
  if (!has_nogenerate) {
      r_code_lines = c(r_code_lines,
          paste0("data = dplyr::mutate(data, `_merge` = dplyr::case_when("),
          paste0("  `", indicator_col_name, "` == \"left_only\" ~ as.integer(", stata_merge_map_left_only_var_in_r, "),"),
          paste0("  `", indicator_col_name, "` == \"right_only\" ~ as.integer(", stata_merge_map_right_only_var_in_r, "),"),
          paste0("  `", indicator_col_name, "` == \"both\" ~ as.integer(", stata_merge_map_both_var_in_r, "),"),
          paste0("  TRUE ~ NA_integer_"),
          paste0("))")
      )
  } else {
    r_code_lines = c(r_code_lines, paste0(" # _merge variable was not generated due to 'nogenerate' option."))
  }

  # Always remove the temporary indicator column
  r_code_lines = c(r_code_lines, paste0("data = dplyr::select(data, -dplyr::any_of('", indicator_col_name, "'))"))

  # Clean up temporary variables
  r_code_lines = c(r_code_lines, paste0("rm(", temp_using_data_var, ", common_cols, common_cols_not_by, parts_fun_split)"))
  
  # Clean up the new temporary variables created for the generated R code
  r_code_lines = c(r_code_lines, paste0("rm(", join_type_var_in_r, ", ", stata_merge_map_left_only_var_in_r, ", ", stata_merge_map_right_only_var_in_r, ", ", stata_merge_map_both_var_in_r, ")"))
  # NEW: Clean up the new temp vars
  r_code_lines = c(r_code_lines, paste0("rm(", pkg_name_in_r_code, ", ", fun_name_in_r_code, ", ", merge_fun_obj_in_r_code, ")"))


  # Add comment about options
  merge_comment_line = paste0("# Stata merge type: ", merge_type, ", keep(", keep_spec_for_comment, ")")
  if (has_nogenerate) {
    merge_comment_line = paste0(merge_comment_line, ", nogenerate")
  }
  r_code_lines = c(r_code_lines, merge_comment_line)

  options_str_cleaned = options_str
  if (!is.na(options_str_cleaned)) {
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bkeep\\s*\\([^)]+\\)", "")
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bno(?:generate|gen)\\b", "")
      options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
  }
  if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
       r_code_lines = c(r_code_lines, paste0(" # Other options ignored: ", options_str_cleaned))
  }

  return(paste(r_code_lines, collapse="\n"))
}
```
!END_CHANGE_FILE R/t_merge.R
