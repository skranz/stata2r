The primary issue reported in the test results ("missing value where TRUE/FALSE needed") likely stems from how `if` conditions and `dplyr::if_else` expressions are constructed within the `t_generate`, `t_replace`, `t_duplicates`, `t_encode`, and `t_decode` functions. Specifically, the use of `with(data, ...)` to evaluate `if` conditions *within the generated R code string* can cause evaluation context issues when `dplyr` verbs are used.

The fix involves refactoring these functions to directly embed the translated `if` condition expression within the `dplyr::if_else` call, allowing `dplyr::mutate` or `dplyr::filter` to handle the evaluation context correctly. This removes the problematic `with(data, ...)` wrapper and the need for a temporary condition variable, making the generated R code more idiomatic and robust.

**Summary of Changes:**
1.  **`t_generate.R` and `t_replace.R`**: Removed the use of a temporary variable for the `if` condition and `with(data, ...)` wrapper. The `dplyr::if_else` condition now directly uses the translated `r_if_cond` string.
2.  **`t_duplicates.R`**: Similarly refactored the `if` condition handling to directly use the translated `r_subset_cond` in `dplyr::filter` and `dplyr::mutate`.
3.  **`t_decode.R` and `t_encode.R`**: Refactored the `if` condition logic to remove `with(data, ...)` and directly use the translated condition string in the generated R code.

These changes address the core problem of how conditional logic is translated and executed, which should resolve the reported errors in `do1` and `do2` tests.

!CHANGE_FILE R/t_generate.R
```R
t_generate = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_generate")
  # Parse `rest_of_cmd` for new variable name, expression, and if condition
  # Example: "newvar = expression [if condition]"

  # Capture explicit type declaration (e.g., `str10`)
  explicit_type_match = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*(byte|int|long|float|double|str\\d+|strL)\\s+")
  declared_type_str = NA_character_
  if (!is.na(explicit_type_match[1,1])) {
    declared_type_str = explicit_type_match[1,2]
  }

  # Strip type if present (e.g. gen double newvar = ...)
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^\\s*(?:byte|int|long|float|double|str\\d+|strL)\\s+", "")

  match = stringi::stri_match_first_regex(rest_of_cmd_no_type, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  # NEW: Defensive check for successful parsing of core components
  if (is.na(match[1,1]) || is.na(match[1,2]) || is.na(match[1,3])) {
    return(paste0("# Failed to parse generate command structure: ", rest_of_cmd))
  }

  new_var = stringi::stri_trim_both(match[1,2])
  stata_expr = stringi::stri_trim_both(match[1,3])
  stata_if_cond = stringi::stri_trim_both(match[1,4]) # Might be NA

  # Context for expression translation (e.g. _n, _N behavior)
  # is_by_group TRUE if cmd_obj$by_group_vars is not NA
  current_context = list(is_by_group = cmd_obj$is_by_prefix && length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1]))
  
  # Translate the Stata expression to R first
  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, current_context)

  # Ensure r_expr is a character string literal, even if it represents NA (logical)
  if (is.na(r_expr) && !is.character(r_expr)) { # Check for logical NA, not string "NA"
      r_expr = "NA_real_"
  } else if (is.character(r_expr) && r_expr == "") {
      # An empty string translated expression should likely be NA in numeric context
      # or empty string in string context. Let's make it explicit for safety.
      r_expr = "NA_real_" # Default to NA_real_ if it's empty string after translation
  }


  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    # The 'if' condition for generate/replace is evaluated row-wise on the whole dataset, not per group.
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  # Determine group_vars for dplyr::group_by
  group_vars_list_bare = character(0) 
  
  if (cmd_obj$is_by_prefix) {
    if (length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1])) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[!is.na(group_vars_list) & group_vars_list != ""]
      if (length(group_vars_list) > 0) {
        group_vars_list_bare = group_vars_list # Assign just the bare names
      }
    }
  }

  # Determine if the target variable will be a string type based on EXPLICIT Stata declaration.
  # If no explicit type, let R infer from the translated expression.
  force_r_output_type = NA_character_ # "character" or "numeric"

  # FIX: Added !is.na(declared_type_str) to prevent error if declared_type_str is NA
  if (!is.na(declared_type_str)) {
      if (stringi::stri_startswith_fixed(declared_type_str, "str")) {
          force_r_output_type = "character"
      } else { # byte, int, long, float, double
          force_r_output_type = "numeric"
      }
  }

  # Step 1: Calculate the value for the new variable, potentially conditionally
  calculated_value_expr_raw = r_expr # This is the R translation of stata_expr

  # Apply explicit type casting if declared in Stata command
  if (force_r_output_type == "character") {
      # If Stata expression is numeric NA (.), it translates to NA_real_.
      # When assigned to a string variable, Stata treats '.' as "".
      if (isTRUE(calculated_value_expr_raw == "NA_real_")) {
          calculated_value_expr = '""'
      } else {
          # Cast to character for other expressions
          calculated_value_expr = paste0("as.character(", calculated_value_expr_raw, ")")
      }
  } else if (force_r_output_type == "numeric") {
      # Ensure logicals become 0/1. Other numeric types should already be fine.
      # This handles `gen newvar = x==y` resulting in numeric 0/1.
      # Added robustness check for NA or empty `calculated_value_expr_raw`
      is_logical_r_expr = FALSE # Default to FALSE
      if (!is.na(calculated_value_expr_raw) && calculated_value_expr_raw != "") {
        # Check if the expression contains logical operators or literals, and is not already an if_else.
        regex_match = stringi::stri_detect_regex(calculated_value_expr_raw, "\\bTRUE\\b|\\bFALSE\\b|==|!=|<=|>=|<|>|&|\\||\\bsfun_missing\\b")
        fixed_match = stringi::stri_detect_fixed(calculated_value_expr_raw, "dplyr::if_else")
        # Ensure the result of logical operations is always TRUE/FALSE, never NA.
        is_logical_r_expr = dplyr::coalesce(regex_match, FALSE) && !dplyr::coalesce(fixed_match, FALSE)
      }
      if (is_logical_r_expr) {
          calculated_value_expr = paste0("as.numeric(", calculated_value_expr_raw, ")")
      } else {
          calculated_value_expr = calculated_value_expr_raw
      }
  } else { # No explicit type declared in Stata, let R infer
      calculated_value_expr = calculated_value_expr_raw
  }

  # The value to assign if the condition is false/missing.
  # If R infers, it should infer NA for missing.
  na_or_empty_str_for_false_cond = if (sfun_is_stata_expression_string_typed(stata_expr)) '""' else "NA_real_"


  # Apply condition only if it exists
  if (!is.na(r_if_cond) && r_if_cond != "") {
    calc_expr = paste0("dplyr::if_else(as.logical(dplyr::coalesce(", r_if_cond, ", FALSE)), ", calculated_value_expr, ", ", na_or_empty_str_for_false_cond, ")")
  } else {
    calc_expr = calculated_value_expr
  }

  # Step 2: Build the R code string using pipes for the mutate operation
  pipe_elements = list("data") # Elements for the pipe chain, starting from `data`

  # Add grouping and mutate steps
  if (length(group_vars_list_bare) > 0) {
      group_by_call_str = paste0('dplyr::group_by(!!!dplyr::syms(c("', paste0(group_vars_list_bare, collapse='", "'), '")))')
      pipe_elements = c(pipe_elements, group_by_call_str)
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", new_var, "` = ", calc_expr, ")"))
      pipe_elements = c(pipe_elements, "dplyr::ungroup()")
  } else {
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", new_var, "` = ", calc_expr, ")"))
  }

  # This is the final assignment line for the current command
  # It takes 'data' (potentially already arranged) and pipes it through the rest
  r_code_lines = c(paste0("data = ", paste(pipe_elements, collapse = " %>% \n  ")))
  
  return(paste(r_code_lines, collapse="\n"))
}
```
!END_CHANGE_FILE R/t_generate.R

!CHANGE_FILE R/t_replace.R
```R
t_replace = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_replace")
  # Capture explicit type declaration (e.g., `str10`)
  explicit_type_match = stringi::stri_match_first_regex(rest_of_cmd, "^(?:byte|int|long|float|double|str\\d+|strL)\\s+")
  declared_type_str = NA_character_
  if (!is.na(explicit_type_match[1,1])) {
    declared_type_str = explicit_type_match[1,2]
  }

  # Strip type if present (e.g. replace double oldvar = ...)
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^(?:byte|int|long|float|double|str\\d+|strL)\\s+", "")

  match = stringi::stri_match_first_regex(rest_of_cmd_no_type, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  # NEW: Defensive check for successful parsing of core components
  if (is.na(match[1,1]) || is.na(match[1,2]) || is.na(match[1,3])) {
    return(paste0("# Failed to parse replace command structure: ", rest_of_cmd))
  }

  var_to_replace = stringi::stri_trim_both(match[1,2])
  stata_expr = stringi::stri_trim_both(match[1,3])
  stata_if_cond = stringi::stri_trim_both(match[1,4]) # Might be NA

  current_context = list(is_by_group = cmd_obj$is_by_prefix && length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1]))
  # Translate the Stata expression to R first
  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, current_context)

  # Ensure r_expr is a character string literal, even if it represents NA (logical)
  if (is.na(r_expr) && !is.character(r_expr)) { # Check for logical NA, not string "NA"
      r_expr = "NA_real_"
  } else if (is.character(r_expr) && r_expr == "") {
      r_expr = "NA_real_"
  }

  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  # Determine group_vars for dplyr::group_by
  group_vars_list_bare = character(0)

  if (cmd_obj$is_by_prefix) {
    if (length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1])) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[!is.na(group_vars_list) & group_vars_list != ""]
      if (length(group_vars_list) > 0) {
        group_vars_list_bare = group_vars_list # Assign just the bare names
      }
    }
  }

  # Determine if the target variable will be a string type based on EXPLICIT Stata declaration.
  # If no explicit type, let R infer from the translated expression.
  force_r_output_type = NA_character_ # "character" or "numeric"

  # FIX: Added !is.na(declared_type_str) to prevent error if declared_type_str is NA
  if (!is.na(declared_type_str)) {
      if (stringi::stri_startswith_fixed(declared_type_str, "str")) {
          force_r_output_type = "character"
      } else { # byte, int, long, float, double
          force_r_output_type = "numeric"
      }
  }

  # Step 1: Calculate the value for the new variable, potentially conditionally
  calculated_value_expr_raw = r_expr # This is the R translation of stata_expr

  # Apply explicit type casting if declared in Stata command
  if (force_r_output_type == "character") {
      # If Stata expression is numeric NA (.), it translates to NA_real_.
      # When assigned to a string variable, Stata treats '.' as "".
      if (isTRUE(calculated_value_expr_raw == "NA_real_")) {
          calculated_value_expr = '""'
      } else {
          # Cast to character for other expressions
          calculated_value_expr = paste0("as.character(", calculated_value_expr_raw, ")")
      }
  } else if (force_r_output_type == "numeric") {
      # Ensure logicals become 0/1. Other numeric types should already be fine.
      # This handles `gen newvar = x==y` resulting in numeric 0/1.
      # Added robustness check for NA or empty `calculated_value_expr_raw`
      is_logical_r_expr = FALSE # Default to FALSE
      if (!is.na(calculated_value_expr_raw) && calculated_value_expr_raw != "") {
        # Check if the expression contains logical operators or literals, and is not already an if_else.
        regex_match = stringi::stri_detect_regex(calculated_value_expr_raw, "\\bTRUE\\b|\\bFALSE\\b|==|!=|<=|>=|<|>|&|\\||\\bsfun_missing\\b")
        fixed_match = stringi::stri_detect_fixed(calculated_value_expr_raw, "dplyr::if_else")
        # Ensure the result of logical operations is always TRUE/FALSE, never NA.
        is_logical_r_expr = dplyr::coalesce(regex_match, FALSE) && !dplyr::coalesce(fixed_match, FALSE)
      }
      if (is_logical_r_expr) {
          calculated_value_expr = paste0("as.numeric(", calculated_value_expr_raw, ")")
      } else {
          calculated_value_expr = calculated_value_expr_raw
      }
  } else { # No explicit type declared in Stata, let R infer
      calculated_value_expr = calculated_value_expr_raw
  }


  # For 'replace' command, if condition is FALSE or NA, the value should be left unchanged.
  # Use dplyr::coalesce(condition, FALSE) to treat NA condition as FALSE.
  # Apply condition only if it exists
  if (!is.na(r_if_cond) && r_if_cond != "") {
    calc_expr = paste0("dplyr::if_else(as.logical(dplyr::coalesce(", r_if_cond, ", FALSE)), ", calculated_value_expr, ", data$`", var_to_replace, "`)")
  } else {
    calc_expr = calculated_value_expr
  }

  # Step 2: Build the R code string using pipes for the mutate operation
  pipe_elements = list("data") # Elements for the pipe chain, starting from `data`

  if (length(group_vars_list_bare) > 0) { # Check if group_vars_list_bare is not empty
      group_by_call_str = paste0('dplyr::group_by(!!!dplyr::syms(c("', paste0(group_vars_list_bare, collapse='", "'), '")))')
      pipe_elements = c(pipe_elements, group_by_call_str)
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", var_to_replace, "` = ", calc_expr, ")"))
      pipe_elements = c(pipe_elements, "dplyr::ungroup()")
  } else {
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", var_to_replace, "` = ", calc_expr, ")"))
  }

  r_code_lines = c(paste0("data = ", paste(pipe_elements, collapse = " %>% \n  ")))

  return(paste(r_code_lines, collapse="\n"))
}
```
!END_CHANGE_FILE R/t_replace.R

!CHANGE_FILE R/t_duplicates.R
```R
# Translate Stata 'duplicates' command
# Stata: duplicates drop [varlist] [if] [in] [, options]
# Stata: duplicates tag varlist [if] [in] [, options] gen(newvar)
# Stata: duplicates list [varlist] [if] [in] [, options]

t_duplicates = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_duplicates") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse subcommand (drop, tag, list)
  parts_subcmd = stringi::stri_split_regex(rest_of_cmd_trimmed, "\\s+", n=2)[[1]]
  subcommand = stringi::stri_trim_both(parts_subcmd[1])
  rest_after_subcmd = if(length(parts_subcmd) > 1) stringi::stri_trim_both(parts_subcmd[2]) else NA_character_

  if (is.na(subcommand) || !(subcommand %in% c("drop", "tag", "list"))) {
      return(paste0("# Failed to parse duplicates subcommand (drop, tag, or list required): ", rest_of_cmd))
  }

  varlist_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  if(!is.na(rest_after_subcmd)){
    if_in_match = stringi::stri_match_first_regex(rest_after_subcmd, "\\s+(?:if\\s+|in\\s+)(.*)$")
    if(!is.na(if_in_match[1,1])) {
        stata_if_in_cond = if_in_match[1,2]
        rest_after_subcmd_no_if_in = stringi::stri_replace_last_regex(rest_after_subcmd, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
        rest_after_subcmd_no_if_in = stringi::stri_trim_both(rest_after_subcmd_no_if_in)
    } else {
        rest_after_subcmd_no_if_in = rest_after_subcmd
    }

    options_match = stringi::stri_match_first_regex(rest_after_subcmd_no_if_in, ",\\s*(.*)$")
    if (!is.na(options_match[1,1])) {
        options_str = stringi::stri_trim_both(options_match[1,2])
        varlist_str = stringi::stri_replace_last_regex(rest_after_subcmd_no_if_in, ",\\s*(.*)$", "")
        varlist_str = stringi::stri_trim_both(varlist_str)
    } else {
        varlist_str = rest_after_subcmd_no_if_in
    }
  }

  vars_for_duplicates = NA_character_
  if (!is.na(varlist_str) && varlist_str != "") {
      vars_for_duplicates_list = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
      vars_for_duplicates_list = vars_for_duplicates_list[vars_for_duplicates_list != ""]
       if (length(vars_for_duplicates_list) > 0) {
           vars_for_duplicates = paste0('c("', paste(vars_for_duplicates_list, collapse = '", "'), '")')
       }
  }

  r_subset_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for duplicates: ", stata_if_in_cond))
      }
  }

  r_code_lines = c()
  # Temporary variable names
  is_duplicate_tmp_var = paste0("stata_tmp_is_duplicate_L", cmd_obj$line)
  is_first_tmp_var = paste0("stata_tmp_is_first_L", cmd_obj$line)
  data_duplicates_tmp_var = paste0("stata_tmp_data_duplicates_L", cmd_obj$line)


  if (subcommand == "drop") {
      # For filter, NA in condition is treated as FALSE, which matches Stata's behavior.
      filter_cond_expr = if (!is.na(r_subset_cond) && r_subset_cond != "") {
                           paste0("as.logical(dplyr::coalesce(", r_subset_cond, ", FALSE))")
                         } else {
                           "TRUE"
                         }

      comment_vars_part = if(is.na(vars_for_duplicates)) "all variables" else paste0("variables: ", varlist_str)
      if (is.na(vars_for_duplicates)) {
          is_duplicate_expr = "base::duplicated(data, fromLast = FALSE)"
      } else {
           is_duplicate_expr = paste0("base::duplicated(data[, ", vars_for_duplicates, ", drop = FALSE], fromLast = FALSE)")
      }

      r_code_lines = c(
          r_code_lines,
          paste0("## Calculate duplicate flag based on ", comment_vars_part),
          paste0(is_duplicate_tmp_var, " = ", is_duplicate_expr),
          paste0("data = dplyr::filter(data, !(", is_duplicate_tmp_var, " & ", filter_cond_expr, "))"),
          paste0("rm(", is_duplicate_tmp_var, ")")
      )

  } else if (subcommand == "tag") {
      gen_var = NA_character_
      if (!is.na(options_str)) {
         gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgen\\s*\\(([^)]+)\\)")
         if (!is.na(gen_opt_match[1,1])) {
             gen_vars_str = stringi::stri_trim_both(gen_opt_match[1,2])
             gen_vars_list = stringi::stri_split_regex(gen_vars_str, "\\s+")[[1]]
             gen_var = gen_vars_list[1]
         }
      }

      if (is.na(gen_var)) {
          return(paste0("# duplicates tag requires gen() option: ", rest_of_cmd))
      }

      mutate_cond_expr = if (!is.na(r_subset_cond) && r_subset_cond != "") {
                           paste0("as.logical(dplyr::coalesce(", r_subset_cond, ", FALSE))")
                         } else {
                           "TRUE"
                         }
      
      comment_vars_part = if(is.na(vars_for_duplicates)) "all variables" else paste0("variables: ", varlist_str)

       if (is.na(vars_for_duplicates)) {
          is_first_occurrence_expr = "!base::duplicated(data, fromLast = FALSE)"
      } else {
           is_first_occurrence_expr = paste0("!base::duplicated(data[, ", vars_for_duplicates, ", drop = FALSE], fromLast = FALSE)")
      }

       r_code_lines = c(
          r_code_lines,
          paste0("## Calculate first occurrence flag based on ", comment_vars_part),
          paste0(is_first_tmp_var, " = ", is_first_occurrence_expr),
          paste0("data = dplyr::mutate(data, `", gen_var, "` = dplyr::if_else(", is_first_tmp_var, " & ", mutate_cond_expr, ", 1, 0))"),
          paste0("rm(", is_first_tmp_var, ")")
       )

  } else if (subcommand == "list") {
       filter_cond_expr = if (!is.na(r_subset_cond) && r_subset_cond != "") {
                           paste0("as.logical(dplyr::coalesce(", r_subset_cond, ", FALSE))")
                         } else {
                           "TRUE"
                         }
       comment_vars_part = if(is.na(vars_for_duplicates)) "all variables" else paste0("variables: ", varlist_str)

        if (is.na(vars_for_duplicates)) {
          is_duplicate_expr = "base::duplicated(data, fromLast = FALSE)"
      } else {
           is_duplicate_expr = paste0("base::duplicated(data[, ", vars_for_duplicates, ", drop = FALSE], fromLast = FALSE)")
      }

       r_code_lines = c(
          r_code_lines,
          paste0("## Calculate duplicate flag based on ", comment_vars_part),
          paste0(is_duplicate_tmp_var, " = ", is_duplicate_expr),
          paste0(data_duplicates_tmp_var, " = dplyr::filter(data, ", is_duplicate_tmp_var, " & ", filter_cond_expr, ")"),
          paste0("print(", data_duplicates_tmp_var, ")"),
          paste0("rm(", is_duplicate_tmp_var, ", ", data_duplicates_tmp_var, ")")
       )

  } else {
      r_code_lines = c(r_code_lines, paste0("# Unknown duplicates subcommand: ", subcommand))
  }

  r_code_str = paste(r_code_lines, collapse="\n")

   options_str_cleaned = options_str
   if (subcommand == "tag" && !is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bgen\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }

  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_duplicates.R

!CHANGE_FILE R/t_decode.R
```R
# Translate Stata 'decode' command
# Stata: decode varname [if] [in] , gen(newvar) [options]
# Converts numeric varname with value labels into string newvar.

t_decode = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_decode") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varname, if/in, options (especially gen())
  # Pattern: `varname [if] [in] , options`

  varname_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Find if/in first
  if_in_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rest_no_if_in = stringi::stri_replace_last_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rest_no_if_in = stringi::stri_trim_both(rest_no_if_in)
  } else {
      rest_no_if_in = rest_of_cmd_trimmed
  }

   # Find options
  options_match = stringi::stri_match_first_regex(rest_no_if_in, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      varname_str = stringi::stri_replace_last_regex(rest_no_if_in, ",\\s*(.*)$", "")
      varname_str = stringi::stri_trim_both(varname_str)
  } else {
      # This case implies `decode varname` without `, gen(newvar)` which is invalid for decode.
      # Stata syntax is `decode varname, gen(newvar)`. The comma is mandatory before options.
      # So, if no comma, there are no options, and thus no gen().
      # This means `gen_var` will be NA, and the error will be thrown later.
      return(paste0("# decode command requires gen() in options: ", rest_of_cmd))
  }

   if (is.na(varname_str) || varname_str == "") {
       return(paste0("# decode command requires varname: ", rest_of_cmd))
   }

  # Parse options, specifically `gen()`
  gen_var = NA_character_
  if (!is.na(options_str)) {
      # Modified regex to accept 'gen' or 'generate'
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\b(?:gen|generate)\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars_str = stringi::stri_trim_both(gen_opt_match[1,2])
           gen_vars_list = stringi::stri_split_regex(gen_vars_str, "\\s+")[[1]]
           gen_var = gen_vars_list[1] # decode generates a single variable
       }
  }

  if (is.na(gen_var)) {
      return(paste0("# decode requires gen() option: ", rest_of_cmd))
  }

  # Translate if/in condition
  r_if_in_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
       # Context for if/in is global, not by_group specific for resolution, but _n/_N can be tricky
       r_if_in_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group=FALSE))
       if (is.na(r_if_in_cond) || r_if_in_cond == "") {
           return(paste0("# Failed to translate if/in condition for decode: ", stata_if_in_cond))
       }
  }

  # Temporary variable names
  temp_decoded_values_L = paste0("stata_tmp_decoded_values_L", cmd_obj$line)
  temp_source_vector_L = paste0("stata_tmp_source_vector_L", cmd_obj$line)

   r_code_lines = c(
      paste0("data = dplyr::mutate(data, `", gen_var, "` = NA_character_)")
   )

   r_code_lines = c(r_code_lines,
      paste0("## Decode values using haven::as_factor"),
      paste0(temp_source_vector_L, " = data[['", varname_str, "']]"), # Store original values
      # Calculate decoded values. haven::as_factor converts unlabelled values to NA.
      # Corrected: removed `levels = 'labels'`
      paste0(temp_decoded_values_L, " = as.character(haven::as_factor(", temp_source_vector_L, "))"),
      # Stata's decode for unlabelled numeric values converts them to their string representation.
      # And missing values (NA) are converted to empty string "".
      paste0(temp_decoded_values_L, " = dplyr::if_else(is.na(", temp_decoded_values_L, "), ",
                                    "dplyr::if_else(is.na(", temp_source_vector_L, "), \"\", as.character(", temp_source_vector_L, ")), ",
                                    temp_decoded_values_L, ")")
   )

  # Apply the if/in condition for replacement
  if (!is.na(r_if_in_cond) && r_if_in_cond != "") {
       r_code_lines = c(r_code_lines,
           paste0("data = dplyr::mutate(data, `", gen_var, "` = dplyr::if_else(as.logical(dplyr::coalesce(", r_if_in_cond, ", FALSE)), ", temp_decoded_values_L, ", `", gen_var, "`))")
       )
  } else {
      r_code_lines = c(r_code_lines,
           paste0("data = dplyr::mutate(data, `", gen_var, "` = ", temp_decoded_values_L, ")")
      )
  }

  r_code_lines = c(r_code_lines, paste0("rm(", temp_decoded_values_L, ", ", temp_source_vector_L, ")"))

  r_code_str = paste(r_code_lines, collapse="\n")

   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\b(?:gen|generate)\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }

  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_decode.R

!CHANGE_FILE R/t_encode.R
```R
# Translate Stata 'encode' command
# Stata: encode varname [if] [in] , gen(newvar) [options]
# Converts string varname into numeric newvar with value labels.

t_encode = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_encode")
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varname, if/in, options (especially gen())
  varname_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Find if/in first
  if_in_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rest_no_if_in = stringi::stri_replace_last_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rest_no_if_in = stringi::stri_trim_both(rest_no_if_in)
  } else {
      rest_no_if_in = rest_of_cmd_trimmed
  }

   # Find options (which contain gen())
  options_match = stringi::stri_match_first_regex(rest_no_if_in, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      varname_str = stringi::stri_replace_last_regex(rest_no_if_in, ",\\s*(.*)$", "")
      varname_str = stringi::stri_trim_both(varname_str)
  } else {
      # This case implies `encode varname` without `, gen(newvar)` which is invalid for encode.
      # Stata syntax is `encode varname, gen(newvar)`. The comma is mandatory before options.
      # So, if no comma, there are no options, and thus no gen().
      # This means `gen_var` will be NA, and the error will be thrown later.
      return(paste0("# encode command requires gen() in options: ", rest_of_cmd))
  }

   if (is.na(varname_str) || varname_str == "") {
       return(paste0("# encode command requires varname: ", rest_of_cmd))
   }

  # Parse options, specifically `gen()` or `generate()`
  gen_var = NA_character_
  if (!is.na(options_str)) {
      # Modified regex to accept 'gen' or 'generate'
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\b(?:gen|generate)\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars_str = stringi::stri_trim_both(gen_opt_match[1,2])
           gen_vars_list = stringi::stri_split_regex(gen_vars_str, "\\s+")[[1]]
           gen_var = gen_vars_list[1] # encode generates a single variable
       }
  }

  if (is.na(gen_var)) {
      return(paste0("# encode requires gen() option: ", rest_of_cmd))
  }

  # Translate if/in condition
  r_if_in_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
       r_if_in_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group=FALSE))
       if (is.na(r_if_in_cond) || r_if_in_cond == "") {
           return(paste0("# Failed to translate if/in condition for encode: ", stata_if_in_cond))
       }
  }

  # Temporary variable names for the fully calculated encoded vector and condition
  encoded_values_full_tmp_var = paste0("stata_tmp_encoded_full_L", cmd_obj$line)
  
  r_code_lines = c()

  # Initialize the new column as an integer vector. Labels will be applied by label values.
  r_code_lines = c(r_code_lines,
    paste0("data = dplyr::mutate(data, `", gen_var, "` = NA_integer_)")
  )

  # Calculate the full encoded vector (based on all unique values in source column, sorted alphabetically)
  # Stata encode assigns numeric codes (1, 2, ...) to non-missing string values, preserving missing values as NA.
  r_code_lines = c(r_code_lines,
    paste0("temp_source_vector_L", cmd_obj$line, " = data[['", varname_str, "']]"),
    # Get unique, non-NA, sorted string values to define the mapping to numeric codes
    paste0("temp_unique_values_L", cmd_obj$line, " = base::sort(base::unique(temp_source_vector_L", cmd_obj$line, "[!is.na(temp_source_vector_L", cmd_obj$line, ")]))"),
    # Create the integer codes (1, 2, ...) based on the sorted unique values. NA values in source remain NA.
    paste0("temp_numeric_values_L", cmd_obj$line, " = base::match(temp_source_vector_L", cmd_obj$line, ", temp_unique_values_L", cmd_obj$line, ")"),
    # Create the labels vector in the R code for haven::labelled
    paste0("temp_labels_vector_L", cmd_obj$line, " = stats::setNames(as.numeric(1:length(temp_unique_values_L", cmd_obj$line, ")), temp_unique_values_L", cmd_obj$line, ")"),
    # Create the haven::labelled object
    paste0(encoded_values_full_tmp_var, " = haven::labelled(as.integer(temp_numeric_values_L", cmd_obj$line, "), labels = temp_labels_vector_L", cmd_obj$line, ")"),
    # Clean up intermediate temp variables
    paste0("rm(temp_source_vector_L", cmd_obj$line, ", temp_unique_values_L", cmd_obj$line, ", temp_numeric_values_L", cmd_obj$line, ", temp_labels_vector_L", cmd_obj$line, ")")
  )

  # Apply the if/in condition for assignment to the target column in 'data'
  if (!is.na(r_if_in_cond) && r_if_in_cond != "") {
       r_code_lines = c(r_code_lines,
           paste0("data = dplyr::mutate(data, `", gen_var, "` = dplyr::if_else(as.logical(dplyr::coalesce(", r_if_in_cond, ", FALSE)), ", encoded_values_full_tmp_var, ", `", gen_var, "`))")
       )
  } else {
      # No condition, assign the full encoded vector
      r_code_lines = c(r_code_lines,
           paste0("data[['", gen_var, "']] = ", encoded_values_full_tmp_var)
      )
  }

  r_code_lines = c(r_code_lines, paste0("rm(", encoded_values_full_tmp_var, ")"))

  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about other options if any were present but not handled (excluding gen)
   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        # Modify regex to remove both 'gen' and 'generate' forms
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\b(?:gen|generate)\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0("\n# Other options ignored: ", options_str_cleaned))
   }

  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_encode.R
