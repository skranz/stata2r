!CHANGE_FILE aic_do_test.R
```
examples = function() {
  do_file = "C:/libraries/aicoder/stata2r/inst/cases/custom_1/do1.do"
  aic_stata2r_do_test(aic=NULL, test_dir = "~/aicoder/stata2r/aicoder_work/tests/do1", data_dir = "~/aicoder/stata2r/inst/cases/do1/do_data")
}

aic_stata2r_do_test = function(aic, test_dir, data_dir, data_prefix="") {
  restore.point("aic_stata2r_do_test")
  txt = capture.output(err<-try(aic_stata2r_do_test_inner(test_dir, data_dir, data_prefix), silent=TRUE))
  log = out_and_err_txt(txt, err)
  cat(log)
  has_err = is(err, "try-error") | isTRUE(err==FALSE)

  #test_log= list(ok=!has_err,test_name=basename(test_dir), msg="", log=log)
  aic = aic_add_test(aic, test_name=basename(test_dir), ok=!has_err, log=log)
  aic
}

aic_stata2r_do_test_inner = function(test_dir, data_dir, data_prefix="") {
  restore.point("aic_stata2r_do_test_inner")
  setwd(test_dir)
  library(stata2r)
  # Explicitly load dependencies for the test environment
  library(collapse)
  library(dplyr)
  library(stringi)
  library(haven)
  library(tidyr) # For reshape
  library(restorepoint) # If used by translated code or framework
  library(readr) # For destring

  # do code that will be translated
  do_code = readLines("do1.do", warn=FALSE)
  #cat(do_code, sep="\n")


  # transforms do_code to a dataframe with
  # one row for each code line possible
  # perform some preparsing
  # the field do_code should contain the original code
  cat("\ncmd_df = do_parse(do_code)")
  cmd_df = do_parse(do_code)

  # will add field "do_translate"
  # if FALSE the stata command does not modify the data set
  # and can be ignored
  cat("\ncmd_df = mark_data_manip_cmd(cmd_df)\n")
  cmd_df = mark_data_manip_cmd(cmd_df)
  cat("\nstr(cmd_df)\n")
  print(str(cmd_df))

  r_li = vector("list", NROW(cmd_df))

  cat("\n---\n#Translate to R commands\n")
  i = 1
  for (i in seq_along(r_li)) {
    #cat("\n", i,"of", length(r_li), "translate", cmd_df$do_code[[i]],"\n")
    cat("\ndo: ", cmd_df$do_code[[i]],"\n")
    cmd_obj = cmd_df[i,]
    r_obj = do_cmd_to_r(cmd_obj=cmd_obj,line=i, cmd_df=cmd_df)
    #print(str(r_obj))
    if (isTRUE(cmd_df$do_translate[i])) {
      cat("R: ", r_obj$r_code,"\n")
      r_li[[i]] = r_obj
    } else {
      cat("  no data manipulation command\n")
    }
  }
  r_df = bind_rows(r_li)

  env = new.env(parent=globalenv())

  cat("\n---\n# Run R commands and check generated data sets\n\n")
  i = 1
  log_str = NULL
  for (i in seq_len(NROW(r_df))) {
    r_code = r_df$r_code[[i]]

    res = aicoder::run_with_log(code_str=r_code, env=env)
    cat("\n",i,res$log)
    if (res$has_error) return(FALSE)
      r_data = env[["data"]]
    if (!is.null(r_data)) {
      dat_file = file.path(data_dir, paste0(data_prefix,i,".dta"))
      do_data = haven::read_dta(dat_file)
      comp = compare_df(r_data, do_data)
      if (!comp$identical) {
        cat("\nError: After the R command abve generates different data set than Stata code\n")
        cat("\nR data set:\n")
        print(str(r_data))
        cat("\nStata version:\n")
        print(str(do_data))
        cat("\nDifferences:")
        print(str(comp))
        return(FALSE)
      }
    } else {
      cat("\n", i," missing data\n")
      return(FALSE)
    }
    if (res$has_error) return(FALSE)
  }
  return(TRUE)



}

aic_stata2r_eval_next_r_line = function(i, r_df, env) {

}

aic_stata2r_eval_example = function(do_file) {
  library(stata2r)
  do_dir = dirname(do_file)
  do_text = readLines(do_file)
  r_code = do_to_r(do_code)

  library(stata2r)
  library(aicoder)

}


out_and_err_txt = function(out, err=NULL) {
  if (is(err,"try-error")) {
    out = c(out,as.character(err))
  }
  paste0(out, collapse="\n")
}

compare_df = function(df1, df2,
                      tol = .Machine$double.eps^0.5,  # numeric tolerance
                      ignore_col_order = FALSE,
                      ignore_row_order = FALSE,
                      sample_n_diff = 5) {            # max rows to show per column

  # ---- basic structure checks ----
  if (!is.data.frame(df1) || !is.data.frame(df2))
    stop("Both inputs must be data frames.")

  if(identical(df1, df2)) return(list(identical=TRUE))

  if (ignore_col_order) {
    df1 = df1[, sort(names(df1)), drop = FALSE]
    df2 = df2[, sort(names(df2)), drop = FALSE]
  }
  if (ignore_row_order) {
    df1 = dplyr::arrange(df1, dplyr::across(dplyr::everything()))
    df2 = dplyr::arrange(df2, dplyr::across(dplyr::everything()))
  }

  out = list(identical=FALSE)

  # ---- dimension and column checks ----
  if (nrow(df1) != nrow(df2))
    out$row_count = c(df1 = nrow(df1), df2 = nrow(df2))

  missing_in_df1 = setdiff(names(df2), names(df1))
  missing_in_df2 = setdiff(names(df1), names(df2))
  if (length(missing_in_df1) + length(missing_in_df2) > 0)
    out$column_mismatch = list(missing_in_df1 = missing_in_df1,
                               missing_in_df2 = missing_in_df2)

  common_cols = intersect(names(df1), names(df2))

  # ---- class / type mismatches ----
  type_df = data.frame(col = common_cols,
                       class_df1 = vapply(df1[common_cols], class, character(1)),
                       class_df2 = vapply(df2[common_cols], class, character(1)),
                       stringsAsFactors = FALSE)
  type_diff = type_df[type_df$class_df1 != type_df$class_df2, ]
  if (nrow(type_diff) > 0)
    out$type_mismatch = type_diff

  # ---- valueâ€level comparison ----
  value_diffs = lapply(common_cols, function(cl) {
    v1 = df1[[cl]]
    v2 = df2[[cl]]

    # numeric columns need tolerance
    if (is.numeric(v1) && is.numeric(v2)) {
      neq = abs(v1 - v2) > tol | xor(is.na(v1), is.na(v2))
    } else {
      neq = v1 != v2 | xor(is.na(v1), is.na(v2))
    }
    which(neq)
  })
  names(value_diffs) = common_cols
  value_diffs = value_diffs[lengths(value_diffs) > 0]

  if (length(value_diffs) > 0) {
    # build a compact summary with at most sample_n_diff rows per column
    sampler = function(idx, cl) {
      head_idx = head(idx, sample_n_diff)
      data.frame(row = head_idx,
                 column = cl,
                 df1_value = df1[[cl]][head_idx],
                 df2_value = df2[[cl]][head_idx],
                 stringsAsFactors = FALSE)
    }
    diff_tbl = do.call(rbind, Map(sampler, value_diffs, names(value_diffs)))
    # tidy row names
    rownames(diff_tbl) = NULL
    out$value_mismatch = diff_tbl
  }

  # ---- return decision ----
  if (length(out) <= 1) {
    return(list(identical=TRUE))
  }
  out
}
```
!END_CHANGE_FILE aic_do_test.R

!CHANGE_FILE t_generate.R
```
# Translate Stata 'generate' or 'gen' command

# Example Stata: gen newvar = oldvar * 2 if condition
# Example Stata: by group: gen seq = _n
t_generate = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  # Parse `rest_of_cmd` for new variable name, expression, and if condition
  # Example: "newvar = expression [if condition]"

  # Strip type if present (e.g. gen double newvar = ...)
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^(?:byte|int|long|float|double)\\s+", "")

  match = stringi::stri_match_first_regex(rest_of_cmd_no_type, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  if (is.na(match[1,1])) {
    return(paste0("# Failed to parse generate command: ", rest_of_cmd))
  }

  new_var = stringi::stri_trim_both(match[1,2])
  stata_expr = stringi::stri_trim_both(match[1,3])
  stata_if_cond = stringi::stri_trim_both(match[1,4]) # Might be NA

  # Context for expression translation (e.g. _n, _N behavior)
  # is_by_group TRUE if cmd_obj$by_group_vars is not NA
  current_context = list(is_by_group = cmd_obj$is_by_prefix && !is.na(cmd_obj$by_group_vars))
  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, current_context)

  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    # The 'if' condition for generate/replace is evaluated row-wise on the whole dataset, not per group.
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  # Prepare for by-processing steps as pipe components
  arrange_step = ""
  group_vars_r_vec_str = NULL
  
  if (cmd_obj$is_by_prefix) {
    if (!is.na(cmd_obj$by_group_vars)) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[group_vars_list != ""]
      group_vars_r_vec_str = paste0('c("', paste0(group_vars_list, collapse='", "'), '")')
    }

    sort_vars_list = character(0)
    if (!is.na(cmd_obj$by_sort_vars)) {
      sort_vars_list = stringi::stri_split_fixed(cmd_obj$by_sort_vars, ",")[[1]]
      sort_vars_list = sort_vars_list[sort_vars_list != ""]
    }

    # If there are sort keys for by-processing (e.g., for lags/leads), arrange data first
    if (length(sort_vars_list) > 0) {
      all_sort_vars = c(if(!is.null(group_vars_list)) group_vars_list else character(0), sort_vars_list)
      all_sort_vars_str = paste(all_sort_vars, collapse = ", ")
      arrange_step = paste0("dplyr::arrange(data, ", all_sort_vars_str, ")")
    }
  }

  if (!is.na(r_if_cond) && r_if_cond != "") {
    mutate_expr = paste0(new_var, " = dplyr::if_else(", r_if_cond, ", ", r_expr, ", NA_real_)")
  } else {
    mutate_expr = paste0(new_var, " = ", r_expr)
  }

  # Build the R code string using pipes
  r_code_parts = c()

  if (arrange_step != "") {
      r_code_parts = c(r_code_parts, arrange_step)
  } else {
      r_code_parts = c(r_code_parts, "data") # Start with data if no arrange step
  }

  if (!is.null(group_vars_r_vec_str)) {
      r_code_parts = c(r_code_parts, paste0("  %>% collapse::fgroup_by(", group_vars_r_vec_str, ")"))
      r_code_parts = c(r_code_parts, paste0("  %>% collapse::fmutate(", mutate_expr, ")"))
      r_code_parts = c(r_code_parts, paste0("  %>% collapse::fungroup()"))
  } else {
      # If not grouped, still use a pipe for fmutate for consistency and clarity
      if (arrange_step == "") { # If no arrange, first pipe is directly to fmutate
          r_code_parts = c(r_code_parts, paste0("  %>% collapse::fmutate(", mutate_expr, ")"))
      } else { # If arrange exists, fmutate is another pipe in the chain
          r_code_parts = c(r_code_parts, paste0("  %>% collapse::fmutate(", mutate_expr, ")"))
      }
  }

  # Final assignment: data = first_part %>% ...
  r_code_str = paste0("data = ", paste(r_code_parts, collapse="\n"))
  
  return(r_code_str)
}
```
!END_CHANGE_FILE t_generate.R

!CHANGE_FILE t_replace.R
```
# Translate Stata 'replace' command
# Stata: replace oldvar = expression [if condition]
t_replace = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  match = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  if (is.na(match[1,1])) {
    return(paste0("# Failed to parse replace command: ", rest_of_cmd))
  }

  var_to_replace = stringi::stri_trim_both(match[1,2])
  stata_expr = stringi::stri_trim_both(match[1,3])
  stata_if_cond = stringi::stri_trim_both(match[1,4]) # Might be NA

  current_context = list(is_by_group = cmd_obj$is_by_prefix && !is.na(cmd_obj$by_group_vars))
  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, current_context)

  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  # Prepare for by-processing steps as pipe components
  arrange_step = ""
  group_vars_r_vec_str = NULL

  if (cmd_obj$is_by_prefix) {
    if (!is.na(cmd_obj$by_group_vars)) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[group_vars_list != ""]
      group_vars_r_vec_str = paste0('c("', paste0(group_vars_list, collapse='", "'), '")')
    }

    sort_vars_list = character(0)
    if (!is.na(cmd_obj$by_sort_vars)) {
      sort_vars_list = stringi::stri_split_fixed(cmd_obj$by_sort_vars, ",")[[1]]
      sort_vars_list = sort_vars_list[sort_vars_list != ""]
    }

    if (length(sort_vars_list) > 0) {
      all_sort_vars = c(if(!is.null(group_vars_list)) group_vars_list else character(0), sort_vars_list)
      all_sort_vars_str = paste(all_sort_vars, collapse = ", ")
      arrange_step = paste0("dplyr::arrange(data, ", all_sort_vars_str, ")")
    }
  }


  if (!is.na(r_if_cond) && r_if_cond != "") {
    mutate_expr = paste0(var_to_replace, " = dplyr::if_else(", r_if_cond, ", ", r_expr, ", ", var_to_replace, ")")
  } else {
    mutate_expr = paste0(var_to_replace, " = ", r_expr)
  }

  # Build the R code string using pipes
  r_code_parts = c()

  if (arrange_step != "") {
      r_code_parts = c(r_code_parts, arrange_step)
  } else {
      r_code_parts = c(r_code_parts, "data") # Start with data if no arrange step
  }

  if (!is.null(group_vars_r_vec_str)) {
      r_code_parts = c(r_code_parts, paste0("  %>% collapse::fgroup_by(", group_vars_r_vec_str, ")"))
      r_code_parts = c(r_code_parts, paste0("  %>% collapse::fmutate(", mutate_expr, ")"))
      r_code_parts = c(r_code_parts, paste0("  %>% collapse::fungroup()"))
  } else {
      # If not grouped, still use a pipe for fmutate for consistency and clarity
      if (arrange_step == "") { # If no arrange, first pipe is directly to fmutate
          r_code_parts = c(r_code_parts, paste0("  %>% collapse::fmutate(", mutate_expr, ")"))
      } else { # If arrange exists, fmutate is another pipe in the chain
          r_code_parts = c(r_code_parts, paste0("  %>% collapse::fmutate(", mutate_expr, ")"))
      }
  }

  # Final assignment: data = first_part %>% ...
  r_code_str = paste0("data = ", paste(r_code_parts, collapse="\n"))

  return(r_code_str)
}
```
!END_CHANGE_FILE t_replace.R
