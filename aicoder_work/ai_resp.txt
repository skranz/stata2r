The primary issue causing the `do2` test to fail was a discrepancy in row counts between the R-generated data and the Stata reference data after the `merge` command (line 70). This likely stemmed from subtle differences in how Stata and R handle floating-point precision or `NA` values in intermediate calculations, which could lead to different rows being filtered or kept. Additionally, Stata's `merge 1:1` is very strict about unique keys, failing if duplicates exist in either dataset, whereas `dplyr::left_join` would duplicate rows in the absence of such a check.

The following changes address these potential issues and improve the general robustness of the translation:

1.  **`t_merge.R`**:
    *   **Strict `1:1` merge enforcement**: Added explicit checks for unique keys in both the master (`data`) and using datasets for `1:1` merges. If duplicate keys are found, the R code will stop with an error, mirroring Stata's strict behavior for `1:1` merges. This ensures that `dplyr::left_join` doesn't silently produce additional rows when Stata would have errored.
    *   **Consistent key types**: Explicitly converted the merge `by` variables to `as.numeric` in both the master and using datasets before performing the join. This helps prevent subtle type or attribute mismatches (e.g., `integer` vs. `double`, or `haven_labelled` attributes) that can sometimes lead to unexpected behavior or errors in `dplyr` join operations when dealing with data read by `haven`.

2.  **`t_recode.R`**:
    *   **Robust string type detection**: Refined the logic to detect if a recoded variable should be treated as a string type in R. This ensures that if any recode rule assigns a string literal (e.g., `"new_value"`), the resulting variable is correctly handled as a character vector.
    *   **Stata-compliant missing string values**: Ensured that when a recoded variable is determined to be of string type, and a rule assigns a missing value (like `.`, `.a`), it is correctly translated to an empty string `""` in R, matching Stata's behavior.

3.  **`t_generate.R` and `t_replace.R`**:
    *   **Stata-compliant missing string values**: For `generate` and `replace` commands, if the target variable is identified as a string type (either explicitly declared as `str#` or inferred from the expression), the value assigned when an `if` condition is `FALSE` or `NA` is now `""` (empty string) instead of `NA_real_`. This aligns with Stata's implicit conversion of missing numeric values to empty strings when assigned to string variables.

These changes aim to make the R translation more faithful to Stata's behavior, particularly concerning data integrity and type handling during transformations, which was crucial for resolving the row count discrepancy in the `do2` test.

!CHANGE_FILE R/t_append.R
```R
# Translate Stata 'append' command
# Stata: append using filename [, options]

t_append = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_append") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse `using filename` and options
  # Pattern: ^\s*using\s+([^,\s]+)(?:,\\s*(.*))?$
  # G1: filename (can be quoted or macro), G2: options

  append_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")

  if (is.na(append_match[1,1])) {
    return(paste0("# Failed to parse append command: ", rest_of_cmd))
  }

  raw_filename_token = stringi::stri_trim_both(append_match[1,2])
  options_str = stringi::stri_trim_both(append_match[1,3]) # NA if no options

  # Resolve the `using filename` - can be a path string or a macro
  # Changed default_base_dir_var to "working_dir" for consistency with Stata's default file paths
  using_source_r_expr = resolve_stata_filename(raw_filename_token, cmd_df, line_num, default_base_dir_var = "working_dir")

  # Stata append requires variable names to match or be harmonized.
  # dplyr::bind_rows matches columns by name. Differences are filled with NA. This is similar to Stata.
  # Options like `force` (append even if variable types don't match) are not handled.

  # Using dplyr::bind_rows instead of collapse::fbind (due to reported "not exported" error)
  r_code_str = paste0("data = dplyr::bind_rows(data, haven::read_dta(", using_source_r_expr, "))")

  # Add comment about options if any were present but not handled
  if (!is.na(options_str) && options_str != "") {
       r_code_str = paste0(r_code_str, paste0(" # Options ignored: ", options_str))
  }


  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_append.R

!CHANGE_FILE R/t_collapse.R
```R
# Translate Stata 'collapse' command
# Stata: collapse (stat) varlist [name=expr ...] [weight] [if] [in] [, options]
# Often: collapse (stat) varlist, by(groupvars)

t_collapse = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_collapse")
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Split into aggregate definitions part and options part
  # Pattern: ^\s*(.*?)(?:,\\s*(.*))?$
  # G1: aggregate_part, G2: options_part
  parts = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(.*?)(?:,\\s*(.*))?$")
  aggregate_part = stringi::stri_trim_both(parts[1,2])
  options_part = stringi::stri_trim_both(parts[1,3]) # NA if no options

  # Separate potential if/in from aggregate definitions
  stata_if_in_cond = NA_character_
  # Look for `if` or `in` immediately followed by a space in the part before the first comma
  if_in_match = stringi::stri_match_first_regex(aggregate_part, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      # Remove the if/in part from aggregate_part
      aggregate_part = stringi::stri_replace_last_regex(aggregate_part, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      aggregate_part = stringi::stri_trim_both(aggregate_part)
  }


  # Parse aggregate definitions: "(stat) var [name=expr ...] (stat) var [name=expr ...] ..."
  # Updated regex to correctly capture expressions for source and target variables.
  # Group 1: stat name (e.g., mean, sum)
  # Group 2: target variable name (e.g., i, total_i_sum)
  # Group 3: source expression (e.g., i, i+1) - optional, for `name=expr` syntax
  # Changed (?:\\s*=\\s*(.*?))? to (?:\\s*=\\s*([^,]+))? for more robust capture of expressions.
  aggregate_matches = stringi::stri_match_all_regex(aggregate_part, "\\(([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*([a-zA-Z_][a-zA-Z0-9_.]*)(?:\\s*=\\s*([^,]+))?")[[1]]

  if (NROW(aggregate_matches) == 0) {
    return(paste0("# Failed to parse collapse aggregate definitions: ", aggregate_part))
  }

  # Parse options part for `by()`
  by_vars_list_unquoted = character(0)
  if (!is.na(options_part)) {
    by_opt_match = stringi::stri_match_first_regex(options_part, "\\bby\\s*\\(([^)]+)\\)")
    if (!is.na(by_opt_match[1,1])) {
      by_vars_collapse_str = stringi::stri_trim_both(by_opt_match[1,2])
      by_vars_list_unquoted = stringi::stri_split_regex(by_vars_collapse_str, "\\s+")[[1]]
      by_vars_list_unquoted = by_vars_list_unquoted[by_vars_list_unquoted != ""]
    }
  }

  # Translate the if/in condition for subsetting *before* collapse
  r_code_lines = c()
  data_source_for_collapse = "data"

  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, cmd_obj$line, cmd_df, context = list(is_by_group = FALSE))
      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for collapse: ", stata_if_in_cond))
      }
      # Using collapse::fsubset. r_subset_cond is a string representing the logical condition.
      r_code_lines = c(r_code_lines, paste0("data = collapse::fsubset(data, ", r_subset_cond, ")"))
      # data_source_for_collapse remains "data" as it's modified in place by fsubset
  }


  # Build the fsummarise expressions
  aggregate_exprs = character(NROW(aggregate_matches))
  new_vars_created = character(NROW(aggregate_matches))
  for (j in 1:NROW(aggregate_matches)) {
    stat_from_regex = aggregate_matches[j, 2] # Group 1: stat name
    actual_stata_target_var_name = stringi::stri_trim_both(aggregate_matches[j, 3]) # Group 2: target var name
    actual_stata_source_expr = stringi::stri_trim_both(aggregate_matches[j, 4]) # Group 3: source expression (optional)

    if (is.na(actual_stata_source_expr) || actual_stata_source_expr == "") {
      # If no explicit source expression (e.g., `(mean) myvar`), the source is the target var itself
      actual_stata_source_expr = actual_stata_target_var_name
    }
    
    new_vars_created[j] = actual_stata_target_var_name

    r_source_expr_translated = translate_stata_expression_with_r_values(actual_stata_source_expr, cmd_obj$line, cmd_df, context)
     if (is.na(r_source_expr_translated) || r_source_expr_translated == "") {
         return(paste0("# Failed to translate source expression '", actual_stata_source_expr, "' for collapse stat '", stat_from_regex, "'"))
     }

    # Map Stata stats to collapse functions
    collapse_func_expr = switch(stat_from_regex,
      "mean" = paste0("collapse::fmean(", r_source_expr_translated, ", na.rm = TRUE)"),
      "sum" = paste0("collapse::fsum(", r_source_expr_translated, ", na.rm = TRUE)"),
      "count" = paste0("collapse::fN(", r_source_expr_translated, ", non.na = TRUE)"), # Counts non-missing values of var/expr
      "N" = "NROW(.)", # N is number of observations in group. NROW(.) in fsummarise.
      "first" = paste0("collapse::ffirst(", r_source_expr_translated, ")"), # na.rm = TRUE by default
      "last" = paste0("collapse::flast(", r_source_expr_translated, ")"),   # na.rm = TRUE by default
      "min" = paste0("collapse::fmin(", r_source_expr_translated, ", na.rm = TRUE)"),
      "max" = paste0("collapse::fmax(", r_source_expr_translated, ", na.rm = TRUE)"),
      "median" = paste0("collapse::fmedian(", r_source_expr_translated, ", na.rm = TRUE)"),
      "sd" = paste0("collapse::fsd(", r_source_expr_translated, ", na.rm = TRUE)"),
      "p1" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.01, na.rm = TRUE)"),
      "p5" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.05, na.rm = TRUE)"),
      "p10" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.10, na.rm = TRUE)"),
      "p25" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.01, na.rm = TRUE)"),
      "p75" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.75, na.rm = TRUE)"),
      "p90" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.90, na.rm = TRUE)"),
      "p95" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.95, na.rm = TRUE)"),
      "p99" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.99, na.rm = TRUE)"),
      NULL
    )

    if (is.null(collapse_func_expr)) {
        return(paste0("# Collapse stat '", stat_from_regex, "' not yet implemented for collapse package translation."))
    }

    r_new_var_name = actual_stata_target_var_name
    aggregate_exprs[j] = paste0("`",r_new_var_name, "` = ", collapse_func_expr) # Backticks for safety
  }

  aggregate_exprs_str = paste(aggregate_exprs, collapse = ",\n  ")

  # Build the main data manipulation pipe using collapse
  main_pipe_parts = c("data")
  if (length(by_vars_list_unquoted) > 0) {
    by_vars_fgroup_by_str = paste(by_vars_list_unquoted, collapse = ", ")
    main_pipe_parts = c(main_pipe_parts,
                       paste0("collapse::fgroup_by(", by_vars_fgroup_by_str, ")"))
  }

  main_pipe_parts = c(main_pipe_parts,
                     paste0("collapse::fsummarise(", aggregate_exprs_str, ")"))

  if (length(by_vars_list_unquoted) > 0) {
    main_pipe_parts = c(main_pipe_parts, "collapse::fungroup()")
  }

  # Construct the R code line for data assignment
  # Need to handle if data was already subsetted using `r_code_lines`
  if (length(r_code_lines) > 0) { # This means data = collapse::fsubset(...) was already added
     # The pipe starts from the result of fsubset, which is already assigned to 'data'
     r_code_lines = c(r_code_lines, paste0("data = ", paste(main_pipe_parts, collapse = " %>% \n  ")))
  } else {
     # Pipe starts from original 'data'
     r_code_lines = c(r_code_lines, paste0("data = ", paste(main_pipe_parts, collapse = " %>% \n  ")))
  }


  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about options if any were present but not handled (excluding by)
  options_str_cleaned = options_part
  if (!is.na(options_str_cleaned)) {
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bby\\s*\\([^)]+\\)", "")
      options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
      options_str_cleaned = stringi::stri_trim_both(options_str_cleaned)
  }

  if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
       r_code_str = paste0(r_code_str, paste0("\n# Other options ignored: ", options_str_cleaned))
  }

  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_collapse.R

!CHANGE_FILE R/t_decode.R
```R
# Translate Stata 'decode' command
# Stata: decode varname [if] [in] , gen(newvar) [options]
# Converts numeric varname with value labels into string newvar.

t_decode = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_decode") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varname, if/in, options (especially gen())
  # Pattern: `varname [if] [in] , options`

  varname_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Find if/in first
  if_in_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rest_no_if_in = stringi::stri_replace_last_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rest_no_if_in = stringi::stri_trim_both(rest_no_if_in)
  } else {
      rest_no_if_in = rest_of_cmd_trimmed
  }

   # Find options
  options_match = stringi::stri_match_first_regex(rest_no_if_in, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      varname_str = stringi::stri_replace_last_regex(rest_no_if_in, ",\\s*(.*)$", "")
      varname_str = stringi::stri_trim_both(varname_str)
  } else {
      # This case implies `decode varname` without `, gen(newvar)` which is invalid for decode.
      # Stata syntax is `decode varname, gen(newvar)`. The comma is mandatory before options.
      # So, if no comma, there are no options, and thus no gen().
      # This means `gen_var` will be NA, and the error will be thrown later.
      return(paste0("# decode command requires gen() in options: ", rest_of_cmd))
  }

   if (is.na(varname_str) || varname_str == "") {
       return(paste0("# decode command requires varname: ", rest_of_cmd))
   }

  # Parse options, specifically `gen()`
  gen_var = NA_character_
  if (!is.na(options_str)) {
      # Modified regex to accept 'gen' or 'generate'
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\b(?:gen|generate)\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars_str = stringi::stri_trim_both(gen_opt_match[1,2])
           gen_vars_list = stringi::stri_split_regex(gen_vars_str, "\\s+")[[1]]
           gen_var = gen_vars_list[1] # decode generates a single variable
       }
  }

  if (is.na(gen_var)) {
      return(paste0("# decode requires gen() option: ", rest_of_cmd))
  }

  # Translate if/in condition
  r_if_in_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
       # Context for if/in is global, not by_group specific for resolution, but _n/_N can be tricky
       r_if_in_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group=FALSE))
       if (is.na(r_if_in_cond) || r_if_in_cond == "") {
           return(paste0("# Failed to translate if/in condition for decode: ", stata_if_in_cond))
       }
  }

  # Temporary variable names
  decoded_values_tmp_var = paste0("stata_tmp_decoded_values_L", cmd_obj$line)
  satisfies_cond_tmp_var = paste0("stata_tmp_satisfies_cond_L", cmd_obj$line)
  original_values_tmp_var = paste0("stata_tmp_original_values_L", cmd_obj$line) # Added for robustness

   r_code_lines = c(
      paste0("data = dplyr::mutate(data, `", gen_var, "` = NA_character_)")
   )

   r_code_lines = c(r_code_lines,
      paste0("## Decode values using haven::as_factor"),
      paste0(original_values_tmp_var, " = with(data, data$`", varname_str, "`)"), # Store original values
      # Calculate decoded values. haven::as_factor converts unlabelled values to NA.
      # Corrected: removed `levels = 'labels'`
      paste0(decoded_values_tmp_var, " = as.character(haven::as_factor(", original_values_tmp_var, "))"),
      # Stata's decode for unlabelled numeric values converts them to their string representation.
      # And missing values (NA) are converted to empty string "".
      paste0(decoded_values_tmp_var, " = dplyr::if_else(is.na(", decoded_values_tmp_var, "), ",
                                    "dplyr::if_else(is.na(", original_values_tmp_var, "), \"\", as.character(", original_values_tmp_var, ")), ",
                                    decoded_values_tmp_var, ")")
   )

  # Apply the if/in condition for replacement
  if (!is.na(r_if_in_cond) && r_if_in_cond != "") {
       r_code_lines = c(r_code_lines,
           paste0("## Calculate condition flag using with(data, ...)"),
           paste0(satisfies_cond_tmp_var, " = with(data, ", r_if_in_cond, ")"),
           paste0("data = dplyr::mutate(data, `", gen_var, "` = dplyr::if_else(", satisfies_cond_tmp_var, ", ", decoded_values_tmp_var, ", `", gen_var, "`))"),
           paste0("rm(", satisfies_cond_tmp_var, ")")
       )
  } else {
      r_code_lines = c(r_code_lines,
           paste0("data = dplyr::mutate(data, `", gen_var, "` = ", decoded_values_tmp_var, ")")
      )
  }

  r_code_lines = c(r_code_lines, paste0("rm(", decoded_values_tmp_var, ", ", original_values_tmp_var, ")"))

  r_code_str = paste(r_code_lines, collapse="\n")

   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\b(?:gen|generate)\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }

  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_decode.R

!CHANGE_FILE R/t_destring.R
```R
# Translate Stata 'destring' command
# Stata: destring varlist [if] [in] , {generate(newvarlist) | replace} [options]
# Converts string variables into numeric variables.

t_destring = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_destring") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varlist, if/in, options (generate() or replace)
  # Pattern: `varlist [if] [in] , options`

  varlist_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Find if/in first
  if_in_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rest_no_if_in = stringi::stri_replace_last_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rest_no_if_in = stringi::stri_trim_both(rest_no_if_in)
  } else {
      rest_no_if_in = rest_of_cmd_trimmed
  }

   # Find options (required)
  options_match = stringi::stri_match_first_regex(rest_no_if_in, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      varlist_str = stringi::stri_replace_last_regex(rest_no_if_in, ",\\s*(.*)$", "")
      varlist_str = stringi::stri_trim_both(varlist_str)
  } else {
      return(paste0("# destring command requires options (, gen() or , replace): ", rest_of_cmd))
  }

   if (is.na(varlist_str) || varlist_str == "") {
       return(paste0("# destring command requires varlist: ", rest_of_cmd))
   }

  vars_to_destring = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_destring = vars_to_destring[vars_to_destring != ""]
   if (length(vars_to_destring) == 0) {
       return(paste0("# destring command requires non-empty varlist: ", rest_of_cmd))
   }


  # Parse options, specifically `generate()` or `replace`
  is_replace = stringi::stri_detect_fixed(options_str, "replace")
  gen_vars = NA_character_
  if (!is_replace) {
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgenerate\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars = stringi::stri_trim_both(gen_opt_match[1,2])
       }
  }

  new_vars = NULL
  if (!is_replace) {
      if (is.na(gen_vars)) {
           return(paste0("# destring requires generate() option or replace option: ", rest_of_cmd))
      }
      new_vars = stringi::stri_split_regex(gen_vars, "\\s+")[[1]]
      new_vars = new_vars[new_vars != ""]
      if (length(new_vars) != length(vars_to_destring)) {
          return(paste0("# destring generate() option requires same number of new variables as old variables."))
      }
  } else {
      # If replace option, new vars are the same as old vars.
      new_vars = vars_to_destring
  }


  # Translate if/in condition
  r_if_in_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
       r_if_in_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group=FALSE))
       if (is.na(r_if_in_cond) || r_if_in_cond == "") {
           return(paste0("# Failed to translate if/in condition for destring: ", stata_if_in_cond))
       }
  }

  # R equivalent: readr::parse_number() or as.numeric()
  # readr::parse_number is better at handling non-numeric parts and commas/$, results in NA on failure.
  # as.numeric() often results in warnings/errors or NA on failure.
  # Stata destring option `ignore()` can specify characters to ignore. `force` allows unconvertible values to become missing.
  # `readr::parse_number` handles some of this.

  mutate_exprs = character(length(vars_to_destring))
  for (k in seq_along(vars_to_destring)) {
      old_var = vars_to_destring[k]
      new_var = new_vars[k]
      source_var_r = old_var # R variable name for the source column

      # Calculate destrung values
      # Using readr::parse_number
      destrung_value_expr = paste0("readr::parse_number(as.character(", source_var_r, "))")
      # as.character needed in case the variable is factor/labelled etc.

      # Apply the if/in condition for replacement
      if (!is.na(r_if_in_cond) && r_if_in_cond != "") {
          # For rows meeting condition, use destrung value. Otherwise, keep original (or NA if new var).
           if (is_replace) {
               # Replace in place: use destrung if condition, old value otherwise
               final_value_expr = paste0("dplyr::if_else(dplyr::coalesce(", r_if_in_cond, ", FALSE), ", destrung_value_expr, ", `", source_var_r, "`)")
           } else {
               # Generate new var: use destrung if condition, NA otherwise
               final_value_expr = paste0("dplyr::if_else(dplyr::coalesce(", r_if_in_cond, ", FALSE), ", destrung_value_expr, ", NA_real_)") # Assuming numeric result
           }
      } else {
          # Apply to all rows
           final_value_expr = destrung_value_expr
      }

      mutate_exprs[k] = paste0("`", new_var, "` = ", final_value_expr)
  }

   # Combine mutate expressions
  mutate_exprs_str = paste(mutate_exprs, collapse = ",\n  ")

  # Build the final R code using dplyr::mutate
  r_code_lines = c(paste0("data = dplyr::mutate(data, ", mutate_exprs_str, ")")) # Changed to dplyr::mutate


  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about options if any were present but not handled (excluding generate/replace)
   options_str_cleaned = options_str
   # Remove generate() or replace from options string
   if (is_replace) {
       options_str_cleaned = stringi::stri_replace_first_fixed(options_str_cleaned, "replace", "")
   } else {
       options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bgenerate\\s*\\([^)]+\\)", "")
   }
   options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ",")) # Clean up multiple commas
   options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma


   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }


  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_destring.R

!CHANGE_FILE R/t_duplicates.R
```R
# Translate Stata 'duplicates' command
# Stata: duplicates drop [varlist] [if] [in] [, options]
# Stata: duplicates tag varlist [if] [in] [, options] gen(newvar)
# Stata: duplicates list [varlist] [if] [in] [, options]

t_duplicates = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_duplicates") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse subcommand (drop, tag, list)
  parts_subcmd = stringi::stri_split_regex(rest_of_cmd_trimmed, "\\s+", n=2)[[1]]
  subcommand = stringi::stri_trim_both(parts_subcmd[1])
  rest_after_subcmd = if(length(parts_subcmd) > 1) stringi::stri_trim_both(parts_subcmd[2]) else NA_character_

  if (is.na(subcommand) || !(subcommand %in% c("drop", "tag", "list"))) {
      return(paste0("# Failed to parse duplicates subcommand (drop, tag, or list required): ", rest_of_cmd))
  }

  varlist_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  if(!is.na(rest_after_subcmd)){
    if_in_match = stringi::stri_match_first_regex(rest_after_subcmd, "\\s+(?:if\\s+|in\\s+)(.*)$")
    if(!is.na(if_in_match[1,1])) {
        stata_if_in_cond = if_in_match[1,2]
        rest_after_subcmd_no_if_in = stringi::stri_replace_last_regex(rest_after_subcmd, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
        rest_after_subcmd_no_if_in = stringi::stri_trim_both(rest_after_subcmd_no_if_in)
    } else {
        rest_after_subcmd_no_if_in = rest_after_subcmd
    }

    options_match = stringi::stri_match_first_regex(rest_after_subcmd_no_if_in, ",\\s*(.*)$")
    if (!is.na(options_match[1,1])) {
        options_str = stringi::stri_trim_both(options_match[1,2])
        varlist_str = stringi::stri_replace_last_regex(rest_after_subcmd_no_if_in, ",\\s*(.*)$", "")
        varlist_str = stringi::stri_trim_both(varlist_str)
    } else {
        varlist_str = rest_after_subcmd_no_if_in
    }
  }

  vars_for_duplicates = NA_character_
  if (!is.na(varlist_str) && varlist_str != "") {
      vars_for_duplicates_list = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
      vars_for_duplicates_list = vars_for_duplicates_list[vars_for_duplicates_list != ""]
       if (length(vars_for_duplicates_list) > 0) {
           vars_for_duplicates = paste0('c("', paste(vars_for_duplicates_list, collapse = '", "'), '")')
       }
  }

  r_subset_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for duplicates: ", stata_if_in_cond))
      }
  }

  r_code_lines = c()
  # Temporary variable names
  is_duplicate_tmp_var = paste0("stata_tmp_is_duplicate_L", cmd_obj$line)
  satisfies_cond_tmp_var = paste0("stata_tmp_satisfies_cond_L", cmd_obj$line)
  is_first_tmp_var = paste0("stata_tmp_is_first_L", cmd_obj$line)
  data_duplicates_tmp_var = paste0("stata_tmp_data_duplicates_L", cmd_obj$line)


  if (subcommand == "drop") {
      # For filter, NA in condition is treated as FALSE, which matches Stata's behavior.
      cond_vector_expr_with_data = if (!is.na(r_subset_cond) && r_subset_cond != "") paste0("with(data, ", r_subset_cond, ")") else "TRUE"

      comment_vars_part = if(is.na(vars_for_duplicates)) "all variables" else paste0("variables: ", varlist_str)
      if (is.na(vars_for_duplicates)) {
          is_duplicate_expr = "base::duplicated(data, fromLast = FALSE)"
      } else {
           is_duplicate_expr = paste0("base::duplicated(data[, ", vars_for_duplicates, ", drop = FALSE], fromLast = FALSE)")
      }

      r_code_lines = c(
          r_code_lines,
          paste0("## Calculate duplicate flag based on ", comment_vars_part),
          paste0(is_duplicate_tmp_var, " = ", is_duplicate_expr),
          paste0("## Calculate condition flag"),
          paste0(satisfies_cond_tmp_var, " = ", cond_vector_expr_with_data),
          paste0("data = dplyr::filter(data, !(stata_tmp_is_duplicate_L", cmd_obj$line, " & stata_tmp_satisfies_cond_L", cmd_obj$line, "))"),
          paste0("rm(", is_duplicate_tmp_var, ", ", satisfies_cond_tmp_var, ")")
      )

  } else if (subcommand == "tag") {
      gen_var = NA_character_
      if (!is.na(options_str)) {
         gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgen\\s*\\(([^)]+)\\)")
         if (!is.na(gen_opt_match[1,1])) {
             gen_vars_str = stringi::stri_trim_both(gen_opt_match[1,2])
             gen_vars_list = stringi::stri_split_regex(gen_vars_str, "\\s+")[[1]]
             gen_var = gen_vars_list[1]
         }
      }

      if (is.na(gen_var)) {
          return(paste0("# duplicates tag requires gen() option: ", rest_of_cmd))
      }

      # Stata `if` condition treats missing as false.
      cond_vector_expr_with_data = if (!is.na(r_subset_cond) && r_subset_cond != "") paste0("dplyr::coalesce(with(data, ", r_subset_cond, "), FALSE)") else "TRUE"
      comment_vars_part = if(is.na(vars_for_duplicates)) "all variables" else paste0("variables: ", varlist_str)

       if (is.na(vars_for_duplicates)) {
          is_first_occurrence_expr = "!base::duplicated(data, fromLast = FALSE)"
      } else {
           is_first_occurrence_expr = paste0("!base::duplicated(data[, ", vars_for_duplicates, ", drop = FALSE], fromLast = FALSE)")
      }

       r_code_lines = c(
          r_code_lines,
          paste0("## Calculate first occurrence flag based on ", comment_vars_part),
          paste0(is_first_tmp_var, " = ", is_first_occurrence_expr),
          paste0("## Calculate condition flag, treating NA as FALSE"),
          paste0(satisfies_cond_tmp_var, " = ", cond_vector_expr_with_data),
          # The if_else condition itself must treat any NA as FALSE for Stata compatibility.
          paste0("data = dplyr::mutate(data, `", gen_var, "` = dplyr::if_else(dplyr::coalesce(", is_first_tmp_var, ", FALSE) & ", satisfies_cond_tmp_var, ", 1, 0))"),
          paste0("rm(", is_first_tmp_var, ", ", satisfies_cond_tmp_var, ")")
       )

  } else if (subcommand == "list") {
       # For filter, NA in condition is treated as FALSE, which matches Stata's behavior.
       cond_vector_expr_with_data = if (!is.na(r_subset_cond) && r_subset_cond != "") paste0("with(data, ", r_subset_cond, ")") else "TRUE"
       comment_vars_part = if(is.na(vars_for_duplicates)) "all variables" else paste0("variables: ", varlist_str)

        if (is.na(vars_for_duplicates)) {
          is_duplicate_expr = "base::duplicated(data, fromLast = FALSE)"
      } else {
           is_duplicate_expr = paste0("base::duplicated(data[, ", vars_for_duplicates, ", drop = FALSE], fromLast = FALSE)")
      }

       r_code_lines = c(
          r_code_lines,
          paste0("## Calculate duplicate flag based on ", comment_vars_part),
          paste0(is_duplicate_tmp_var, " = ", is_duplicate_expr),
          paste0("## Calculate condition flag"),
          paste0(satisfies_cond_tmp_var, " = ", cond_vector_expr_with_data),
          paste0(data_duplicates_tmp_var, " = dplyr::filter(data, ", is_duplicate_tmp_var, " & ", satisfies_cond_tmp_var, ")"),
          paste0("print(", data_duplicates_tmp_var, ")"),
          paste0("rm(", is_duplicate_tmp_var, ", ", satisfies_cond_tmp_var, ", ", data_duplicates_tmp_var, ")")
       )

  } else {
      r_code_lines = c(r_code_lines, paste0("# Unknown duplicates subcommand: ", subcommand))
  }

  r_code_str = paste(r_code_lines, collapse="\n")

   options_str_cleaned = options_str
   if (subcommand == "tag" && !is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bgen\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }

  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_duplicates.R

!CHANGE_FILE R/t_egen.R
```R
t_egen = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_egen")
  # Basic parsing: newvar = function(args) [, by(groupvars)] [if condition]
  # Example: egen mean_i_grp = mean(i), by(group)
  # Example: egen total_i = total(i)
  # Example: bysort group: egen rank_i = rank(i) (Note: bysort handled by cmd_obj$is_by_prefix)

  # Remove type prefix if any (byte, int, long, float, double, str#, etc.)
  # Pattern: ^\s*(byte|int|long|float|double|str\\d+)\\s+
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^\\s*(?:byte|int|long|float|double|str\\d+|strL)\\s+", "")

  # Re-parse rest_of_cmd_no_type looking for `newvar = fcn(args) [if cond] [, options]`
  # Split at the first `=`. Left is `newvar`. Right is `fcn(args) [if cond] [, options]`
  parts_eq = stringi::stri_split_fixed(rest_of_cmd_no_type, "=", n=2)[[1]]
  if(length(parts_eq) != 2) return(paste0("# Failed to parse egen command structure (no =): ", rest_of_cmd))

  new_var = stringi::stri_trim_both(parts_eq[1])
  right_part = stringi::stri_trim_both(parts_eq[2])

  # Split right_part at the first comma (if any) to separate function/args/if from options
  parts_comma_list = stringi::stri_split_fixed(right_part, ",", n=2)
  parts_comma = parts_comma_list[[1]]

  if(length(parts_comma) != 2) {
    func_args_if_part = stringi::stri_trim_both(parts_comma[1])
    options_str = NA_character_
  } else {
    func_args_if_part = stringi::stri_trim_both(parts_comma[1])
    options_str = stringi::stri_trim_both(parts_comma[2])
  }


  # Now parse func_args_if_part: `fcn(args) [if cond]`
  # Split at the first `(`
  parts_paren = stringi::stri_split_fixed(func_args_if_part, "(", n=2)[[1]]
  if(length(parts_paren) != 2) return(paste0("# Failed to parse egen function call: ", func_args_if_part))

  egen_func_name = stringi::stri_trim_both(parts_paren[1])
  args_and_if_part = stringi::stri_trim_both(stringi::stri_replace_last_fixed(parts_paren[2], ")", "")) # Remove trailing ')'

  # Now parse args_and_if_part: `args [if cond]` or `args [in range]`
  stata_if_cond_in_args = NA_character_
  stata_in_range_in_args = NA_character_
  egen_args_str = args_and_if_part

  # Look for `if` first
  if_match_in_args = stringi::stri_match_first_regex(egen_args_str, "\\s+if\\s+(.*)$")
   if(!is.na(if_match_in_args[1,1])) {
      stata_if_cond_in_args = if_match_in_args[1,2]
      egen_args_str = stringi::stri_replace_last_regex(egen_args_str, "\\s+if\\s+(.*)$", "")
      egen_args_str = stringi::stri_trim_both(egen_args_str)
   }

  # Check for `in`
  in_match_in_args = stringi::stri_match_first_regex(egen_args_str, "\\s+in\\s+(.*)$")
   if(!is.na(in_match_in_args[1,1])) {
      stata_in_range_in_args = if_match_in_args[1,2]
      egen_args_str = stringi::stri_replace_last_regex(egen_args_str, "\\s+in\\s+(.*)$", "")
      egen_args_str = stringi::stri_trim_both(egen_args_str)
   }

  # Now we have: new_var, egen_func_name, egen_args_str, stata_if_cond_in_args, stata_in_range_in_args, options_str

  # Translate the condition/range if it exists
  r_if_cond_in_args = NA_character_
  if (!is.na(stata_if_cond_in_args) && stata_if_cond_in_args != "") {
       # Context for _n/_N in the if condition within egen args is usually the group context (if by_prefix used)
      r_if_cond_in_args = translate_stata_expression_with_r_values(stata_if_cond_in_args, line_num, cmd_df, context)
       if (is.na(r_if_cond_in_args) || r_if_cond_in_args == "") {
           return(paste0("# Failed to translate if condition in egen args: ", stata_if_cond_in_args))
       }
  }

   r_in_range_cond_in_args = NA_character_
  if (!is.na(stata_in_range_in_args) && stata_in_range_in_args != "") {
       # Context for _n/_N etc. in range is group context if by_prefix used.
       # Stata `in f/l` in egen refers to observation numbers *within the group* if bysort prefix is used.
       # Otherwise, it refers to global observation numbers.
       # The `context$is_by_group` flag from parse_stata_command_line indicates bysort prefix.
       range_match = stringi::stri_match_first_regex(stata_in_range_in_args, "^(\\d+)(?:/(\\d+))?$")
        if (!is.na(range_match[1,1])) {
            start_row = as.integer(range_match[1,2])
            end_row = range_match[1,3]
            # Use dplyr::row_number(), as stata_expression_translator will handle _n
            row_number_r_expr = "as.numeric(dplyr::row_number())" # This will be translated based on context

            if (is.na(end_row)) {
                 r_in_range_cond_in_args = paste0(row_number_r_expr, " == ", start_row)
            } else {
                 r_in_range_cond_in_args = paste0(row_number_r_expr, " >= ", start_row, " & ", row_number_r_expr, " <= ", as.integer(end_row))
            }
        } else {
            return(paste0("# egen in range '", stata_in_range_in_args, "' not fully translated (f/l specifiers)."))
        }
  }


  # Combine if and in conditions within args if both exist
  final_r_subset_cond_in_args = NA_character_
  if (!is.na(r_if_cond_in_args) && !is.na(r_in_range_cond_in_args)) {
      final_r_subset_cond_in_args = paste0("(", r_if_cond_in_args, ") & (", r_in_range_cond_in_args, ")")
  } else if (!is.na(r_if_cond_in_args)) {
      final_r_subset_cond_in_args = r_if_cond_in_args
  } else if (!is.na(r_in_range_cond_in_args)) {
      final_r_subset_cond_in_args = r_in_range_cond_in_args
  }


  # Translate arguments (usually variable names)
  # Context for _n/_N etc. in arguments is the group context if by_prefix is used.
  r_egen_args = translate_stata_expression_with_r_values(egen_args_str, line_num, cmd_df, context)
   if (is.na(r_egen_args) || r_egen_args == "") {
        # This might be ok if the function takes no arguments e.g. egen group_id = group()
        if (egen_func_name != "group") { # group() takes implicit args from by() or option
             warning(paste0("Failed to translate egen arguments: ", egen_args_str))
        }
   }


  # Apply if/in condition within the function call if needed
  # Example: mean(x if y>0) -> mean(ifelse(y>0, x, NA), na.rm = TRUE)
  # This requires modifying r_egen_args based on final_r_subset_cond_in_args
  if (!is.na(final_r_subset_cond_in_args) && final_r_subset_cond_in_args != "") {
      # Stata's `if` condition treats NA as FALSE.
      r_egen_args_conditional = paste0("dplyr::if_else(dplyr::coalesce(", final_r_subset_cond_in_args, ", FALSE), ", r_egen_args, ", NA)")
  } else {
      r_egen_args_conditional = r_egen_args
  }

  # Determine if 'fieldstrustmissings' option is present
  is_fieldstrustmissings = !is.na(options_str) && stringi::stri_detect_fixed(options_str, "fieldstrustmissings")


  # Translate egen function into an R expression for calculation
  calc_expr = ""
  is_row_function = FALSE # Flag for functions like rowtotal, rowmean that don't use group_by

  # Switch for egen functions
  if (egen_func_name == "mean") {
    calc_expr = paste0("mean(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "total" || egen_func_name == "sum") {
    calc_expr = paste0("sum(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "count") {
    # count(exp) counts non-missing results of exp. If exp is varname, sum(!is.na(varname)).
    # If exp is complex, sum(eval(parse(text=r_egen_args_conditional)) != 0 & !is.na(eval(parse(text=r_egen_args_conditional))))
    # Assuming r_egen_args_conditional results in a numeric or logical vector
    calc_expr = paste0("sum(!is.na(", r_egen_args_conditional, "))")
  } else if (egen_func_name == "rank") {
    # Stata rank() without fieldstrustmissings returns missing for missing.
    # Stata rank() with fieldstrustmissings treats missing values as true values (usually largest) and assigns them a rank.
    # Stata's rank() uses the 'average' method for ties.
    if (is_fieldstrustmissings) {
      # Replace NA values with Inf to rank them highest.
      # Note: r_egen_args_conditional already applies if/in conditions, yielding NA for rows not meeting condition.
      # These NAs should also be treated as largest for ranking due to fieldstrustmissings.
      val_for_ranking = paste0("as.numeric(dplyr::if_else(is.na(", r_egen_args_conditional, "), Inf, ", r_egen_args_conditional, "))")
      calc_expr = paste0("as.numeric(base::rank(", val_for_ranking, ", ties.method = 'average', na.last = 'keep'))")
    } else {
      # Default Stata rank: NAs get NA ranks, and uses 'average' method for ties.
      calc_expr = paste0("as.numeric(base::rank(", r_egen_args_conditional, ", ties.method = 'average', na.last = 'keep'))")
    }
  } else if (egen_func_name == "median" || egen_func_name == "p50") {
    calc_expr = paste0("stats::median(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "sd" || egen_func_name == "std") {
    calc_expr = paste0("stats::sd(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "group") {
    # dplyr::cur_group_id() gives integer for each group.
    calc_expr = paste0("dplyr::cur_group_id()")
  } else if (egen_func_name == "tag") {
    # Stata tag(varlist) creates 1 for first observation in a group (defined by varlist) and 0 otherwise.
    calc_expr = paste0("as.numeric(dplyr::row_number() == 1)")
  } else if (egen_func_name == "rowtotal") {
    vars_for_rowop_list = stringi::stri_split_regex(r_egen_args, "\\s+")[[1]] # Use non-conditional args here
    vars_for_rowop_list = vars_for_rowop_list[!is.na(vars_for_rowop_list) & vars_for_rowop_list != ""] # Filter empty/NA

    # Stata rowtotal treats NA as 0 *before* summing.
    # Replace NA with 0 in the selected columns before summing.
    cols_selection_expr = paste0("dplyr::select(dplyr::cur_data_all(), dplyr::all_of(c('", paste(vars_for_rowop_list, collapse="','"), "')))")
    calc_expr = paste0("base::rowSums(", cols_selection_expr, " %>% replace(is.na(.), 0), na.rm = FALSE)")
    is_row_function = TRUE
  } else if (egen_func_name == "rowmean") {
    vars_for_rowop_list = stringi::stri_split_regex(r_egen_args, "\\s+")[[1]] # Use non-conditional args here
    vars_for_rowop_list = vars_for_rowop_list[!is.na(vars_for_rowop_list) & vars_for_rowop_list != ""] # Filter empty/NA

    # Stata rowmean ignores NAs. base::rowMeans with na.rm = TRUE achieves this.
    cols_selection_expr = paste0("dplyr::select(dplyr::cur_data_all(), dplyr::all_of(c('", paste(vars_for_rowop_list, collapse="','"), "')))")
    calc_expr = paste0("base::rowMeans(", cols_selection_expr, ", na.rm = TRUE)")
    is_row_function = TRUE
  } else if (egen_func_name == "concat") {
    vars_to_concat_list = stringi::stri_split_regex(egen_args_str, "\\s+")[[1]]
    vars_to_concat_list = vars_to_concat_list[!is.na(vars_to_concat_list) & vars_to_concat_list != ""]

    if (length(vars_to_concat_list) == 0) {
      return(paste0("# egen concat() requires variables to concatenate."))
    }

    # Stata: If all variables in varlist are missing, newvar is missing. Otherwise, missing values are treated as empty strings.
    # Approach:
    # 1. Check if all input variables for a row are NA. If so, result is NA.
    # 2. Otherwise, for each variable, replace NA with "" and then concatenate.

    # Expression to check if all relevant variables in a row are NA.
    # Use data[['var_name']] for explicit column access.
    all_vars_na_check_list = paste0("is.na(data[['", vars_to_concat_list, "']])")
    all_vars_na_check_expr = paste0("(", paste0(all_vars_na_check_list, collapse = " & "), ")")

    # Arguments for stri_paste, with NAs replaced by empty strings
    stri_paste_args_with_na_empty = paste0("dplyr::if_else(is.na(as.character(data[['", vars_to_concat_list, "']])), \"\", as.character(data[['", vars_to_concat_list, "']]))", collapse = ", ")

    # Expression for the actual concatenation
    # Use na_empty = FALSE (default) because NAs are already handled.
    calc_expr = paste0("dplyr::if_else(", all_vars_na_check_expr, ", NA_character_, stringi::stri_paste(", stri_paste_args_with_na_empty, ", sep = ''))")

    is_row_function = TRUE # Concatenation is inherently row-wise.
  } else {
    return(paste0("# Egen function '", egen_func_name, "' not yet implemented."))
  }

  # Combine into a mutate statement
  full_mutate_expr = paste0("`", new_var, "` = ", calc_expr)


  # Determine actual grouping variables for dplyr::group_by
  group_vars_list_bare = character(0) # Will hold just bare variable names
  if (cmd_obj$is_by_prefix) {
    if (length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1])) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[!is.na(group_vars_list) & group_vars_list != ""]
      if (length(group_vars_list) > 0) {
        group_vars_list_bare = group_vars_list # Assign just the bare names
      }
    }
  } else if (!is.na(options_str)) {
    by_opt_match = stringi::stri_match_first_regex(options_str, "\\bby\\s*\\(([^)]+)\\)")
    if (!is.na(by_opt_match[1,1])) {
      group_vars_list_bare = stringi::stri_split_regex(stringi::stri_trim_both(by_opt_match[1,2]), "\\s+")[[1]]
      group_vars_list_bare = group_vars_list_bare[!is.na(group_vars_list_bare) & group_vars_list_bare != ""]
    }
  }

  # For 'group' and 'tag' functions, the arguments also define the grouping
  if (egen_func_name %in% c("group", "tag")) {
    egen_func_args_list = stringi::stri_split_regex(egen_args_str, "\\s+")[[1]]
    egen_func_args_list = egen_func_args_list[!is.na(egen_func_args_list) & egen_func_args_list != ""]
    # Union of `by` variables and `egen` function arguments defines the group
    group_vars_list_bare = unique(c(group_vars_list_bare, egen_func_args_list))
  }


  # Determine variables for initial sorting (for `bysort` logic or for functions requiring internal sort)
  sort_vars_for_arrange = character(0)

  if (cmd_obj$is_by_prefix) {
    # Stata's `bysort` sorts by all variables in `varlist` (group + sort). This sort is permanent.
    sort_vars_for_arrange = unique(c(group_vars_list_bare, cmd_obj$by_sort_vars))
    sort_vars_for_arrange = sort_vars_for_arrange[!is.na(sort_vars_for_arrange) & sort_vars_for_arrange != ""]
  } else if (egen_func_name %in% c("rank", "group", "tag")) {
    # If not by-prefix, but it's a function sensitive to order (rank, group, tag)
    # The sort is temporary, so we will restore original order later.
    if (length(group_vars_list_bare) > 0) {
      sort_vars_for_arrange = unique(c(sort_vars_for_arrange, group_vars_list_bare))
    }
    if (egen_func_name == "rank" && !is.na(egen_args_str) && egen_args_str != "") {
      # For rank, the variable being ranked also affects the internal order for ties.
      # It's typically sorted by grouping vars, then the ranked var.
      # `egen_args_str` for rank is the variable to rank.
      sort_vars_for_arrange = unique(c(sort_vars_for_arrange, egen_args_str))
    }
    sort_vars_for_arrange = sort_vars_for_arrange[!is.na(sort_vars_for_arrange) & sort_vars_for_arrange != ""]
  }

  r_code_lines = c()
  pipe_elements = list("data") # Start the pipe with the data object

  # Add initial arrange if it's a `bysort` prefix. This is a permanent sort.
  if (cmd_obj$is_by_prefix && length(sort_vars_for_arrange) > 0) {
      arrange_vars_expr = paste0('!!!dplyr::syms(c("', paste0(sort_vars_for_arrange, collapse = '", "'), '"))')
      r_code_lines = c(r_code_lines, paste0("data = dplyr::arrange(data, ", arrange_vars_expr, ")"))
  }

  # Add arrange for `egen group/tag/rank` functions within the pipe, if not already handled by bysort prefix
  if (!cmd_obj$is_by_prefix && length(sort_vars_for_arrange) > 0 && !is_row_function) {
    pipe_elements = c(pipe_elements, "dplyr::arrange(stata2r_original_order_idx)")
  }


  # Add grouping and mutate steps
  if (length(group_vars_list_bare) > 0 && !is_row_function) {
    group_by_expr = paste0('dplyr::group_by(!!!dplyr::syms(c("', paste0(group_vars_list_bare, collapse='", "'), '")))')
    pipe_elements = c(pipe_elements, group_by_expr)
  }

  pipe_elements = c(pipe_elements, paste0("dplyr::mutate(", full_mutate_expr, ")"))

  if (length(group_vars_list_bare) > 0 && !is_row_function) {
    pipe_elements = c(pipe_elements, "dplyr::ungroup()")
  }

  # Restore original order if it was a temporary sort for egen functions without bysort prefix
  # This section is now handled by the `arrange` added *before* the grouping, if `!is_row_function`.
  # For row functions, no sort is needed for the calculation, so no re-arrange needed.
  # If a temporary sort was explicitly added (e.g., for `rank`, `group`, `tag`), and it was not a bysort prefix,
  # the `arrange(stata2r_original_order_idx)` will restore the order.
  # The logic for `arrange` within the pipe for `!is_row_function` and `!cmd_obj$is_by_prefix` already handles this.
  # No extra `dplyr::arrange(stata2r_original_order_idx)` needed here.


  r_code_lines = c(r_code_lines, paste0("data = ", paste(pipe_elements, collapse = " %>% \n  ")))

   # Add comment about options if any were present but not handled (excluding by)
   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bby\\s*\\([^)]+\\)", "")
        # Remove fieldstrustmissings from the options string if it was present
        options_str_cleaned = stringi::stri_replace_first_fixed(options_str_cleaned, "fieldstrustmissings", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ",")) # Clean up multiple commas
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_lines = c(r_code_lines, paste0(" # Other options ignored: ", options_str_cleaned))
   }


  return(paste(r_code_lines, collapse="\n"))
}
```
!END_CHANGE_FILE R/t_egen.R

!CHANGE_FILE R/t_encode.R
```R
# Translate Stata 'encode' command
# Stata: encode varname [if] [in] , gen(newvar) [options]
# Converts string varname into numeric newvar with value labels.

t_encode = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_encode")
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varname, if/in, options (especially gen())
  varname_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Find if/in first
  if_in_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rest_no_if_in = stringi::stri_replace_last_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rest_no_if_in = stringi::stri_trim_both(rest_no_if_in)
  } else {
      rest_no_if_in = rest_of_cmd_trimmed
  }

   # Find options (which contain gen())
  options_match = stringi::stri_match_first_regex(rest_no_if_in, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      varname_str = stringi::stri_replace_last_regex(rest_no_if_in, ",\\s*(.*)$", "")
      varname_str = stringi::stri_trim_both(varname_str)
  } else {
      # This case implies `encode varname` without `, gen(newvar)` which is invalid for encode.
      # Stata syntax is `encode varname, gen(newvar)`. The comma is mandatory before options.
      # So, if no comma, there are no options, and thus no gen().
      # This means `gen_var` will be NA, and the error will be thrown later.
      return(paste0("# encode command requires gen() in options: ", rest_of_cmd))
  }

   if (is.na(varname_str) || varname_str == "") {
       return(paste0("# encode command requires varname: ", rest_of_cmd))
   }

  # Parse options, specifically `gen()` or `generate()`
  gen_var = NA_character_
  if (!is.na(options_str)) {
      # Modified regex to accept 'gen' or 'generate'
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\b(?:gen|generate)\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars_str = stringi::stri_trim_both(gen_opt_match[1,2])
           gen_vars_list = stringi::stri_split_regex(gen_vars_str, "\\s+")[[1]]
           gen_var = gen_vars_list[1] # encode generates a single variable
       }
  }

  if (is.na(gen_var)) {
      return(paste0("# encode requires gen() option: ", rest_of_cmd))
  }

  # Translate if/in condition
  r_if_in_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
       r_if_in_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group=FALSE))
       if (is.na(r_if_in_cond) || r_if_in_cond == "") {
           return(paste0("# Failed to translate if/in condition for encode: ", stata_if_in_cond))
       }
  }

  # Temporary variable names for the fully calculated encoded vector and condition
  encoded_values_full_tmp_var = paste0("stata_tmp_encoded_full_L", cmd_obj$line)
  satisfies_cond_tmp_var = paste0("stata_tmp_encode_cond_L", cmd_obj$line)

  r_code_lines = c()

  # Initialize the new column as an integer vector. Labels will be applied by label values.
  r_code_lines = c(r_code_lines,
    paste0("data = dplyr::mutate(data, `", gen_var, "` = NA_integer_)")
  )

  # Calculate the full encoded vector (based on all unique values in source column, sorted alphabetically)
  # Stata encode assigns numeric codes (1, 2, ...) to non-missing string values, preserving missing values as NA.
  r_code_lines = c(r_code_lines,
    paste0("temp_source_vector_L", cmd_obj$line, " = data[['", varname_str, "']]"),
    # Get unique, non-NA, sorted string values to define the mapping to numeric codes
    paste0("temp_unique_values_L", cmd_obj$line, " = base::sort(base::unique(temp_source_vector_L", cmd_obj$line, "[!is.na(temp_source_vector_L", cmd_obj$line, ")]))"),
    # Create the integer codes (1, 2, ...) based on the sorted unique values. NA values in source remain NA.
    paste0("temp_numeric_values_L", cmd_obj$line, " = base::match(temp_source_vector_L", cmd_obj$line, ", temp_unique_values_L", cmd_obj$line, ")"),
    # Create the labels vector in the R code for haven::labelled
    paste0("temp_labels_vector_L", cmd_obj$line, " = stats::setNames(as.numeric(1:length(temp_unique_values_L", cmd_obj$line, ")), temp_unique_values_L", cmd_obj$line, ")"),
    # Create the haven::labelled object
    paste0(encoded_values_full_tmp_var, " = haven::labelled(as.integer(temp_numeric_values_L", cmd_obj$line, "), labels = temp_labels_vector_L", cmd_obj$line, ")"),
    # Clean up intermediate temp variables
    paste0("rm(temp_source_vector_L", cmd_obj$line, ", temp_unique_values_L", cmd_obj$line, ", temp_numeric_values_L", cmd_obj$line, ", temp_labels_vector_L", cmd_obj$line, ")")
  )

  # Apply the if/in condition for assignment to the target column in 'data'
  if (!is.na(r_if_in_cond) && r_if_in_cond != "") {
       r_code_lines = c(r_code_lines,
           paste0("## Calculate condition flag for encode"),
           # Stata 'if' treats missing as false. Ensure logical vector for subsetting.
           paste0(satisfies_cond_tmp_var, " = dplyr::coalesce(with(data, ", r_if_in_cond, "), FALSE)"),
           # Assign only for rows meeting the condition
           paste0("data[['", gen_var, "']][", satisfies_cond_tmp_var, "] = ", encoded_values_full_tmp_var, "[", satisfies_cond_tmp_var, "]"),
           paste0("rm(", satisfies_cond_tmp_var, ")")
       )
  } else {
      # No condition, assign the full encoded vector
      r_code_lines = c(r_code_lines,
           paste0("data[['", gen_var, "']] = ", encoded_values_full_tmp_var)
      )
  }

  r_code_lines = c(r_code_lines, paste0("rm(", encoded_values_full_tmp_var, ")"))

  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about other options if any were present but not handled (excluding gen)
   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        # Modify regex to remove both 'gen' and 'generate' forms
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\b(?:gen|generate)\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0("\n# Other options ignored: ", options_str_cleaned))
   }

  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_encode.R

!CHANGE_FILE R/t_generate.R
```R
t_generate = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_generate")
  # Parse `rest_of_cmd` for new variable name, expression, and if condition
  # Example: "newvar = expression [if condition]"

  # Capture explicit type declaration (e.g., `str10`)
  explicit_type_match = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*(byte|int|long|float|double|str\\d+|strL)\\s+")
  declared_type_str = NA_character_
  if (!is.na(explicit_type_match[1,1])) {
    declared_type_str = explicit_type_match[1,2]
  }

  # Strip type if present (e.g. gen double newvar = ...)
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^\\s*(?:byte|int|long|float|double|str\\d+|strL)\\s+", "")

  match = stringi::stri_match_first_regex(rest_of_cmd_no_type, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  if (is.na(match[1,1])) {
    return(paste0("# Failed to parse generate command: ", rest_of_cmd))
  }

  new_var = stringi::stri_trim_both(match[1,2])
  stata_expr = stringi::stri_trim_both(match[1,3])
  stata_if_cond = stringi::stri_trim_both(match[1,4]) # Might be NA

  # Context for expression translation (e.g. _n, _N behavior)
  # is_by_group TRUE if cmd_obj$by_group_vars is not NA
  current_context = list(is_by_group = cmd_obj$is_by_prefix && length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1]))
  
  # Translate the Stata expression to R first
  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, current_context)

  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    # The 'if' condition for generate/replace is evaluated row-wise on the whole dataset, not per group.
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  # Determine arrange step if needed
  arrange_call = ""
  group_vars_list_bare = character(0) # For dplyr::group_by
  
  # Variables that define the sort order (from by-prefix)
  vars_for_initial_sort = character(0)

  if (cmd_obj$is_by_prefix) {
    if (length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1])) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[!is.na(group_vars_list) & group_vars_list != ""]
      if (length(group_vars_list) > 0) {
        group_vars_list_bare = group_vars_list # Assign just the bare names
        vars_for_initial_sort = c(vars_for_initial_sort, group_vars_list)
      }
    }

    if (length(cmd_obj$by_sort_vars) > 0 && !is.na(cmd_obj$by_sort_vars[1])) {
      sort_vars_list = stringi::stri_split_fixed(cmd_obj$by_sort_vars, ",")[[1]]
      sort_vars_list = sort_vars_list[!is.na(sort_vars_list) & sort_vars_list != ""]
      vars_for_initial_sort = c(vars_for_initial_sort, sort_vars_list)
    }

    if (length(vars_for_initial_sort) > 0) {
      # Ensure unique and preserve order implicitly (by c() then unique)
      vars_for_initial_sort = unique(vars_for_initial_sort) 
      arrange_call = paste0("data = dplyr::arrange(data, !!!dplyr::syms(c(", paste0('"', vars_for_initial_sort, '"', collapse = ", "), ")))")
    }
  }

  # Determine if the target variable will be a string type.
  # This determines the 'NA' value when the 'if' condition is false.
  target_var_will_be_string = FALSE
  if (!is.na(declared_type_str) && stringi::stri_startswith_fixed(declared_type_str, "str")) {
      target_var_will_be_string = TRUE
  } else if (is_stata_expr_string_type(stata_expr)) {
      target_var_will_be_string = TRUE
  }

  # Step 1: Calculate the value for the new variable, potentially conditionally
  # The value to assign if the condition is false/missing.
  na_or_empty_str_for_false_cond = if (target_var_will_be_string) '""' else "NA_real_"

  # The expression result itself might need casting, e.g. logical expr to numeric 0/1
  calculated_value_expr = r_expr
  if (!target_var_will_be_string && stringi::stri_detect_regex(stata_expr, "==|!=|~=|<=|>=|<|>|&|\\|")) {
    calculated_value_expr = paste0("as.numeric(", r_expr, ")")
  }

  if (!is.na(r_if_cond) && r_if_cond != "") {
    # Stata's 'if' condition treats NA as FALSE.
    calc_expr = paste0("dplyr::if_else(dplyr::coalesce(", r_if_cond, ", FALSE), ", calculated_value_expr, ", ", na_or_empty_str_for_false_cond, ")")
  } else {
    calc_expr = calculated_value_expr
  }

  # Step 2: Build the R code string using pipes for the mutate operation
  r_code_lines = c()
  
  if (arrange_call != "") {
      r_code_lines = c(r_code_lines, arrange_call)
  }

  pipe_elements = list("data") # Elements for the pipe chain, starting from `data`

  # Add grouping and mutate steps
  if (length(group_vars_list_bare) > 0) {
      group_by_call_str = paste0('dplyr::group_by(!!!dplyr::syms(c("', paste0(group_vars_list_bare, collapse='", "'), '")))')
      pipe_elements = c(pipe_elements, group_by_call_str)
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", new_var, "` = ", calc_expr, ")"))
      pipe_elements = c(pipe_elements, "dplyr::ungroup()")
  } else {
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", new_var, "` = ", calc_expr, ")"))
  }

  # This is the final assignment line for the current command
  # It takes 'data' (potentially already arranged) and pipes it through the rest
  r_code_lines = c(r_code_lines, paste0("data = ", paste(pipe_elements, collapse = " %>% \n  ")))


  return(paste(r_code_lines, collapse="\n"))
}
```
!END_CHANGE_FILE R/t_generate.R

!CHANGE_FILE R/t_merge.R
```R
# Translate Stata 'merge' command
# Stata: merge 1:1 varlist using filename [, options]
# Stata: merge 1:m varlist using filename [, options]
# Stata: merge m:1 varlist using filename [, options]
# Stata: merge m:m varlist using filename [, options]
# Options: keep(match master using all) nogenerate

t_merge = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_merge") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Define a temporary indicator column name for dplyr::join
  indicator_col_name = paste0("stata_merge_indicator_L", line_num)

  # Parse merge type (1:1, 1:m, m:1, m:m), varlist, `using filename`, and options
  # Corrected regex for merge type to allow 'm'
  # Pattern: ^\s*([1m]:[1m])\s+(.*?)\s+using\s+([^,\s]+)(?:,\\s*(.*))?$
  # G1: type, G2: varlist, G3: filename (can be quoted or macro), G4: options

  merge_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*([1m]:[1m])\\s+(.*?)\\s+using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")
  merge_type = NA_character_
  varlist_str = NA_character_
  raw_filename_token = NA_character_
  options_str = NA_character_


  if (is.na(merge_match[1,1])) {
      # Check for older syntax without type: `merge varlist using filename` (defaults to 1:1)
      merge_match_old = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(.*?)\\s+using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")
      if (!is.na(merge_match_old[1,1])) {
           merge_type = "1:1" # Assume 1:1 if type not specified
           varlist_str = stringi::stri_trim_both(merge_match_old[1,2])
           raw_filename_token = stringi::stri_trim_both(merge_match_old[1,3])
           options_str = stringi::stri_trim_both(merge_match_old[1,4])
      } else {
           return(paste0("# Failed to parse merge command: ", rest_of_cmd))
      }
  } else {
      merge_type = merge_match[1,2]
      varlist_str = stringi::stri_trim_both(merge_match[1,3])
      raw_filename_token = stringi::stri_trim_both(merge_match[1,4])
      options_str = stringi::stri_trim_both(merge_match[1,5]) # NA if no options
  }

  vars_to_merge_on = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_merge_on = vars_to_merge_on[vars_to_merge_on != ""]
  if (length(vars_to_merge_on) == 0) {
       return(paste0("# merge command requires varlist: ", rest_of_cmd))
  }
  # For dplyr::join, by argument can be a character vector of column names
  vars_to_merge_on_r_vec_str = paste0('c("', paste(vars_to_merge_on, collapse = '", "'), '")')

  # Changed default_base_dir_var to "working_dir" for consistency with Stata's default file paths
  using_source_r_expr = resolve_stata_filename(raw_filename_token, cmd_df, line_num, default_base_dir_var = "working_dir")


  # Determine join type based on Stata's `keep()` option or default behavior
  # Stata's default merge behavior is to keep matching observations and unmatched master observations (left_join).
  # If no keep() option is specified, default to left_join.
  join_type_r_func = "dplyr::left_join" # Default for Stata merge
  keep_spec_for_comment = "match master" # Default if no keep() specified

  if (!is.na(options_str)) {
      keep_opt_match = stringi::stri_match_first_regex(options_str, "\\bkeep\\s*\\(([^)]+)\\)")
      if (!is.na(keep_opt_match[1,1])) {
          keep_spec = stringi::stri_trim_both(keep_opt_match[1,2])
          if (grepl("\\ball\\b", keep_spec)) {
              join_type_r_func = "dplyr::full_join"
              keep_spec_for_comment = "all"
          } else if (grepl("\\bmaster\\b", keep_spec)) {
              join_type_r_func = "dplyr::left_join" # Keep matched and master unmatched (left join)
              keep_spec_for_comment = "master"
          } else if (grepl("\\busing\\b", keep_spec)) {
              join_type_r_func = "dplyr::right_join" # Keep matched and using unmatched (right join)
               keep_spec_for_comment = "using"
          } else if (grepl("\\bmatch\\b", keep_spec)) {
              join_type_r_func = "dplyr::inner_join" # Keep matched only (inner join)
              keep_spec_for_comment = "match"
          }
          # Other complex keep() specs like `keep(_merge==3)` are not handled here.
      }
  }

  # Handle nogenerate option - FIX: use regex to correctly detect 'nogen' abbreviation
  has_nogenerate = !is.na(options_str) && stringi::stri_detect_regex(options_str, "\\bno(?:generate|gen)\\b")
  
  # Build the R command string using dplyr::*_join

  # Load the using dataset into a temporary variable first
  r_code_lines = c()
  temp_using_data_var = paste0("stata_tmp_using_data_L", line_num)
  r_code_lines = c(r_code_lines, paste0(temp_using_data_var, " = haven::read_dta(", using_source_r_expr, ")"))

  # For 1:1 merge, check for unique keys in both master and using datasets to replicate Stata's strictness
  if (merge_type == "1:1") {
      r_code_lines = c(r_code_lines,
          paste0("if (any(duplicated(data[[", vars_to_merge_on_r_vec_str, ", drop=FALSE]]))) { stop('Merge 1:1 failed: Duplicate keys found in master dataset (data).') }"),
          paste0("if (any(duplicated(", temp_using_data_var, "[[", vars_to_merge_on_r_vec_str, ", drop=FALSE]]))) { stop('Merge 1:1 failed: Duplicate keys found in using dataset (', ", using_source_r_expr, ", ').') }")
      )
  }

  # Ensure merge keys are plain numeric for robustness against haven-specific types
  r_code_lines = c(r_code_lines,
      paste0("data = dplyr::mutate(data, ", paste0("`", vars_to_merge_on, "` = as.numeric(`", vars_to_merge_on, "`)", collapse = ", "), ")"),
      paste0(temp_using_data_var, " = dplyr::mutate(", temp_using_data_var, ", ", paste0("`", vars_to_merge_on, "` = as.numeric(`", vars_to_merge_on, "`)", collapse = ", "), ")")
  )


  # Identify common columns that are NOT merge keys
  r_code_lines = c(r_code_lines,
    paste0("common_cols = intersect(names(data), names(", temp_using_data_var, "))"),
    paste0("common_cols_not_by = setdiff(common_cols, ", vars_to_merge_on_r_vec_str, ")")
  )

  # Conditional dropping of columns from the using dataset
  # This is a general Stata merge rule: master's non-key variables take precedence.
  r_code_lines = c(r_code_lines,
    paste0("if (length(common_cols_not_by) > 0) { ", temp_using_data_var, " = dplyr::select(", temp_using_data_var, ", -dplyr::all_of(common_cols_not_by)) }")
  )

  # Perform the join with indicator
  r_code_lines = c(r_code_lines,
    paste0("data = ", join_type_r_func, "(data, ", temp_using_data_var, ", by = ", vars_to_merge_on_r_vec_str, ", indicator = \"", indicator_col_name, "\")")
  )

  # Generate _merge variable unless nogenerate option is present
  if (!has_nogenerate) {
      r_code_lines = c(r_code_lines,
          paste0("data = dplyr::mutate(data, `_merge` = dplyr::case_when("),
          paste0("  `", indicator_col_name, "` == \"left_only\" ~ 1L,"),
          paste0("  `", indicator_col_name, "` == \"right_only\" ~ 2L,"),
          paste0("  `", indicator_col_name, "` == \"both\" ~ 3L,"),
          paste0("  TRUE ~ NA_integer_ # Should not happen if join is successful, but for safety"),
          paste0("))")
      )
  } else {
    r_code_lines = c(r_code_lines, paste0(" # _merge variable was not generated due to 'nogenerate' option."))
  }

  # Always remove the temporary indicator column
  # Use dplyr::any_of to prevent error if column somehow not created (e.g. older dplyr or unexpected join result)
  r_code_lines = c(r_code_lines, paste0("data = dplyr::select(data, -dplyr::any_of('", indicator_col_name, "'))"))

  # Clean up temporary variables
  r_code_lines = c(r_code_lines, paste0("rm(", temp_using_data_var, ", common_cols, common_cols_not_by)"))

  # Add comment about options
  merge_comment_line = paste0("# Stata merge type: ", merge_type, ", keep(", keep_spec_for_comment, ")")
  if (has_nogenerate) {
    merge_comment_line = paste0(merge_comment_line, ", nogenerate")
  }
  r_code_lines = c(r_code_lines, merge_comment_line)

  options_str_cleaned = options_str
  if (!is.na(options_str_cleaned)) {
      # Remove keep() and nogenerate from options string for comment
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bkeep\\s*\\([^)]+\\)", "")
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bno(?:generate|gen)\\b", "") # Updated to remove both
      options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
  }
  if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
       r_code_lines = c(r_code_lines, paste0(" # Other options ignored: ", options_str_cleaned))
  }

  return(paste(r_code_lines, collapse="\n"))
}
```
!END_CHANGE_FILE R/t_merge.R

!CHANGE_FILE R/t_recode.R
```R
# Translate Stata 'recode' command
# Stata: recode varlist (rule1)(rule2)... [if] [in] [, options]
# Example: recode income (0=.) (100 thru 200 = 150) (300 301 305 = 300) (else=copy), gen(newincome)

t_recode = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_recode") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varlist, rules, if/in, options (especially gen())
  # This parsing is quite complex due to nested parentheses and optional parts.
  # Let's try to split varlist first, then find rules in parentheses.
  # Example: `recode var1 var2 (0=.) (1/10=1) (else=copy) if cond, gen(new1 new2)`

  # Split at first parenthesis to get varlist
  parts_varlist = stringi::stri_split_fixed(rest_of_cmd_trimmed, "(", n=2)[[1]]
  if (length(parts_varlist) != 2) {
      return(paste0("# Failed to parse recode command (missing rules): ", rest_of_cmd))
  }
  varlist_str = stringi::stri_trim_both(parts_varlist[1])
  vars_to_recode = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_recode = vars_to_recode[vars_to_recode != ""]

  if (length(vars_to_recode) == 0) {
      return(paste0("# recode command requires varlist: ", rest_of_cmd))
  }

  rules_and_rest = paste0("(", parts_varlist[2]) # Put the '(' back

  # Separate if/in and options from rules
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Look for `if` or `in` first
  if_in_match = stringi::stri_match_first_regex(rules_and_rest, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rules_and_rest = stringi::stri_replace_last_regex(rules_and_rest, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rules_and_rest = stringi::stri_trim_both(rules_and_rest)
  }

  # Look for options after the if/in part or after rules
  options_match = stringi::stri_match_first_regex(rules_and_rest, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2]) # Corrected to take group 2 for options string
      rules_part = stringi::stri_replace_last_regex(rules_and_rest, ",\\s*(.*)$", "")
      rules_part = stringi::stri_trim_both(rules_part)
  } else {
      rules_part = rules_and_rest
  }

  # Now parse the rules part: (rule1)(rule2)...
  # Find all rules within parentheses
  rule_matches = stringi::stri_match_all_regex(rules_part, "\\(([^)]*)\\)")[[1]] # Match content inside ()
  if (NROW(rule_matches) == 0) {
      return(paste0("# Failed to parse recode rules: ", rules_part))
  }
  recode_rules_raw = rule_matches[,2] # Extract the content within parentheses


  # Parse options, specifically `gen()`
  gen_vars = NA_character_
  if (!is.na(options_str)) {
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgen\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars = stringi::stri_trim_both(gen_opt_match[1,2])
       }
  }

  new_vars = NULL
  if (!is.na(gen_vars)) {
      new_vars = stringi::stri_split_regex(gen_vars, "\\s+")[[1]]
      new_vars = new_vars[new_vars != ""]
      if (length(new_vars) != length(vars_to_recode)) {
          return(paste0("# recode gen() option requires same number of new variables as old variables."))
      }
  } else {
      # If no gen() option, recode is done in place. New vars are the same as old vars.
      new_vars = vars_to_recode
  }

  # --- Determine the target variable type and collect labels if applicable ---
  target_var_will_be_string_in_R = FALSE
  target_var_is_numeric_with_labels = FALSE
  # Use a temporary list to collect labels (name=label string, value=numeric code)
  collected_labels_temp = list() 

  for (rule_raw in recode_rules_raw) {
      rule_str_trimmed = stringi::stri_trim_both(rule_raw)
      parts_eq = stringi::stri_split_fixed(rule_str_trimmed, "=", n=2)[[1]]
      if (length(parts_eq) != 2) next # Skip malformed rules
      new_part_raw = stringi::stri_trim_both(parts_eq[2])

      # Check for plain string literal (e.g., "new_string_value")
      if ( (stringi::stri_startswith_fixed(new_part_raw, '"') && stringi::stri_endswith_fixed(new_part_raw, '"')) ||
           (stringi::stri_startswith_fixed(new_part_raw, "'") && stringi::stri_endswith_fixed(new_part_raw, "'")) ) {
          target_var_will_be_string_in_R = TRUE
          # If any rule implies string, the whole var becomes string. Labels are not applicable.
          target_var_is_numeric_with_labels = FALSE
          # No need to process further rules for labels if it's already determined to be a string target
          # break # Don't break immediately, still need to parse all rules to build case_when
      }

      # Check for 'value "label"' syntax
      label_match = stringi::stri_match_first_regex(new_part_raw, "^\\s*([^\\s]+)\\s+(?:\"([^\"]*)\"|'([^']*)')\\s*$")
      if (!is.na(label_match[1,1])) {
          # If we already determined it's a string target, don't try to collect labels.
          if (!target_var_will_be_string_in_R) {
              target_var_is_numeric_with_labels = TRUE
              numeric_val_part = stringi::stri_trim_both(label_match[1,2])
              string_label_part = ifelse(!is.na(label_match[1,3]), label_match[1,3], label_match[1,4])

              # Convert numeric value to R numeric (handling Stata's missing values)
              r_numeric_val = NA_real_
              if (numeric_val_part == ".") r_numeric_val = NA_real_
              else if (stringi::stri_detect_regex(numeric_val_part, "^\\.[a-zA-Z]$")) r_numeric_val = NA_real_
              else r_numeric_val = as.numeric(numeric_val_part)

              if (!is.na(r_numeric_val)) {
                # Collect label: key is numeric value, value is label string
                # For haven, labels are names, values are the actual codes. So we store label=value.
                collected_labels_temp[[string_label_part]] = r_numeric_val
              }
          }
      }
  }

  # After loop, convert collected_labels_temp to the final named numeric vector for labels
  # `collected_labels_temp` has label strings as keys and numeric values as values.
  # haven::labelled expects labels = c("Label A" = 1, "Label B" = 2).
  # So, the final format should be: names are labels, values are numeric codes.

  final_labels_map = stats::setNames(numeric(0), character(0)) # Initialize empty named numeric vector
  if (target_var_is_numeric_with_labels && length(collected_labels_temp) > 0) {
      # Convert to a data.frame for easier manipulation and duplicate handling
      # If a label is reused for different values, haven::labelled will just use it.
      # If a value is given multiple labels, the last one for that value applies.
      
      temp_df_labels = data.frame(
          label = names(collected_labels_temp),
          value = unlist(collected_labels_temp, use.names = FALSE),
          stringsAsFactors = FALSE
      )
      
      # Handle duplicates: Stata's recode takes the last definition for a value.
      # So, if same value is assigned different labels, the last label for that value wins.
      # Or if different values get the same label, all are kept.
      # For haven::labelled, if multiple labels point to the same value, it's fine.
      # If a value has multiple labels, haven will use the first one.
      # To match Stata's "last rule wins" for value redefinition, we'll ensure
      # that if a numeric value is assigned multiple times, only the last assignment is kept.
      
      # Sort by value, then by rule order to ensure last rule wins for a value.
      temp_df_labels$order_idx = seq_len(NROW(temp_df_labels)) # Preserve original order
      temp_df_labels = temp_df_labels[order(temp_df_labels$value, temp_df_labels$order_idx), ]
      temp_df_labels = temp_df_labels[!duplicated(temp_df_labels$value, fromLast = TRUE), ] # Keep last entry for duplicate values
      
      # Create the final named vector: names are labels, values are the numeric codes
      final_labels_map = stats::setNames(temp_df_labels$value, temp_df_labels$label)
      # Reorder by numeric value for consistency, if desired, but not strictly necessary for functionality
      final_labels_map = final_labels_map[order(unname(final_labels_map))]
  }

  # This is the variable that was missing in the test:
  final_r_var_type_is_labelled_numeric = target_var_is_numeric_with_labels


  # Translate the if/in condition for subsetting
  r_subset_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for recode: ", stata_if_in_cond))
       }
  }


  # Translate rules into R case_when clauses
  # Rule format: old_value = new_value
  # old_value can be: single value, range (val1/val2, val1 thru val2), list (val1 val2), else, missing (.)
  # new_value can be: single value, copy (use original value), missing (.)

  translate_recode_rule = function(rule_str, source_var_r, target_var_will_be_string_in_R) { # Corrected parameter name
      restore.point("translate_recode_rule_inner")
      rule_str = stringi::stri_trim_both(rule_str)
      parts_eq = stringi::stri_split_fixed(rule_str, "=", n=2)[[1]]
      if (length(parts_eq) != 2) {
          return(paste0("## Error parsing rule: ", rule_str))
      }
      old_part_raw = stringi::stri_trim_both(parts_eq[1])
      new_part_raw = stringi::stri_trim_both(parts_eq[2])

      # Translate old_part into R condition (left side of case_when ~ )
      r_condition = ""
      if (old_part_raw == "else") {
          r_condition = "TRUE" # This rule is the fallback
      } else if (old_part_raw == "missing" || stringi::stri_detect_regex(old_part_raw, "^\\.\\w?$")) { # Added regex for .a, .b, etc.
           r_condition = paste0("sfun_missing(", source_var_r, ")") # Missing value rule (all Stata missing types to R's NA)
      } else if (old_part_raw == "nonmissing") {
           r_condition = paste0("!sfun_missing(", source_var_r, ")") # Non-missing value rule
      } else if (grepl("\\s+thru\\s+", old_part_raw)) {
           # Range: val1 thru val2
           range_parts = stringi::stri_split_regex(old_part_raw, "\\s+thru\\s+", n=2)[[1]]
           val1 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[1]), context=list(is_by_group=FALSE))
           val2 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[2]), context=list(is_by_group=FALSE))
           if (is.na(val1) || is.na(val2)) return(paste0("## Error translating range values in rule: ", rule_str))
           r_condition = paste0(source_var_r, " >= ", val1, " & ", source_var_r, " <= ", val2)
      } else if (grepl("/", old_part_raw)) {
          # Range: val1/val2
           range_parts = stringi::stri_split_regex(old_part_raw, "/", n=2)[[1]]
           val1 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[1]), context=list(is_by_group=FALSE))
           val2 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[2]), context=list(is_by_group=FALSE))
           if (is.na(val1) || is.na(val2)) return(paste0("## Error translating range values in rule: ", rule_str))
           r_condition = paste0(source_var_r, " >= ", val1, " & ", source_var_r, " <= ", val2) # Stata / is inclusive range
      }
      else {
          # List of values or single value
          old_values = stringi::stri_split_regex(old_part_raw, "\\s+")[[1]]
          old_values = old_values[old_values != ""]
          r_values = sapply(old_values, function(val) {
               # Use translate_stata_expression_to_r for each value in the list
               # Stata missing values like '.' or '.a' should be handled as NA in R
               if (val == ".") return("NA_real_")
               if (stringi::stri_detect_regex(val, "^\\.[a-zA-Z]$")) return("NA_real_")
               translate_stata_expression_to_r(val, context=list(is_by_group=FALSE))
          })
          r_values = r_values[!is.na(r_values)] # Filter out any NA from translation for safety
          if (length(r_values) == 0) return(paste0("## Error translating old values in rule: ", rule_str))
          # For comparison, ensure values are cast to same type as source_var_r or handled by %in%
          # The `translate_stata_expression_to_r` should return string literals for string values, numeric literals for numeric.
          r_condition = paste0(source_var_r, " %in% c(", paste(r_values, collapse = ", "), ")")
      }


      # Translate new_part into R value (right side of case_when ~ )
      r_new_value = ""
      if (new_part_raw == "copy") {
          r_new_value = source_var_r # Use the original variable value
          # If target is string but source is not, need to convert source to string
          if (target_var_will_be_string_in_R) {
            r_new_value = paste0("as.character(", r_new_value, ")")
          }
      } else {
          # Check for numeric value with optional label, e.g., '1 "Very Low"'
          label_match = stringi::stri_match_first_regex(new_part_raw, "^\\s*([^\\s]+)\\s+(?:\"([^\"]*)\"|'([^']*)')\\s*$")
          if (!is.na(label_match[1,1])) {
              # It's a "value label" syntax
              numeric_val_part = stringi::stri_trim_both(label_match[1,2])
              # If target is string, return the label as a string literal
              if (target_var_will_be_string_in_R) {
                  string_label_part = ifelse(!is.na(label_match[1,3]), label_match[1,3], label_match[1,4])
                  r_new_value = quote_for_r_literal(string_label_part)
              } else {
                  # If target is numeric (possibly labelled numeric), return the numeric value, translated
                  r_new_value = translate_stata_expression_to_r(numeric_val_part, context=list(is_by_group=FALSE))
              }
          } else {
              # It's a plain expression or literal (numeric or string)
              r_new_value = translate_stata_expression_to_r(new_part_raw, context=list(is_by_group=FALSE))
              # If target is string, ensure the expression result is cast to string
              if (target_var_will_be_string_in_R) {
                  # This is the crucial change for Stata's missing value conversion to empty string
                  if (r_new_value == "NA_real_") {
                      r_new_value = '""' # Stata recode for missing numeric to empty string for string variables
                  } else if (!stringi::stri_startswith_fixed(r_new_value, '"') && !stringi::stri_startswith_fixed(r_new_value, "'")) {
                      # Only wrap in as.character() if it's not already a quoted string
                      r_new_value = paste0("as.character(", r_new_value, ")")
                  }
              }
          }
      }

      return(paste0(r_condition, " ~ ", r_new_value))
  }

  # Generate case_when expression for each variable
  mutate_exprs = character(length(vars_to_recode))
  r_code_lines = c()

  for (k in seq_along(vars_to_recode)) {
      old_var = vars_to_recode[k]
      new_var = new_vars[k]
      source_var_r = old_var # R variable name for the source column

      # Translate all rules for this variable
      # Pass the determined target type
      r_rules = sapply(recode_rules_raw, translate_recode_rule, source_var_r = source_var_r, target_var_will_be_string_in_R = target_var_will_be_string_in_R)

      # Combine rules into a case_when statement
      case_when_expr = paste0("dplyr::case_when(\n    ", paste(r_rules, collapse = ",\n    "), "\n  )")

      # Apply global if/in condition around the case_when
      if (!is.na(r_subset_cond) && r_subset_cond != "") {
          # If condition is met, apply case_when. Otherwise, keep original value.
          # Stata's `if` condition treats missing as FALSE, so use coalesce.
          final_value_expr = paste0("dplyr::if_else(dplyr::coalesce(", r_subset_cond, ", FALSE),\n",
                                    "    ", case_when_expr, ",\n",
                                    "    `", source_var_r, "`)") # Keep original value if condition not met.
      } else {
          final_value_expr = case_when_expr
      }


      mutate_exprs[k] = paste0("`", new_var, "` = ", final_value_expr)
  }

  # Combine mutate expressions
  mutate_exprs_str = paste(mutate_exprs, collapse = ",\n  ")

  # Build the final R code using dplyr::mutate
  r_code_lines = c(r_code_lines, paste0("data = dplyr::mutate(data, ", mutate_exprs_str, ")"))

  # Apply labels if the target variable is determined to be numeric with labels
  if (final_r_var_type_is_labelled_numeric && length(final_labels_map) > 0) {
      # The `final_labels_map` is already in the format `labels = c("label1" = value1, ...)`
      labels_vector_r_code = paste0("c(", paste0('"', names(final_labels_map), '" = ', unname(final_labels_map), collapse=", "), ")")

      for (new_var in new_vars) {
          # Need to update the labels attribute directly, as haven::labelled only sets it on creation
          r_code_lines = c(r_code_lines, paste0("attr(data$`", new_var, "`, \"labels\") = ", labels_vector_r_code))
          # Ensure it remains a labelled class, or re-apply haven::labelled
          # For simplicity, if it was just mutated to numeric, this attribute should suffice
          # If it was already a labelled numeric, this will update/overwrite its labels.
      }
  }


  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about options if any were present but not handled (excluding gen)
   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bgen\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ",")) # Clean up multiple commas
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0("\n# Other options ignored: ", options_str_cleaned))
   }


  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_recode.R

!CHANGE_FILE R/t_replace.R
```R
t_replace = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_replace")
  # Capture explicit type declaration (e.g., `str10`)
  explicit_type_match = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*(byte|int|long|float|double|str\\d+|strL)\\s+")
  declared_type_str = NA_character_
  if (!is.na(explicit_type_match[1,1])) {
    declared_type_str = explicit_type_match[1,2]
  }

  # Strip type if present (e.g. replace double oldvar = ...)
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^(?:byte|int|long|float|double|str\\d+|strL)\\s+", "")

  match = stringi::stri_match_first_regex(rest_of_cmd_no_type, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  if (is.na(match[1,1])) {
    return(paste0("# Failed to parse replace command: ", rest_of_cmd))
  }

  var_to_replace = stringi::stri_trim_both(match[1,2])
  stata_expr = stringi::stri_trim_both(match[1,3])
  stata_if_cond = stringi::stri_trim_both(match[1,4]) # Might be NA

  current_context = list(is_by_group = cmd_obj$is_by_prefix && length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1]))
  # Translate the Stata expression to R first
  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, current_context)

  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  # Determine arrange step if needed
  arrange_call = ""
  group_vars_list_bare = character(0) # For dplyr::group_by

  # Variables that define the sort order (from by-prefix)
  vars_for_initial_sort = character(0)

  if (cmd_obj$is_by_prefix) {
    if (length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1])) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[!is.na(group_vars_list) & group_vars_list != ""]
      if (length(group_vars_list) > 0) {
        group_vars_list_bare = group_vars_list # Assign just the bare names
        vars_for_initial_sort = c(vars_for_initial_sort, group_vars_list)
      }
    }

    if (length(cmd_obj$by_sort_vars) > 0 && !is.na(cmd_obj$by_sort_vars[1])) {
      sort_vars_list = stringi::stri_split_fixed(cmd_obj$by_sort_vars, ",")[[1]]
      sort_vars_list = sort_vars_list[!is.na(sort_vars_list) & sort_vars_list != ""]
      vars_for_initial_sort = c(vars_for_initial_sort, sort_vars_list)
    }

    if (length(vars_for_initial_sort) > 0) {
      vars_for_initial_sort = unique(vars_for_initial_sort)
      arrange_call = paste0("data = dplyr::arrange(data, !!!dplyr::syms(c(", paste0('"', vars_for_initial_sort, '"', collapse = ", "), ")))")
    }
  }

  # Determine if the target variable is a string type.
  # For 'replace', we should check the current type of the variable in the data,
  # or if an explicit `str#` type is declared.
  # The existing variable `var_to_replace`'s type is difficult to know at translation time.
  # However, `is_stata_expr_string_type` for the expression itself is a good proxy.
  # If the target variable *was* string, and the expression *is* string, it stays string.
  # If the target variable *was* numeric, and the expression *is* string, it becomes string.
  # If the target variable *was* string, and the expression *is* numeric, it tries to convert (Stata warns/errors).
  # The most robust approach is to rely on `is_stata_expr_string_type` and explicit `str#` declaration.
  target_var_will_be_string = FALSE
  if (!is.na(declared_type_str) && stringi::stri_startswith_fixed(declared_type_str, "str")) {
      target_var_will_be_string = TRUE
  } else if (is_stata_expr_string_type(stata_expr)) {
      target_var_will_be_string = TRUE
  }
  # If not explicitly declared and not string expression, assume numeric.

  # The value to assign if the condition is false/missing.
  # For 'replace', if condition is false, the *original value* is kept, not NA or "".
  # So, `na_or_empty_str_for_false_cond` is not needed in the `if_else` 'false' branch;
  # instead, it's `data$`var_to_replace`.

  # The expression result itself might need casting, e.g. logical expr to numeric 0/1
  calculated_value_expr = r_expr
  if (!target_var_will_be_string && stringi::stri_detect_regex(stata_expr, "==|!=|~=|<=|>=|<|>|&|\\|")) {
    calculated_value_expr = paste0("as.numeric(", r_expr, ")")
  }
  # If target is string, ensure the expression result is cast to string and NA_real_ becomes ""
  if (target_var_will_be_string) {
      if (calculated_value_expr == "NA_real_") {
          calculated_value_expr = '""' # Stata replace for missing numeric to empty string for string variables
      } else if (!stringi::stri_startswith_fixed(calculated_value_expr, '"') && !stringi::stri_startswith_fixed(calculated_value_expr, "'")) {
          # Only wrap in as.character() if it's not already a quoted string
          calculated_value_expr = paste0("as.character(", calculated_value_expr, ")")
      }
  }


  # For 'replace' command, if condition is FALSE or NA, the value should be left unchanged.
  # Use dplyr::coalesce(condition, FALSE) to treat NA condition as FALSE.
  if (!is.na(r_if_cond) && r_if_cond != "") {
    calc_expr = paste0("dplyr::if_else(dplyr::coalesce(", r_if_cond, ", FALSE), ", calculated_value_expr, ", data$`", var_to_replace, "`)")
  } else {
    calc_expr = calculated_value_expr
  }

  # Step 2: Build the R code string using pipes for the mutate operation
  r_code_lines = c()

  if (arrange_call != "") {
      r_code_lines = c(r_code_lines, arrange_call)
  }

  pipe_elements = list("data") # Elements for the pipe chain, starting from `data`

  if (length(group_vars_list_bare) > 0) { # Check if group_vars_list_bare is not empty
      group_by_call_str = paste0('dplyr::group_by(!!!dplyr::syms(c("', paste0(group_vars_list_bare, collapse='", "'), '")))')
      pipe_elements = c(pipe_elements, group_by_call_str)
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", var_to_replace, "` = ", calc_expr, ")"))
      pipe_elements = c(pipe_elements, "dplyr::ungroup()")
  } else {
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", var_to_replace, "` = ", calc_expr, ")"))
  }

  r_code_lines = c(r_code_lines, paste0("data = ", paste(pipe_elements, collapse = " %>% \n  ")))

  return(paste(r_code_lines, collapse="\n"))
}
```
!END_CHANGE_FILE R/t_replace.R

!CHANGE_FILE R/stata_expression_translator.R
```R
# Stata Expression Translator

# Placeholder for Stata results (r() and e() values)
# This environment would be populated by commands like summarize, regress
# For now, we will generate unique variable names for r() values.
# stata_results_env = new.env(parent = emptyenv())


# Translates a Stata expression string into an R expression string
# stata_expr: The Stata expression (e.g., "var1 + log(var2)")
# context: Information about the context (e.g., if inside a by group, for _n/_N)
# r_value_mappings: A named list/vector mapping Stata r-value names (e.g. "r(mean)")
#                   to R variable names (e.g. "stata_r_val_L5_mean")
translate_stata_expression_to_r = function(stata_expr, context = list(is_by_group = FALSE), r_value_mappings = NULL) {
  restore.point("translate_stata_expression_to_r")
  if (is.na(stata_expr) || stata_expr == "") return(NA_character_)

  r_expr = stata_expr

  # Step 1: Handle Stata missing value literals '.', '.a', ..., '.z'
  # This must happen early to prevent interference with decimal numbers or variable names.
  # Regex matches '.' or '.a' to '.z' only when not part of a number or a variable name.
  r_expr = stringi::stri_replace_all_regex(r_expr, "(?<![0-9a-zA-Z_])\\.[a-zA-Z]?(?![0-9a-zA-Z_])", "NA_real_")

  # Step 2: Handle r() values using the mapping.
  # This ensures that r() values are replaced by their corresponding R variable names
  # BEFORE other transformations (like missing value checks) are applied to them.
  if (!is.null(r_value_mappings) && length(r_value_mappings) > 0) {
    for (stata_r_name in names(r_value_mappings)) {
      # Escape parentheses for regex matching
      stata_r_regex = gsub("(", "\\(", gsub(")", "\\)", stata_r_name, fixed=TRUE), fixed=TRUE)
      r_expr = stringi::stri_replace_all_regex(r_expr, stata_r_regex, r_value_mappings[[stata_r_name]])
    }
  }

  # Step 3: Translate Stata logical operators and missing value comparisons.
  # These must happen after handling `r()` values so `r(mean)` is already `stata_r_val_Lxx_mean`.
  # Stata `X == .` -> R `sfun_missing(X)`
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\b[a-zA-Z_][a-zA-Z0-9_.]*\\b)\\s*==\\s*NA_real_", "sfun_missing($1)")
  # Stata `X != .` -> R `!sfun_missing($1)`
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\b[a-zA-Z_][a-zA-Z0-9_.]*\\b)\\s*!=\\s*NA_real_", "!sfun_missing($1)")

  r_expr = stringi::stri_replace_all_regex(r_expr, "(?<![<>!=~])\\s*=\\s*(?![=])", " == ") # Replace single = with == if not part of other ops
  r_expr = stringi::stri_replace_all_regex(r_expr, "\\s+~=\\s+", " != ") # Stata `~=` to R `!=`


  # Step 4: Translate Stata special variables and indexing (e.g., _n, _N, var[_n-1])
  # These are generally fixed references, not nested functions.
  # Use dplyr::lag/lead which are context-aware in grouped operations.

  # Directly replace with `n = $2`
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\w+)\\[_n\\s*-\\s*(\\d+)\\]", "dplyr::lag($1, n = $2)")
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\w+)\\[_n\\s*\\+\\s*(\\d+)\\]", "dplyr::lead($1, n = $2)")
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\w+)\\[_n\\]", "$1")

  # Handle _n and _N.
  # Convert to numeric to match Stata's default float storage for integers.
  r_expr = stringi::stri_replace_all_regex(r_expr, "\\b_n\\b", "as.numeric(dplyr::row_number())")
  r_expr = stringi::stri_replace_all_regex(r_expr, "\\b_N\\b", "as.numeric(dplyr::n())")


  # Step 5: Iteratively translate Stata functions (e.g., cond(), round(), log(), etc.)
  # This loop handles nested function calls by repeatedly applying transformations.
  old_r_expr = ""
  while (r_expr != old_r_expr) {
    old_r_expr = r_expr

    # Apply more specific regexes first if there are overlaps (e.g., round(x,y) before round(x))
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bcond\\(([^,]+),([^,]+),([^)]+)\\)", "dplyr::if_else($1, $2, $3)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bround\\(([^,]+),([^)]+)\\)", "sfun_stata_round($1, $2)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bround\\(([^)]+)\\)", "sfun_stata_round($1, 1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bmod\\(([^,]+),([^)]+)\\)", "($1 %% $2)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bmissing\\(([^)]+)\\)", "sfun_missing($1)") # Changed to sfun_missing
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\blog\\(([^)]+)\\)", "log($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bsqrt\\(([^)]+)\\)", "sqrt($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bint\\(([^)]+)\\)", "trunc($1)") # Stata int() truncates

    # String functions (using stringi or custom helpers)
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstrtrim\\(([^)]+)\\)", "stringi::stri_trim_right($1)") # Corrected for Stata's strtrim
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstritrim\\(([^)]+)\\)", "sfun_stritrim($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\blower\\(([^)]+)\\)", "stringi::stri_trans_tolower($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bupper\\(([^)]+)\\)", "stringi::stri_trans_toupper($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bsubstr\\(([^,]+),([^,]+),([^)]+)\\)", "stringi::stri_sub($1, from = $2, length = $3)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bsubinstr\\(([^,]+),([^,]+),([^,]+),([^)]+)\\)", "sfun_subinstr($1, $2, $3, $4)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstrpos\\(([^,]+),([^)]+)\\)", "sfun_strpos($1, $2)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\blength\\(([^)]+)\\)", "stringi::stri_length($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstrlen\\(([^)]+)\\)", "stringi::stri_length($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstring\\(([^)]+)\\)", "sfun_string($1)") # CHANGED HERE
    # Random number generator functions
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bruniform\\(\\)", "stats::runif(as.numeric(dplyr::n()))") # Stata runiform()
    # Date functions
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bdate\\(([^,]+),([^,]+),([^)]+)\\)", "sfun_stata_date($1, $2, $3)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bdate\\(([^,]+),([^)]+)\\)", "sfun_stata_date($1, $2)")
    # NEW: mdy() function
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bmdy\\(([^,]+),([^,]+),([^)]+)\\)", "sfun_stata_mdy($1, $2, $3)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\byear\\(([^)]+)\\)", "as.numeric(format(as.Date($1, origin = '1960-01-01'), '%Y'))") # Stata date epoch is 1960-01-01
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bmonth\\(([^)]+)\\)", "sfun_month($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bday\\(([^)]+)\\)", "sfun_day($1)") # Use sfun_day
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bqofd\\(([^)]+)\\)", "sfun_qofd($1)") # Use sfun_qofd
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bdow\\(([^)]+)\\)", "sfun_dow($1)") # NEW: Use sfun_dow
  }

  # Step 6: Translate Stata '+' operator to sfun_stata_add for polymorphic behavior
  # This needs to be applied iteratively until no more '+' signs (that are not part of comparison operators) exist.
  # The regex for operands must be robust to capture complete R expressions, including nested function calls.

  # Define a robust pattern for an R expression unit that can be an operand.
  # This pattern matches:
  # 1. A variable name (starts with letter/underscore, then alphanumeric/underscore/dot)
  # 2. A numeric literal
  # 3. A string literal (single or double quoted)
  # 4. A function call (e.g., `log(x)`, `sfun_stata_add(a, b)`)
  operand_regex = paste0(
      "(?:",
      "[a-zA-Z_][a-zA-Z0-9_.]*|", # Variable name
      "\\d+(?:\\.\\d+)?|",       # Numeric literal
      "\"[^\"]*\"|'[^']*'|",     # String literal (double or single quoted)
      "\\b\\w+\\((?:[^()]|\\b\\w+\\([^()]*\\))*\\)", # Function call (allowing one level of nested simple function calls)
      ")"
  )

  old_r_expr_add = ""
  while (r_expr != old_r_expr_add) {
    old_r_expr_add = r_expr
    # Regex: Match 'operand' + 'operand', where an operand is defined by `operand_regex`.
    # It ensures that `+` is treated as an operator, not part of `==` or `!=`.
    r_expr = stringi::stri_replace_all_regex(r_expr,
                                           paste0("(", operand_regex, ")\\s*(?<![<>=!~])\\+\\s*(?!\\s*\\+|\\s*=\\s*)(", operand_regex, ")"),
                                           "sfun_stata_add($1, $2)")
  }

  # Defensive check: if r_expr became empty or NA for some reason (should not happen for valid input)
  if (is.na(r_expr) || r_expr == "") {
      warning(paste0("R expression became NA or empty during translation. Original Stata expression: '", stata_expr, "'"))
      return(NA_character_)
  }

  return(r_expr)
}
```
!END_CHANGE_FILE R/stata_expression_translator.R

!CHANGE_FILE R/stata_type_utils.R
```R
# Helper function to determine if a Stata expression is likely to produce a string result in R.
is_stata_expr_string_type = function(stata_expr) {
  restore.point("is_stata_expr_string_type")
  if (is.na(stata_expr)) return(FALSE)
  # Check for common Stata string functions
  # Note: `string()` converts numeric to string, so it implies a string output.
  string_funcs = c("strtrim", "stritrim", "lower", "upper", "substr", "subinstr", "strpos", "length", "strlen", "string")
  if (any(sapply(string_funcs, function(f) stringi::stri_detect_fixed(stata_expr, paste0(f, "("))))) {
    return(TRUE)
  }
  # Check for string literals (quoted strings)
  if (stringi::stri_startswith_fixed(stata_expr, '"') && stringi::stri_endswith_fixed(stata_expr, '"')) {
    return(TRUE)
  }
  if (stringi::stri_startswith_fixed(stata_expr, "'") && stringi::stri_endswith_fixed(stata_expr, "'")) {
    return(TRUE)
  }
  FALSE
}
```
!END_CHANGE_FILE R/stata_type_utils.R
