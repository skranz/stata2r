Here are the changes to address the reported test failures and improve the robustness of the Stata to R translation.

The main issues fixed are:
1.  **`t_merge.R`**: The `indicator_col_name` variable was undefined. It is now defined as a local temporary variable within the function. Additionally, the temporary "hack" for `1:1` merge to assume `full_join` has been removed, as Stata's default `merge 1:1` behavior is typically a `left_join` unless `keep(all)` is specified. This adheres to the instruction of not adding hacks for specific test cases.
2.  **`t_recode.R`**: The `final_r_var_type_is_string` and `final_r_var_type_is_labelled_numeric` variables were not correctly propagated or defined. They are now correctly assigned based on the determined target variable type. The logic for constructing the `haven::labelled` label map has also been refined to correctly handle duplicate values in recode rules.

!CHANGE_FILE R/t_append.R
```R
# Translate Stata 'append' command
# Stata: append using filename [, options]

t_append = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_append") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse `using filename` and options
  # Pattern: ^\s*using\s+([^,\s]+)(?:,\\s*(.*))?$
  # G1: filename (can be quoted or macro), G2: options

  append_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")

  if (is.na(append_match[1,1])) {
    return(paste0("# Failed to parse append command: ", rest_of_cmd))
  }

  raw_filename_token = stringi::stri_trim_both(append_match[1,2])
  options_str = stringi::stri_trim_both(append_match[1,3]) # NA if no options

  # Resolve the `using filename` - can be a path string or a macro
  # Changed default_base_dir_var to "working_dir" for consistency with Stata's default file paths
  using_source_r_expr = resolve_stata_filename(raw_filename_token, cmd_df, line_num, default_base_dir_var = "working_dir")

  # Stata append requires variable names to match or be harmonized.
  # dplyr::bind_rows matches columns by name. Differences are filled with NA. This is similar to Stata.
  # Options like `force` (append even if variable types don't match) are not handled.

  # Using dplyr::bind_rows instead of collapse::fbind (due to reported "not exported" error)
  r_code_str = paste0("data = dplyr::bind_rows(data, haven::read_dta(", using_source_r_expr, "))")

  # Add comment about options if any were present but not handled
  if (!is.na(options_str) && options_str != "") {
       r_code_str = paste0(r_code_str, paste0(" # Options ignored: ", options_str))
  }


  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_append.R

!CHANGE_FILE R/t_collapse.R
```R
# Translate Stata 'collapse' command
# Stata: collapse (stat) varlist [name=expr ...] [weight] [if] [in] [, options]
# Often: collapse (stat) varlist, by(groupvars)

t_collapse = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_collapse")
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Split into aggregate definitions part and options part
  # Pattern: ^\s*(.*?)(?:,\\s*(.*))?$
  # G1: aggregate_part, G2: options_part
  parts = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(.*?)(?:,\\s*(.*))?$")
  aggregate_part = stringi::stri_trim_both(parts[1,2])
  options_part = stringi::stri_trim_both(parts[1,3]) # NA if no options

  # Separate potential if/in from aggregate definitions
  stata_if_in_cond = NA_character_
  # Look for `if` or `in` immediately followed by a space in the part before the first comma
  if_in_match = stringi::stri_match_first_regex(aggregate_part, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      # Remove the if/in part from aggregate_part
      aggregate_part = stringi::stri_replace_last_regex(aggregate_part, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      aggregate_part = stringi::stri_trim_both(aggregate_part)
  }


  # Parse aggregate definitions: "(stat) var [name=expr ...] (stat) var [name=expr ...] ..."
  # Updated regex to correctly capture expressions for source and target variables.
  # Group 1: stat name (e.g., mean, sum)
  # Group 2: target variable name (e.g., i, total_i_sum)
  # Group 3: source expression (e.g., i, i+1) - optional, for `name=expr` syntax
  # Changed (?:\\s*=\\s*(.*?))? to (?:\\s*=\\s*([^,]+))? for more robust capture of expressions.
  aggregate_matches = stringi::stri_match_all_regex(aggregate_part, "\\(([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*([a-zA-Z_][a-zA-Z0-9_.]*)(?:\\s*=\\s*([^,]+))?")[[1]]

  if (NROW(aggregate_matches) == 0) {
    return(paste0("# Failed to parse collapse aggregate definitions: ", aggregate_part))
  }

  # Parse options part for `by()`
  by_vars_list_unquoted = character(0)
  if (!is.na(options_part)) {
    by_opt_match = stringi::stri_match_first_regex(options_part, "\\bby\\s*\\(([^)]+)\\)")
    if (!is.na(by_opt_match[1,1])) {
      by_vars_collapse_str = stringi::stri_trim_both(by_opt_match[1,2])
      by_vars_list_unquoted = stringi::stri_split_regex(by_vars_collapse_str, "\\s+")[[1]]
      by_vars_list_unquoted = by_vars_list_unquoted[by_vars_list_unquoted != ""]
    }
  }

  # Translate the if/in condition for subsetting *before* collapse
  r_code_lines = c()
  data_source_for_collapse = "data"

  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, cmd_obj$line, cmd_df, context = list(is_by_group = FALSE))
      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for collapse: ", stata_if_in_cond))
      }
      # Using collapse::fsubset. r_subset_cond is a string representing the logical condition.
      r_code_lines = c(r_code_lines, paste0("data = collapse::fsubset(data, ", r_subset_cond, ")"))
      # data_source_for_collapse remains "data" as it's modified in place by fsubset
  }


  # Build the fsummarise expressions
  aggregate_exprs = character(NROW(aggregate_matches))
  new_vars_created = character(NROW(aggregate_matches))
  for (j in 1:NROW(aggregate_matches)) {
    stat_from_regex = aggregate_matches[j, 2] # Group 1: stat name
    actual_stata_target_var_name = stringi::stri_trim_both(aggregate_matches[j, 3]) # Group 2: target var name
    actual_stata_source_expr = stringi::stri_trim_both(aggregate_matches[j, 4]) # Group 3: source expression (optional)

    if (is.na(actual_stata_source_expr) || actual_stata_source_expr == "") {
      # If no explicit source expression (e.g., `(mean) myvar`), the source is the target var itself
      actual_stata_source_expr = actual_stata_target_var_name
    }
    
    new_vars_created[j] = actual_stata_target_var_name

    r_source_expr_translated = translate_stata_expression_with_r_values(actual_stata_source_expr, cmd_obj$line, cmd_df, context)
     if (is.na(r_source_expr_translated) || r_source_expr_translated == "") {
         return(paste0("# Failed to translate source expression '", actual_stata_source_expr, "' for collapse stat '", stat_from_regex, "'"))
     }

    # Map Stata stats to collapse functions
    collapse_func_expr = switch(stat_from_regex,
      "mean" = paste0("collapse::fmean(", r_source_expr_translated, ", na.rm = TRUE)"),
      "sum" = paste0("collapse::fsum(", r_source_expr_translated, ", na.rm = TRUE)"),
      "count" = paste0("collapse::fN(", r_source_expr_translated, ", non.na = TRUE)"), # Counts non-missing values of var/expr
      "N" = "NROW(.)", # N is number of observations in group. NROW(.) in fsummarise.
      "first" = paste0("collapse::ffirst(", r_source_expr_translated, ")"), # na.rm = TRUE by default
      "last" = paste0("collapse::flast(", r_source_expr_translated, ")"),   # na.rm = TRUE by default
      "min" = paste0("collapse::fmin(", r_source_expr_translated, ", na.rm = TRUE)"),
      "max" = paste0("collapse::fmax(", r_source_expr_translated, ", na.rm = TRUE)"),
      "median" = paste0("collapse::fmedian(", r_source_expr_translated, ", na.rm = TRUE)"),
      "sd" = paste0("collapse::fsd(", r_source_expr_translated, ", na.rm = TRUE)"),
      "p1" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.01, na.rm = TRUE)"),
      "p5" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.05, na.rm = TRUE)"),
      "p10" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.10, na.rm = TRUE)"),
      "p25" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.01, na.rm = TRUE)"),
      "p75" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.75, na.rm = TRUE)"),
      "p90" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.90, na.rm = TRUE)"),
      "p95" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.95, na.rm = TRUE)"),
      "p99" = paste0("collapse::fquantile(", r_source_expr_translated, ", probs = 0.99, na.rm = TRUE)"),
      NULL
    )

    if (is.null(collapse_func_expr)) {
        return(paste0("# Collapse stat '", stat_from_regex, "' not yet implemented for collapse package translation."))
    }

    r_new_var_name = actual_stata_target_var_name
    aggregate_exprs[j] = paste0("`",r_new_var_name, "` = ", collapse_func_expr) # Backticks for safety
  }

  aggregate_exprs_str = paste(aggregate_exprs, collapse = ",\n  ")

  # Build the main data manipulation pipe using collapse
  main_pipe_parts = c("data")
  if (length(by_vars_list_unquoted) > 0) {
    by_vars_fgroup_by_str = paste(by_vars_list_unquoted, collapse = ", ")
    main_pipe_parts = c(main_pipe_parts,
                       paste0("collapse::fgroup_by(", by_vars_fgroup_by_str, ")"))
  }

  main_pipe_parts = c(main_pipe_parts,
                     paste0("collapse::fsummarise(", aggregate_exprs_str, ")"))

  if (length(by_vars_list_unquoted) > 0) {
    main_pipe_parts = c(main_pipe_parts, "collapse::fungroup()")
  }

  # Construct the R code line for data assignment
  # Need to handle if data was already subsetted using `r_code_lines`
  if (length(r_code_lines) > 0) { # This means data = collapse::fsubset(...) was already added
     # The pipe starts from the result of fsubset, which is already assigned to 'data'
     r_code_lines = c(r_code_lines, paste0("data = ", paste(main_pipe_parts, collapse = " %>% \n  ")))
  } else {
     # Pipe starts from original 'data'
     r_code_lines = c(r_code_lines, paste0("data = ", paste(main_pipe_parts, collapse = " %>% \n  ")))
  }


  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about options if any were present but not handled (excluding by)
  options_str_cleaned = options_part
  if (!is.na(options_str_cleaned)) {
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bby\\s*\\([^)]+\\)", "")
      options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
      options_str_cleaned = stringi::stri_trim_both(options_str_cleaned)
  }

  if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
       r_code_str = paste0(r_code_str, paste0("\n# Other options ignored: ", options_str_cleaned))
  }

  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_collapse.R

!CHANGE_FILE R/t_decode.R
```R
# Translate Stata 'decode' command
# Stata: decode varname [if] [in] , gen(newvar) [options]
# Converts numeric varname with value labels into string newvar.

t_decode = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_decode") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varname, if/in, options (especially gen())
  # Pattern: `varname [if] [in] , options`

  varname_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Find if/in first
  if_in_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rest_no_if_in = stringi::stri_replace_last_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rest_no_if_in = stringi::stri_trim_both(rest_no_if_in)
  } else {
      rest_no_if_in = rest_of_cmd_trimmed
  }

   # Find options
  options_match = stringi::stri_match_first_regex(rest_no_if_in, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      varname_str = stringi::stri_replace_last_regex(rest_no_if_in, ",\\s*(.*)$", "")
      varname_str = stringi::stri_trim_both(varname_str)
  } else {
      # This case implies `decode varname` without `, gen(newvar)` which is invalid for decode.
      # Stata syntax is `decode varname, gen(newvar)`. The comma is mandatory before options.
      # So, if no comma, there are no options, and thus no gen().
      # This means `gen_var` will be NA, and the error will be thrown later.
      return(paste0("# decode command requires gen() in options: ", rest_of_cmd))
  }

   if (is.na(varname_str) || varname_str == "") {
       return(paste0("# decode command requires varname: ", rest_of_cmd))
   }

  # Parse options, specifically `gen()`
  gen_var = NA_character_
  if (!is.na(options_str)) {
      # Modified regex to accept 'gen' or 'generate'
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\b(?:gen|generate)\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars_str = stringi::stri_trim_both(gen_opt_match[1,2])
           gen_vars_list = stringi::stri_split_regex(gen_vars_str, "\\s+")[[1]]
           gen_var = gen_vars_list[1] # decode generates a single variable
       }
  }

  if (is.na(gen_var)) {
      return(paste0("# decode requires gen() option: ", rest_of_cmd))
  }

  # Translate if/in condition
  r_if_in_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
       # Context for if/in is global, not by_group specific for resolution, but _n/_N can be tricky
       r_if_in_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group=FALSE))
       if (is.na(r_if_in_cond) || r_if_in_cond == "") {
           return(paste0("# Failed to translate if/in condition for decode: ", stata_if_in_cond))
       }
  }

  # Temporary variable names
  decoded_values_tmp_var = paste0("stata_tmp_decoded_values_L", cmd_obj$line)
  satisfies_cond_tmp_var = paste0("stata_tmp_satisfies_cond_L", cmd_obj$line)
  original_values_tmp_var = paste0("stata_tmp_original_values_L", cmd_obj$line) # Added for robustness

   r_code_lines = c(
      paste0("data = dplyr::mutate(data, `", gen_var, "` = NA_character_)")
   )

   r_code_lines = c(r_code_lines,
      paste0("## Decode values using haven::as_factor"),
      paste0(original_values_tmp_var, " = with(data, data$`", varname_str, "`)"), # Store original values
      # Calculate decoded values. haven::as_factor converts unlabelled values to NA.
      # Corrected: removed `levels = 'labels'`
      paste0(decoded_values_tmp_var, " = as.character(haven::as_factor(", original_values_tmp_var, "))"),
      # Stata's decode for unlabelled numeric values converts them to their string representation.
      # And missing values (NA) are converted to empty string "".
      paste0(decoded_values_tmp_var, " = dplyr::if_else(is.na(", decoded_values_tmp_var, "), ",
                                    "dplyr::if_else(is.na(", original_values_tmp_var, "), \"\", as.character(", original_values_tmp_var, ")), ",
                                    decoded_values_tmp_var, ")")
   )

  # Apply the if/in condition for replacement
  if (!is.na(r_if_in_cond) && r_if_in_cond != "") {
       r_code_lines = c(r_code_lines,
           paste0("## Calculate condition flag using with(data, ...)"),
           paste0(satisfies_cond_tmp_var, " = with(data, ", r_if_in_cond, ")"),
           paste0("data = dplyr::mutate(data, `", gen_var, "` = dplyr::if_else(", satisfies_cond_tmp_var, ", ", decoded_values_tmp_var, ", `", gen_var, "`))"),
           paste0("rm(", satisfies_cond_tmp_var, ")")
       )
  } else {
      r_code_lines = c(r_code_lines,
           paste0("data = dplyr::mutate(data, `", gen_var, "` = ", decoded_values_tmp_var, ")")
      )
  }

  r_code_lines = c(r_code_lines, paste0("rm(", decoded_values_tmp_var, ", ", original_values_tmp_var, ")"))

  r_code_str = paste(r_code_lines, collapse="\n")

   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\b(?:gen|generate)\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }

  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_decode.R

!CHANGE_FILE R/t_destring.R
```R
# Translate Stata 'destring' command
# Stata: destring varlist [if] [in] , {generate(newvarlist) | replace} [options]
# Converts string variables into numeric variables.

t_destring = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_destring") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varlist, if/in, options (generate() or replace)
  # Pattern: `varlist [if] [in] , options`

  varlist_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Find if/in first
  if_in_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rest_no_if_in = stringi::stri_replace_last_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rest_no_if_in = stringi::stri_trim_both(rest_no_if_in)
  } else {
      rest_no_if_in = rest_of_cmd_trimmed
  }

   # Find options (required)
  options_match = stringi::stri_match_first_regex(rest_no_if_in, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      varlist_str = stringi::stri_replace_last_regex(rest_no_if_in, ",\\s*(.*)$", "")
      varlist_str = stringi::stri_trim_both(varlist_str)
  } else {
      return(paste0("# destring command requires options (, gen() or , replace): ", rest_of_cmd))
  }

   if (is.na(varlist_str) || varlist_str == "") {
       return(paste0("# destring command requires varlist: ", rest_of_cmd))
   }

  vars_to_destring = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_destring = vars_to_destring[vars_to_destring != ""]
   if (length(vars_to_destring) == 0) {
       return(paste0("# destring command requires non-empty varlist: ", rest_of_cmd))
   }


  # Parse options, specifically `generate()` or `replace`
  is_replace = stringi::stri_detect_fixed(options_str, "replace")
  gen_vars = NA_character_
  if (!is_replace) {
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgenerate\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars = stringi::stri_trim_both(gen_opt_match[1,2])
       }
  }

  new_vars = NULL
  if (!is_replace) {
      if (is.na(gen_vars)) {
           return(paste0("# destring requires generate() option or replace option: ", rest_of_cmd))
      }
      new_vars = stringi::stri_split_regex(gen_vars, "\\s+")[[1]]
      new_vars = new_vars[new_vars != ""]
      if (length(new_vars) != length(vars_to_destring)) {
          return(paste0("# destring generate() option requires same number of new variables as old variables."))
      }
  } else {
      # If replace option, new vars are the same as old vars.
      new_vars = vars_to_destring
  }


  # Translate if/in condition
  r_if_in_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
       r_if_in_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group=FALSE))
       if (is.na(r_if_in_cond) || r_if_in_cond == "") {
           return(paste0("# Failed to translate if/in condition for destring: ", stata_if_in_cond))
       }
  }

  # R equivalent: readr::parse_number() or as.numeric()
  # readr::parse_number is better at handling non-numeric parts and commas/$, results in NA on failure.
  # as.numeric() often results in warnings/errors or NA on failure.
  # Stata destring option `ignore()` can specify characters to ignore. `force` allows unconvertible values to become missing.
  # `readr::parse_number` handles some of this.

  mutate_exprs = character(length(vars_to_destring))
  for (k in seq_along(vars_to_destring)) {
      old_var = vars_to_destring[k]
      new_var = new_vars[k]
      source_var_r = old_var # R variable name for the source column

      # Calculate destrung values
      # Using readr::parse_number
      destrung_value_expr = paste0("readr::parse_number(as.character(", source_var_r, "))")
      # as.character needed in case the variable is factor/labelled etc.

      # Apply the if/in condition for replacement
      if (!is.na(r_if_in_cond) && r_if_in_cond != "") {
          # For rows meeting condition, use destrung value. Otherwise, keep original (or NA if new var).
           if (is_replace) {
               # Replace in place: use destrung if condition, old value otherwise
               final_value_expr = paste0("dplyr::if_else(dplyr::coalesce(", r_if_in_cond, ", FALSE), ", destrung_value_expr, ", `", source_var_r, "`)")
           } else {
               # Generate new var: use destrung if condition, NA otherwise
               final_value_expr = paste0("dplyr::if_else(dplyr::coalesce(", r_if_in_cond, ", FALSE), ", destrung_value_expr, ", NA_real_)") # Assuming numeric result
           }
      } else {
          # Apply to all rows
           final_value_expr = destrung_value_expr
      }

      mutate_exprs[k] = paste0("`", new_var, "` = ", final_value_expr)
  }

   # Combine mutate expressions
  mutate_exprs_str = paste(mutate_exprs, collapse = ",\n  ")

  # Build the final R code using dplyr::mutate
  r_code_lines = c(paste0("data = dplyr::mutate(data, ", mutate_exprs_str, ")")) # Changed to dplyr::mutate


  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about options if any were present but not handled (excluding generate/replace)
   options_str_cleaned = options_str
   # Remove generate() or replace from options string
   if (is_replace) {
       options_str_cleaned = stringi::stri_replace_first_fixed(options_str_cleaned, "replace", "")
   } else {
       options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bgenerate\\s*\\([^)]+\\)", "")
   }
   options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ",")) # Clean up multiple commas
   options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma


   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }


  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_destring.R

!CHANGE_FILE R/t_drop.R
```R
# Translate Stata 'drop' command
# Can be `drop varlist` or `drop if condition` or `drop in range`

t_drop = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_drop") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  is_if_drop = stringi::stri_startswith_fixed(rest_of_cmd_trimmed, "if ")
  is_in_drop = stringi::stri_startswith_fixed(rest_of_cmd_trimmed, "in ")

  if (is_if_drop) {
    # drop if condition
    stata_if_cond = stringi::stri_sub(rest_of_cmd_trimmed, from = 4)
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context)
    # Using dplyr::filter
    r_code_str = paste0("data = dplyr::filter(data, !(", r_if_cond, "))")
  } else if (is_in_drop) {
    # drop in range
    range_str = stringi::stri_sub(rest_of_cmd_trimmed, from = 4)
    range_match = stringi::stri_match_first_regex(range_str, "^(\\d+)(?:/(\\d+))?$")
    if (!is.na(range_match[1,1])) {
      start_row = as.integer(range_match[1,2])
      end_row = range_match[1,3]
      if (is.na(end_row)) {
        slice_expr = paste0("-",start_row) # Drop single row
      } else {
        slice_expr = paste0("-(", start_row, ":", as.integer(end_row), ")") # Drop range
      }
      # Using dplyr::slice
      r_code_str = paste0("data = dplyr::slice(data, ", slice_expr, ")")
    } else {
      r_code_str = paste0("# drop in range '", range_str, "' not fully translated (f/l specifiers).")
    }
  } else {
    # drop varlist
    vars_to_drop = stringi::stri_split_regex(rest_of_cmd_trimmed, "\\s+")[[1]]
    vars_to_drop = vars_to_drop[vars_to_drop != ""]

    if (length(vars_to_drop) == 0) {
      return("# drop command with no variables specified.")
    }
    # Using dplyr::select
    r_code_str = paste0("data = dplyr::select(data, -dplyr::any_of(c('", paste(vars_to_drop, collapse="','"), "')))")
  }

  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_drop.R

!CHANGE_FILE R/t_duplicates.R
```R
# Translate Stata 'duplicates' command
# Stata: duplicates drop [varlist] [if] [in] [, options]
# Stata: duplicates tag varlist [if] [in] [, options] gen(newvar)
# Stata: duplicates list [varlist] [if] [in] [, options]

t_duplicates = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_duplicates") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse subcommand (drop, tag, list)
  parts_subcmd = stringi::stri_split_regex(rest_of_cmd_trimmed, "\\s+", n=2)[[1]]
  subcommand = stringi::stri_trim_both(parts_subcmd[1])
  rest_after_subcmd = if(length(parts_subcmd) > 1) stringi::stri_trim_both(parts_subcmd[2]) else NA_character_

  if (is.na(subcommand) || !(subcommand %in% c("drop", "tag", "list"))) {
      return(paste0("# Failed to parse duplicates subcommand (drop, tag, or list required): ", rest_of_cmd))
  }

  varlist_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  if(!is.na(rest_after_subcmd)){
    if_in_match = stringi::stri_match_first_regex(rest_after_subcmd, "\\s+(?:if\\s+|in\\s+)(.*)$")
    if(!is.na(if_in_match[1,1])) {
        stata_if_in_cond = if_in_match[1,2]
        rest_after_subcmd_no_if_in = stringi::stri_replace_last_regex(rest_after_subcmd, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
        rest_after_subcmd_no_if_in = stringi::stri_trim_both(rest_after_subcmd_no_if_in)
    } else {
        rest_after_subcmd_no_if_in = rest_after_subcmd
    }

    options_match = stringi::stri_match_first_regex(rest_after_subcmd_no_if_in, ",\\s*(.*)$")
    if (!is.na(options_match[1,1])) {
        options_str = stringi::stri_trim_both(options_match[1,2])
        varlist_str = stringi::stri_replace_last_regex(rest_after_subcmd_no_if_in, ",\\s*(.*)$", "")
        varlist_str = stringi::stri_trim_both(varlist_str)
    } else {
        varlist_str = rest_after_subcmd_no_if_in
    }
  }

  vars_for_duplicates = NA_character_
  if (!is.na(varlist_str) && varlist_str != "") {
      vars_for_duplicates_list = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
      vars_for_duplicates_list = vars_for_duplicates_list[vars_for_duplicates_list != ""]
       if (length(vars_for_duplicates_list) > 0) {
           vars_for_duplicates = paste0('c("', paste(vars_for_duplicates_list, collapse = '", "'), '")')
       }
  }

  r_subset_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for duplicates: ", stata_if_in_cond))
      }
  }

  r_code_lines = c()
  # Temporary variable names
  is_duplicate_tmp_var = paste0("stata_tmp_is_duplicate_L", cmd_obj$line)
  satisfies_cond_tmp_var = paste0("stata_tmp_satisfies_cond_L", cmd_obj$line)
  is_first_tmp_var = paste0("stata_tmp_is_first_L", cmd_obj$line)
  data_duplicates_tmp_var = paste0("stata_tmp_data_duplicates_L", cmd_obj$line)


  if (subcommand == "drop") {
      # For filter, NA in condition is treated as FALSE, which matches Stata's behavior.
      cond_vector_expr_with_data = if (!is.na(r_subset_cond) && r_subset_cond != "") paste0("with(data, ", r_subset_cond, ")") else "TRUE"

      comment_vars_part = if(is.na(vars_for_duplicates)) "all variables" else paste0("variables: ", varlist_str)
      if (is.na(vars_for_duplicates)) {
          is_duplicate_expr = "base::duplicated(data, fromLast = FALSE)"
      } else {
           is_duplicate_expr = paste0("base::duplicated(data[, ", vars_for_duplicates, ", drop = FALSE], fromLast = FALSE)")
      }

      r_code_lines = c(
          r_code_lines,
          paste0("## Calculate duplicate flag based on ", comment_vars_part),
          paste0(is_duplicate_tmp_var, " = ", is_duplicate_expr),
          paste0("## Calculate condition flag"),
          paste0(satisfies_cond_tmp_var, " = ", cond_vector_expr_with_data),
          paste0("data = dplyr::filter(data, !(", is_duplicate_tmp_var, " & ", satisfies_cond_tmp_var, "))"),
          paste0("rm(", is_duplicate_tmp_var, ", ", satisfies_cond_tmp_var, ")")
      )

  } else if (subcommand == "tag") {
      gen_var = NA_character_
      if (!is.na(options_str)) {
         gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgen\\s*\\(([^)]+)\\)")
         if (!is.na(gen_opt_match[1,1])) {
             gen_vars_str = stringi::stri_trim_both(gen_opt_match[1,2])
             gen_vars_list = stringi::stri_split_regex(gen_vars_str, "\\s+")[[1]]
             gen_var = gen_vars_list[1]
         }
      }

      if (is.na(gen_var)) {
          return(paste0("# duplicates tag requires gen() option: ", rest_of_cmd))
      }

      # Stata `if` condition treats missing as false.
      cond_vector_expr_with_data = if (!is.na(r_subset_cond) && r_subset_cond != "") paste0("dplyr::coalesce(with(data, ", r_subset_cond, "), FALSE)") else "TRUE"
      comment_vars_part = if(is.na(vars_for_duplicates)) "all variables" else paste0("variables: ", varlist_str)

       if (is.na(vars_for_duplicates)) {
          is_first_occurrence_expr = "!base::duplicated(data, fromLast = FALSE)"
      } else {
           is_first_occurrence_expr = paste0("!base::duplicated(data[, ", vars_for_duplicates, ", drop = FALSE], fromLast = FALSE)")
      }

       r_code_lines = c(
          r_code_lines,
          paste0("## Calculate first occurrence flag based on ", comment_vars_part),
          paste0(is_first_tmp_var, " = ", is_first_occurrence_expr),
          paste0("## Calculate condition flag, treating NA as FALSE"),
          paste0(satisfies_cond_tmp_var, " = ", cond_vector_expr_with_data),
          # The if_else condition itself must treat any NA as FALSE for Stata compatibility.
          paste0("data = dplyr::mutate(data, `", gen_var, "` = dplyr::if_else(dplyr::coalesce(", is_first_tmp_var, ", FALSE) & ", satisfies_cond_tmp_var, ", 1, 0))"),
          paste0("rm(", is_first_tmp_var, ", ", satisfies_cond_tmp_var, ")")
       )

  } else if (subcommand == "list") {
       # For filter, NA in condition is treated as FALSE, which matches Stata's behavior.
       cond_vector_expr_with_data = if (!is.na(r_subset_cond) && r_subset_cond != "") paste0("with(data, ", r_subset_cond, ")") else "TRUE"
       comment_vars_part = if(is.na(vars_for_duplicates)) "all variables" else paste0("variables: ", varlist_str)

        if (is.na(vars_for_duplicates)) {
          is_duplicate_expr = "base::duplicated(data, fromLast = FALSE)"
      } else {
           is_duplicate_expr = paste0("base::duplicated(data[, ", vars_for_duplicates, ", drop = FALSE], fromLast = FALSE)")
      }

       r_code_lines = c(
          r_code_lines,
          paste0("## Calculate duplicate flag based on ", comment_vars_part),
          paste0(is_duplicate_tmp_var, " = ", is_duplicate_expr),
          paste0("## Calculate condition flag"),
          paste0(satisfies_cond_tmp_var, " = ", cond_vector_expr_with_data),
          paste0(data_duplicates_tmp_var, " = dplyr::filter(data, ", is_duplicate_tmp_var, " & ", satisfies_cond_tmp_var, ")"),
          paste0("print(", data_duplicates_tmp_var, ")"),
          paste0("rm(", is_duplicate_tmp_var, ", ", satisfies_cond_tmp_var, ", ", data_duplicates_tmp_var, ")")
       )

  } else {
      r_code_lines = c(r_code_lines, paste0("# Unknown duplicates subcommand: ", subcommand))
  }

  r_code_str = paste(r_code_lines, collapse="\n")

   options_str_cleaned = options_str
   if (subcommand == "tag" && !is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bgen\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }

  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_duplicates.R

!CHANGE_FILE R/t_egen.R
```R
t_egen = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_egen")
  # Basic parsing: newvar = function(args) [, by(groupvars)] [if condition]
  # Example: egen mean_i_grp = mean(i), by(group)
  # Example: egen total_i = total(i)
  # Example: bysort group: egen rank_i = rank(i) (Note: bysort handled by cmd_obj$is_by_prefix)

  # Remove type prefix if any (byte, int, long, float, double, str#, etc.)
  # Pattern: ^\s*(byte|int|long|float|double|str\\d+)\\s+
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^\\s*(?:byte|int|long|float|double|str\\d+)\\s+", "")

  # Re-parse rest_of_cmd_no_type looking for `newvar = fcn(args) [if cond] [, options]`
  # Split at the first `=`. Left is `newvar`. Right is `fcn(args) [if cond] [, options]`
  parts_eq = stringi::stri_split_fixed(rest_of_cmd_no_type, "=", n=2)[[1]]
  if(length(parts_eq) != 2) return(paste0("# Failed to parse egen command structure (no =): ", rest_of_cmd))

  new_var = stringi::stri_trim_both(parts_eq[1])
  right_part = stringi::stri_trim_both(parts_eq[2])

  # Split right_part at the first comma (if any) to separate function/args/if from options
  parts_comma_list = stringi::stri_split_fixed(right_part, ",", n=2)
  parts_comma = parts_comma_list[[1]]

  if(length(parts_comma) != 2) {
    func_args_if_part = stringi::stri_trim_both(parts_comma[1])
    options_str = NA_character_
  } else {
    func_args_if_part = stringi::stri_trim_both(parts_comma[1])
    options_str = stringi::stri_trim_both(parts_comma[2])
  }


  # Now parse func_args_if_part: `fcn(args) [if cond]`
  # Split at the first `(`
  parts_paren = stringi::stri_split_fixed(func_args_if_part, "(", n=2)[[1]]
  if(length(parts_paren) != 2) return(paste0("# Failed to parse egen function call: ", func_args_if_part))

  egen_func_name = stringi::stri_trim_both(parts_paren[1])
  args_and_if_part = stringi::stri_trim_both(stringi::stri_replace_last_fixed(parts_paren[2], ")", "")) # Remove trailing ')'

  # Now parse args_and_if_part: `args [if cond]` or `args [in range]`
  stata_if_cond_in_args = NA_character_
  stata_in_range_in_args = NA_character_
  egen_args_str = args_and_if_part

  # Look for `if` first
  if_match_in_args = stringi::stri_match_first_regex(egen_args_str, "\\s+if\\s+(.*)$")
   if(!is.na(if_match_in_args[1,1])) {
      stata_if_cond_in_args = if_match_in_args[1,2]
      egen_args_str = stringi::stri_replace_last_regex(egen_args_str, "\\s+if\\s+(.*)$", "")
      egen_args_str = stringi::stri_trim_both(egen_args_str)
   }

  # Check for `in`
  in_match_in_args = stringi::stri_match_first_regex(egen_args_str, "\\s+in\\s+(.*)$")
   if(!is.na(in_match_in_args[1,1])) {
      stata_in_range_in_args = if_match_in_args[1,2]
      egen_args_str = stringi::stri_replace_last_regex(egen_args_str, "\\s+in\\s+(.*)$", "")
      egen_args_str = stringi::stri_trim_both(egen_args_str)
   }

  # Now we have: new_var, egen_func_name, egen_args_str, stata_if_cond_in_args, stata_in_range_in_args, options_str

  # Translate the condition/range if it exists
  r_if_cond_in_args = NA_character_
  if (!is.na(stata_if_cond_in_args) && stata_if_cond_in_args != "") {
       # Context for _n/_N in the if condition within egen args is usually the group context (if by_prefix used)
      r_if_cond_in_args = translate_stata_expression_with_r_values(stata_if_cond_in_args, line_num, cmd_df, context)
       if (is.na(r_if_cond_in_args) || r_if_cond_in_args == "") {
           return(paste0("# Failed to translate if condition in egen args: ", stata_if_cond_in_args))
       }
  }

   r_in_range_cond_in_args = NA_character_
  if (!is.na(stata_in_range_in_args) && stata_in_range_in_args != "") {
       # Context for _n/_N etc. in range is group context if by_prefix used.
       # Stata `in f/l` in egen refers to observation numbers *within the group* if bysort prefix is used.
       # Otherwise, it refers to global observation numbers.
       # The `context$is_by_group` flag from parse_stata_command_line indicates bysort prefix.
       range_match = stringi::stri_match_first_regex(stata_in_range_in_args, "^(\\d+)(?:/(\\d+))?$")
        if (!is.na(range_match[1,1])) {
            start_row = as.integer(range_match[1,2])
            end_row = range_match[1,3]
            # Use dplyr::row_number(), as stata_expression_translator will handle _n
            row_number_r_expr = "as.numeric(dplyr::row_number())" # This will be translated based on context

            if (is.na(end_row)) {
                 r_in_range_cond_in_args = paste0(row_number_r_expr, " == ", start_row)
            } else {
                 r_in_range_cond_in_args = paste0(row_number_r_expr, " >= ", start_row, " & ", row_number_r_expr, " <= ", as.integer(end_row))
            }
        } else {
            return(paste0("# egen in range '", stata_in_range_in_args, "' not fully translated (f/l specifiers)."))
        }
  }


  # Combine if and in conditions within args if both exist
  final_r_subset_cond_in_args = NA_character_
  if (!is.na(r_if_cond_in_args) && !is.na(r_in_range_cond_in_args)) {
      final_r_subset_cond_in_args = paste0("(", r_if_cond_in_args, ") & (", r_in_range_cond_in_args, ")")
  } else if (!is.na(r_if_cond_in_args)) {
      final_r_subset_cond_in_args = r_if_cond_in_args
  } else if (!is.na(r_in_range_cond_in_args)) {
      final_r_subset_cond_in_args = r_in_range_cond_in_args
  }


  # Translate arguments (usually variable names)
  # Context for _n/_N etc. in arguments is the group context if by_prefix is used.
  r_egen_args = translate_stata_expression_with_r_values(egen_args_str, line_num, cmd_df, context)
   if (is.na(r_egen_args) || r_egen_args == "") {
        # This might be ok if the function takes no arguments e.g. egen group_id = group()
        if (egen_func_name != "group") { # group() takes implicit args from by() or option
             warning(paste0("Failed to translate egen arguments: ", egen_args_str))
        }
   }


  # Apply if/in condition within the function call if needed
  # Example: mean(x if y>0) -> mean(ifelse(y>0, x, NA), na.rm = TRUE)
  # This requires modifying r_egen_args based on final_r_subset_cond_in_args
  if (!is.na(final_r_subset_cond_in_args) && final_r_subset_cond_in_args != "") {
      # Stata's `if` condition treats NA as FALSE.
      r_egen_args_conditional = paste0("dplyr::if_else(dplyr::coalesce(", final_r_subset_cond_in_args, ", FALSE), ", r_egen_args, ", NA)")
  } else {
      r_egen_args_conditional = r_egen_args
  }

  # Determine if 'fieldstrustmissings' option is present
  is_fieldstrustmissings = !is.na(options_str) && stringi::stri_detect_fixed(options_str, "fieldstrustmissings")


  # Translate egen function into an R expression for calculation
  calc_expr = ""
  is_row_function = FALSE # Flag for functions like rowtotal, rowmean that don't use group_by

  # Switch for egen functions
  if (egen_func_name == "mean") {
    calc_expr = paste0("mean(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "total" || egen_func_name == "sum") {
    calc_expr = paste0("sum(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "count") {
    # count(exp) counts non-missing results of exp. If exp is varname, sum(!is.na(varname)).
    # If exp is complex, sum(eval(parse(text=r_egen_args_conditional)) != 0 & !is.na(eval(parse(text=r_egen_args_conditional))))
    # Assuming r_egen_args_conditional results in a numeric or logical vector
    calc_expr = paste0("sum(!is.na(", r_egen_args_conditional, "))")
  } else if (egen_func_name == "rank") {
    # Stata rank() without fieldstrustmissings returns missing for missing.
    # Stata rank() with fieldstrustmissings treats missing values as true values (usually largest) and assigns them a rank.
    # Stata's rank() uses the 'average' method for ties.
    if (is_fieldstrustmissings) {
      # Replace NA values with Inf to rank them highest.
      # Note: r_egen_args_conditional already applies if/in conditions, yielding NA for rows not meeting condition.
      # These NAs should also be treated as largest for ranking due to fieldstrustmissings.
      val_for_ranking = paste0("as.numeric(dplyr::if_else(is.na(", r_egen_args_conditional, "), Inf, ", r_egen_args_conditional, "))")
      calc_expr = paste0("as.numeric(base::rank(", val_for_ranking, ", ties.method = 'average', na.last = 'keep'))")
    } else {
      # Default Stata rank: NAs get NA ranks, and uses 'average' method for ties.
      calc_expr = paste0("as.numeric(base::rank(", r_egen_args_conditional, ", ties.method = 'average', na.last = 'keep'))")
    }
  } else if (egen_func_name == "median" || egen_func_name == "p50") {
    calc_expr = paste0("stats::median(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "sd" || egen_func_name == "std") {
    calc_expr = paste0("stats::sd(", r_egen_args_conditional, ", na.rm = TRUE)")
  } else if (egen_func_name == "group") {
    # dplyr::cur_group_id() gives integer for each group.
    calc_expr = paste0("dplyr::cur_group_id()")
  } else if (egen_func_name == "tag") {
    # Stata tag(varlist) creates 1 for first observation in a group (defined by varlist) and 0 otherwise.
    calc_expr = paste0("as.numeric(dplyr::row_number() == 1)")
  } else if (egen_func_name == "rowtotal") {
    vars_for_rowop_list = stringi::stri_split_regex(r_egen_args, "\\s+")[[1]] # Use non-conditional args here
    vars_for_rowop_list = vars_for_rowop_list[!is.na(vars_for_rowop_list) & vars_for_rowop_list != ""] # Filter empty/NA

    # Stata rowtotal treats NA as 0 *before* summing.
    # Replace NA with 0 in the selected columns before summing.
    cols_selection_expr = paste0("dplyr::select(dplyr::cur_data_all(), dplyr::all_of(c('", paste(vars_for_rowop_list, collapse="','"), "')))")
    calc_expr = paste0("base::rowSums(", cols_selection_expr, " %>% replace(is.na(.), 0), na.rm = FALSE)")
    is_row_function = TRUE
  } else if (egen_func_name == "rowmean") {
    vars_for_rowop_list = stringi::stri_split_regex(r_egen_args, "\\s+")[[1]] # Use non-conditional args here
    vars_for_rowop_list = vars_for_rowop_list[!is.na(vars_for_rowop_list) & vars_for_rowop_list != ""] # Filter empty/NA

    # Stata rowmean ignores NAs. base::rowMeans with na.rm = TRUE achieves this.
    cols_selection_expr = paste0("dplyr::select(dplyr::cur_data_all(), dplyr::all_of(c('", paste(vars_for_rowop_list, collapse="','"), "')))")
    calc_expr = paste0("base::rowMeans(", cols_selection_expr, ", na.rm = TRUE)")
    is_row_function = TRUE
  } else if (egen_func_name == "concat") {
    vars_to_concat_list = stringi::stri_split_regex(egen_args_str, "\\s+")[[1]]
    vars_to_concat_list = vars_to_concat_list[!is.na(vars_to_concat_list) & vars_to_concat_list != ""]

    if (length(vars_to_concat_list) == 0) {
      return(paste0("# egen concat() requires variables to concatenate."))
    }

    # Stata: If all variables in varlist are missing, newvar is missing. Otherwise, missing values are treated as empty strings.
    # Approach:
    # 1. Check if all input variables for a row are NA. If so, result is NA.
    # 2. Otherwise, for each variable, replace NA with "" and then concatenate.

    # Expression to check if all relevant variables in a row are NA.
    # Use data[['var_name']] for explicit column access.
    all_vars_na_check_list = paste0("is.na(data[['", vars_to_concat_list, "']])")
    all_vars_na_check_expr = paste0("(", paste0(all_vars_na_check_list, collapse = " & "), ")")

    # Arguments for stri_paste, with NAs replaced by empty strings
    stri_paste_args_with_na_empty = paste0("dplyr::if_else(is.na(as.character(data[['", vars_to_concat_list, "']])), \"\", as.character(data[['", vars_to_concat_list, "']]))", collapse = ", ")

    # Expression for the actual concatenation
    # Use na_empty = FALSE (default) because NAs are already handled.
    concat_result_expr = paste0("stringi::stri_paste(", stri_paste_args_with_na_empty, ", sep = '')")

    # Combine using if_else to handle the all-NA case (Stata concat(.,.) returns . (missing))
    calc_expr = paste0("dplyr::if_else(", all_vars_na_check_expr, ", NA_character_, ", concat_result_expr, ")")

    is_row_function = TRUE # Concatenation is inherently row-wise.
  } else {
    return(paste0("# Egen function '", egen_func_name, "' not yet implemented."))
  }

  # Combine into a mutate statement
  full_mutate_expr = paste0("`", new_var, "` = ", calc_expr)


  # Determine actual grouping variables for dplyr::group_by
  group_vars_list_bare = character(0) # Will hold just bare variable names
  if (cmd_obj$is_by_prefix) {
    if (length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1])) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[!is.na(group_vars_list) & group_vars_list != ""]
      if (length(group_vars_list) > 0) {
        group_vars_list_bare = group_vars_list # Assign just the bare names
      }
    }
  } else if (!is.na(options_str)) {
    by_opt_match = stringi::stri_match_first_regex(options_str, "\\bby\\s*\\(([^)]+)\\)")
    if (!is.na(by_opt_match[1,1])) {
      group_vars_list_bare = stringi::stri_split_regex(stringi::stri_trim_both(by_opt_match[1,2]), "\\s+")[[1]]
      group_vars_list_bare = group_vars_list_bare[!is.na(group_vars_list_bare) & group_vars_list_bare != ""]
    }
  }

  # For 'group' and 'tag' functions, the arguments also define the grouping
  if (egen_func_name %in% c("group", "tag")) {
    egen_func_args_list = stringi::stri_split_regex(egen_args_str, "\\s+")[[1]]
    egen_func_args_list = egen_func_args_list[!is.na(egen_func_args_list) & egen_func_args_list != ""]
    # Union of `by` variables and `egen` function arguments defines the group
    group_vars_list_bare = unique(c(group_vars_list_bare, egen_func_args_list))
  }


  # Determine variables for initial sorting (for `bysort` logic or for functions requiring internal sort)
  sort_vars_for_arrange = character(0)

  if (cmd_obj$is_by_prefix) {
    # Stata's `bysort` sorts by all variables in `varlist` (group + sort). This sort is permanent.
    sort_vars_for_arrange = unique(c(group_vars_list_bare, cmd_obj$by_sort_vars))
    sort_vars_for_arrange = sort_vars_for_arrange[!is.na(sort_vars_for_arrange) & sort_vars_for_arrange != ""]
  } else if (egen_func_name %in% c("rank", "group", "tag")) {
    # If not by-prefix, but it's a function sensitive to order (rank, group, tag)
    # The sort is temporary, so we will restore original order later.
    if (length(group_vars_list_bare) > 0) {
      sort_vars_for_arrange = unique(c(sort_vars_for_arrange, group_vars_list_bare))
    }
    if (egen_func_name == "rank" && !is.na(egen_args_str) && egen_args_str != "") {
      # For rank, the variable being ranked also affects the internal order for ties.
      # It's typically sorted by grouping vars, then the ranked var.
      # `egen_args_str` for rank is the variable to rank.
      sort_vars_for_arrange = unique(c(sort_vars_for_arrange, egen_args_str))
    }
    sort_vars_for_arrange = sort_vars_for_arrange[!is.na(sort_vars_for_arrange) & sort_vars_for_arrange != ""]
  }

  r_code_lines = c()
  pipe_elements = list("data") # Start the pipe with the data object

  # Add initial arrange if it's a `bysort` prefix. This is a permanent sort.
  if (cmd_obj$is_by_prefix && length(sort_vars_for_arrange) > 0) {
      arrange_vars_expr = paste0('!!!dplyr::syms(c("', paste0(sort_vars_for_arrange, collapse = '", "'), '"))')
      r_code_lines = c(r_code_lines, paste0("data = dplyr::arrange(data, ", arrange_vars_expr, ")"))
  }

  # Add arrange for `egen group/tag/rank` functions within the pipe, if not already handled by bysort prefix
  if (!cmd_obj$is_by_prefix && length(sort_vars_for_arrange) > 0 && !is_row_function) {
    pipe_elements = c(pipe_elements, "dplyr::arrange(stata2r_original_order_idx)")
  }


  # Add grouping and mutate steps
  if (length(group_vars_list_bare) > 0 && !is_row_function) {
    group_by_expr = paste0('dplyr::group_by(!!!dplyr::syms(c("', paste0(group_vars_list_bare, collapse='", "'), '")))')
    pipe_elements = c(pipe_elements, group_by_expr)
  }

  pipe_elements = c(pipe_elements, paste0("dplyr::mutate(", full_mutate_expr, ")"))

  if (length(group_vars_list_bare) > 0 && !is_row_function) {
    pipe_elements = c(pipe_elements, "dplyr::ungroup()")
  }

  # Restore original order if it was a temporary sort for egen functions without bysort prefix
  # This section is now handled by the `arrange` added *before* the grouping, if `!is_row_function`.
  # For row functions, no sort is needed for the calculation, so no re-arrange needed.
  # If a temporary sort was explicitly added (e.g., for `rank`, `group`, `tag`), and it was not a bysort prefix,
  # the `arrange(stata2r_original_order_idx)` will restore the order.
  # The logic for `arrange` within the pipe for `!is_row_function` and `!cmd_obj$is_by_prefix` already handles this.
  # No extra `dplyr::arrange(stata2r_original_order_idx)` needed here.


  r_code_lines = c(r_code_lines, paste0("data = ", paste(pipe_elements, collapse = " %>% \n  ")))

   # Add comment about options if any were present but not handled (excluding by)
   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bby\\s*\\([^)]+\\)", "")
        # Remove fieldstrustmissings from the options string if it was present
        options_str_cleaned = stringi::stri_replace_first_fixed(options_str_cleaned, "fieldstrustmissings", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ",")) # Clean up multiple commas
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_lines = c(r_code_lines, paste0(" # Other options ignored: ", options_str_cleaned))
   }


  return(paste(r_code_lines, collapse="\n"))
}

```
!END_CHANGE_FILE R/t_egen.R

!CHANGE_FILE R/t_encode.R
```R
# Translate Stata 'encode' command
# Stata: encode varname [if] [in] , gen(newvar) [options]
# Converts string varname into numeric newvar with value labels.

t_encode = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_encode")
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varname, if/in, options (especially gen())
  varname_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Find if/in first
  if_in_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rest_no_if_in = stringi::stri_replace_last_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rest_no_if_in = stringi::stri_trim_both(rest_no_if_in)
  } else {
      rest_no_if_in = rest_of_cmd_trimmed
  }

   # Find options (which contain gen())
  options_match = stringi::stri_match_first_regex(rest_no_if_in, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      varname_str = stringi::stri_replace_last_regex(rest_no_if_in, ",\\s*(.*)$", "")
      varname_str = stringi::stri_trim_both(varname_str)
  } else {
      # This case implies `encode varname` without `, gen(newvar)` which is invalid for encode.
      # Stata syntax is `encode varname, gen(newvar)`. The comma is mandatory before options.
      # So, if no comma, there are no options, and thus no gen().
      # This means `gen_var` will be NA, and the error will be thrown later.
      return(paste0("# encode command requires gen() in options: ", rest_of_cmd))
  }

   if (is.na(varname_str) || varname_str == "") {
       return(paste0("# encode command requires varname: ", rest_of_cmd))
   }

  # Parse options, specifically `gen()` or `generate()`
  gen_var = NA_character_
  if (!is.na(options_str)) {
      # Modified regex to accept 'gen' or 'generate'
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\b(?:gen|generate)\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars_str = stringi::stri_trim_both(gen_opt_match[1,2])
           gen_vars_list = stringi::stri_split_regex(gen_vars_str, "\\s+")[[1]]
           gen_var = gen_vars_list[1] # encode generates a single variable
       }
  }

  if (is.na(gen_var)) {
      return(paste0("# encode requires gen() option: ", rest_of_cmd))
  }

  # Translate if/in condition
  r_if_in_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
       r_if_in_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group=FALSE))
       if (is.na(r_if_in_cond) || r_if_in_cond == "") {
           return(paste0("# Failed to translate if/in condition for encode: ", stata_if_in_cond))
       }
  }

  # Temporary variable names for the fully calculated encoded vector and condition
  encoded_values_full_tmp_var = paste0("stata_tmp_encoded_full_L", cmd_obj$line)
  satisfies_cond_tmp_var = paste0("stata_tmp_encode_cond_L", cmd_obj$line)

  r_code_lines = c()

  # Initialize the new column as an integer vector. Labels will be applied by label values.
  r_code_lines = c(r_code_lines,
    paste0("data = dplyr::mutate(data, `", gen_var, "` = NA_integer_)")
  )

  # Calculate the full encoded vector (based on all unique values in source column, sorted alphabetically)
  # Stata encode assigns numeric codes (1, 2, ...) to non-missing string values, preserving missing values as NA.
  r_code_lines = c(r_code_lines,
    paste0("temp_source_vector_L", cmd_obj$line, " = data[['", varname_str, "']]"),
    # Get unique, non-NA, sorted string values to define the mapping to numeric codes
    paste0("temp_unique_values_L", cmd_obj$line, " = base::sort(base::unique(temp_source_vector_L", cmd_obj$line, "[!is.na(temp_source_vector_L", cmd_obj$line, ")]))"),
    # Create the integer codes (1, 2, ...) based on the sorted unique values. NA values in source remain NA.
    paste0("temp_numeric_values_L", cmd_obj$line, " = base::match(temp_source_vector_L", cmd_obj$line, ", temp_unique_values_L", cmd_obj$line, ")"),
    # Create the labels vector in the R code for haven::labelled
    paste0("temp_labels_vector_L", cmd_obj$line, " = stats::setNames(as.numeric(1:length(temp_unique_values_L", cmd_obj$line, ")), temp_unique_values_L", cmd_obj$line, ")"),
    # Create the haven::labelled object
    paste0(encoded_values_full_tmp_var, " = haven::labelled(as.integer(temp_numeric_values_L", cmd_obj$line, "), labels = temp_labels_vector_L", cmd_obj$line, ")"),
    # Clean up intermediate temp variables
    paste0("rm(temp_source_vector_L", cmd_obj$line, ", temp_unique_values_L", cmd_obj$line, ", temp_numeric_values_L", cmd_obj$line, ", temp_labels_vector_L", cmd_obj$line, ")")
  )

  # Apply the if/in condition for assignment to the target column in 'data'
  if (!is.na(r_if_in_cond) && r_if_in_cond != "") {
       r_code_lines = c(r_code_lines,
           paste0("## Calculate condition flag for encode"),
           # Stata 'if' treats missing as false. Ensure logical vector for subsetting.
           paste0(satisfies_cond_tmp_var, " = dplyr::coalesce(with(data, ", r_if_in_cond, "), FALSE)"),
           # Assign only for rows meeting the condition
           paste0("data[['", gen_var, "']][", satisfies_cond_tmp_var, "] = ", encoded_values_full_tmp_var, "[", satisfies_cond_tmp_var, "]"),
           paste0("rm(", satisfies_cond_tmp_var, ")")
       )
  } else {
      # No condition, assign the full encoded vector
      r_code_lines = c(r_code_lines,
           paste0("data[['", gen_var, "']] = ", encoded_values_full_tmp_var)
      )
  }

  r_code_lines = c(r_code_lines, paste0("rm(", encoded_values_full_tmp_var, ")"))

  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about other options if any were present but not handled (excluding gen)
   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        # Modify regex to remove both 'gen' and 'generate' forms
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\b(?:gen|generate)\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0("\n# Other options ignored: ", options_str_cleaned))
   }

  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_encode.R

!CHANGE_FILE R/t_expand.R
```R
# Translate Stata 'expand' command
# Stata: expand N [if] [in] [, options]
# Creates N copies of each observation. N can be an expression.
# Example: expand 2
# Example: expand num_copies if condition

t_expand = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_expand") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  parts_if = stringi::stri_split_regex(rest_of_cmd_trimmed, "\\s+if\\s+", n=2)[[1]]
  expand_n_part_or_cond = stringi::stri_trim_both(parts_if[1])
  stata_if_cond = if(length(parts_if) > 1) stringi::stri_trim_both(parts_if[2]) else NA_character_

  parts_in = stringi::stri_split_regex(expand_n_part_or_cond, "\\s+in\\s+", n=2)[[1]]
  stata_n_expr = stringi::stri_trim_both(parts_in[1])
  stata_in_range = if(length(parts_in) > 1) stringi::stri_trim_both(parts_in[2]) else NA_character_

  if (is.na(stata_n_expr) || stata_n_expr == "") {
       return(paste0("# expand command requires N expression: ", rest_of_cmd))
  }

  # Context for r_n_expr and conditions should be global, not by_group specific
  # but _n/_N in them needs to be resolved correctly (usually globally for these conditions)
  eval_context = list(is_by_group = FALSE) # Conditions in expand are typically global context

  r_n_expr = translate_stata_expression_with_r_values(stata_n_expr, line_num, cmd_df, context = eval_context)
   if (is.na(r_n_expr) || r_n_expr == "") {
       return(paste0("# Failed to translate N expression for expand: ", stata_n_expr))
   }

  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = eval_context)
  }

  r_in_range_cond = NA_character_
  if (!is.na(stata_in_range) && stata_in_range != "") {
       range_match = stringi::stri_match_first_regex(stata_in_range, "^(\\d+)(?:/(\\d+))?$")
        if (!is.na(range_match[1,1])) {
            start_row = as.integer(range_match[1,2])
            end_row = range_match[1,3]
            # Use dplyr::row_number() which is context-aware via translate_stata_expression
            # For expand, _n is global row number.
            if (is.na(end_row)) {
                 r_in_range_cond = paste0("as.numeric(dplyr::row_number()) == ", start_row)
            } else {
                 r_in_range_cond = paste0("as.numeric(dplyr::row_number()) >= ", start_row, " & as.numeric(dplyr::row_number()) <= ", as.integer(end_row))
            }
        } else {
            return(paste0("# expand in range '", stata_in_range, "' not fully translated (f/l specifiers)."))
        }
  }

  final_r_subset_cond = NA_character_
  if (!is.na(r_if_cond) && !is.na(r_in_range_cond)) {
      final_r_subset_cond = paste0("(", r_if_cond, ") & (", r_in_range_cond, ")")
  } else if (!is.na(r_if_cond)) {
      final_r_subset_cond = r_if_cond
  } else if (!is.na(r_in_range_cond)) {
      final_r_subset_cond = r_in_range_cond
  }

  r_code_str = ""
  line_id = cmd_obj$line

  # Temporary variable names
  temp_n_values_var = paste0("stata_tmp_expand_n_values_L", line_id)
  temp_cond_values_var = paste0("stata_tmp_expand_cond_values_L", line_id)
  final_times_calc_var = paste0("stata_tmp_final_expand_times_L", line_id)

  # Determine if r_n_expr or final_r_subset_cond need `with(data, ...)`
  # Simple heuristic: if expression is not just a number.
  # For r_n_expr:
  n_expr_with_context = if (grepl("[a-zA-Z_]", r_n_expr) && !grepl("^\\d+(\\.\\d*)?$", r_n_expr)) {
                            paste0("with(data, ", r_n_expr, ")")
                          } else {
                            r_n_expr
                          }
  # For final_r_subset_cond:
  cond_expr_with_context = if (!is.na(final_r_subset_cond) && final_r_subset_cond != "") {
                             paste0("with(data, ", final_r_subset_cond, ")")
                           } else {
                             NA_character_ # or "TRUE" if it's to be used directly
                           }


  if (!is.na(final_r_subset_cond) && final_r_subset_cond != "") {
       r_code_lines = c(
           paste0(temp_n_values_var, " = ", n_expr_with_context),
           paste0(temp_cond_values_var, " = ", cond_expr_with_context),
           paste0(final_times_calc_var, " = ifelse(!is.na(", temp_cond_values_var, ") & ", temp_cond_values_var, ", ",
                                             "ifelse(is.na(", temp_n_values_var, "), 1, pmax(0, as.integer(", temp_n_values_var, "))), ",
                                             "1)"),
           paste0("data = data[base::rep(1:NROW(data), times = ", final_times_calc_var, "), ]"),
           paste0("if (exists('", temp_n_values_var, "')) rm(", temp_n_values_var, ", ", temp_cond_values_var, ", ", final_times_calc_var, ")")
       )
       r_code_str = paste(r_code_lines, collapse="\n")
  } else {
        r_code_lines = c(
           paste0(temp_n_values_var, " = ", n_expr_with_context),
           paste0(final_times_calc_var, " = ifelse(is.na(", temp_n_values_var, "), 1, pmax(0, as.integer(", temp_n_values_var, ")))"),
           paste0("data = data[base::rep(1:NROW(data), times = ", final_times_calc_var, "), ]"),
           paste0("if (exists('", temp_n_values_var, "')) rm(", temp_n_values_var, ", ", final_times_calc_var, ")")
        )
       r_code_str = paste(r_code_lines, collapse="\n")
  }

  options_str_cleaned = NA_character_
   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Options ignored: ", options_str_cleaned))
   }

  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_expand.R

!CHANGE_FILE R/t_format.R
```R
# Translate Stata 'format' command
# Stata: format varname %fmt
# This command only affects display, not the underlying data.

t_format = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_format")
  # Stata's `format` command only affects how data is displayed, not its underlying values or type.
  # It is now marked as `do_translate = FALSE` in `mark_data_manip_cmd.R`.
  # This function should ideally not be called if `do_translate` is FALSE.
  # Returning a comment as a fallback, though it should be skipped earlier.
  return(paste0("# Stata format command '", cmd_obj$stata_cmd_original, " ", rest_of_cmd, "' ignored for data transformation (already marked as non-data-manipulating)."))
}

```
!END_CHANGE_FILE R/t_format.R

!CHANGE_FILE R/t_generate.R
```R
t_generate = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_generate")
  # Parse `rest_of_cmd` for new variable name, expression, and if condition
  # Example: "newvar = expression [if condition]"

  # Capture explicit type declaration (e.g., `str10`)
  explicit_type_match = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*(byte|int|long|float|double|str\\d+|strL)\\s+")
  declared_type_str = NA_character_
  if (!is.na(explicit_type_match[1,1])) {
    declared_type_str = explicit_type_match[1,2]
  }

  # Strip type if present (e.g. gen double newvar = ...)
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^\\s*(?:byte|int|long|float|double|str\\d+|strL)\\s+", "")

  match = stringi::stri_match_first_regex(rest_of_cmd_no_type, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  if (is.na(match[1,1])) {
    return(paste0("# Failed to parse generate command: ", rest_of_cmd))
  }

  new_var = stringi::stri_trim_both(match[1,2])
  stata_expr = stringi::stri_trim_both(match[1,3])
  stata_if_cond = stringi::stri_trim_both(match[1,4]) # Might be NA

  # Context for expression translation (e.g. _n, _N behavior)
  # is_by_group TRUE if cmd_obj$by_group_vars is not NA
  current_context = list(is_by_group = cmd_obj$is_by_prefix && length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1]))
  
  # Translate the Stata expression to R first
  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, current_context)

  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    # The 'if' condition for generate/replace is evaluated row-wise on the whole dataset, not per group.
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  # Determine arrange step if needed
  arrange_call = ""
  group_vars_list_bare = character(0) # For dplyr::group_by
  
  # Variables that define the sort order (from by-prefix)
  vars_for_initial_sort = character(0)

  if (cmd_obj$is_by_prefix) {
    if (length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1])) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[!is.na(group_vars_list) & group_vars_list != ""]
      if (length(group_vars_list) > 0) {
        group_vars_list_bare = group_vars_list # Assign just the bare names
        vars_for_initial_sort = c(vars_for_initial_sort, group_vars_list)
      }
    }

    if (length(cmd_obj$by_sort_vars) > 0 && !is.na(cmd_obj$by_sort_vars[1])) {
      sort_vars_list = stringi::stri_split_fixed(cmd_obj$by_sort_vars, ",")[[1]]
      sort_vars_list = sort_vars_list[!is.na(sort_vars_list) & sort_vars_list != ""]
      vars_for_initial_sort = c(vars_for_initial_sort, sort_vars_list)
    }

    if (length(vars_for_initial_sort) > 0) {
      # Ensure unique and preserve order implicitly (by c() then unique)
      vars_for_initial_sort = unique(vars_for_initial_sort) 
      arrange_call = paste0("data = dplyr::arrange(data, !!!dplyr::syms(c(", paste0('"', vars_for_initial_sort, '"', collapse = ", "), ")))")
    }
  }

  # Determine if the target variable will be a string type.
  # This determines the 'NA' value when the 'if' condition is false.
  target_var_will_be_string = FALSE
  if (!is.na(declared_type_str) && stringi::stri_startswith_fixed(declared_type_str, "str")) {
      target_var_will_be_string = TRUE
  } else if (is_stata_expr_string_type(stata_expr)) {
      target_var_will_be_string = TRUE
  }

  # Step 1: Calculate the value for the new variable, potentially conditionally
  # The value to assign if the condition is false/missing.
  na_or_empty_str_for_false_cond = if (target_var_will_be_string) '""' else "NA_real_"

  # The expression result itself might need casting, e.g. logical expr to numeric 0/1
  calculated_value_expr = r_expr
  if (!target_var_will_be_string && stringi::stri_detect_regex(stata_expr, "==|!=|~=|<=|>=|<|>|&|\\|")) {
    calculated_value_expr = paste0("as.numeric(", r_expr, ")")
  }

  if (!is.na(r_if_cond) && r_if_cond != "") {
    # Stata's 'if' condition treats NA as FALSE.
    calc_expr = paste0("dplyr::if_else(dplyr::coalesce(", r_if_cond, ", FALSE), ", calculated_value_expr, ", ", na_or_empty_str_for_false_cond, ")")
  } else {
    calc_expr = calculated_value_expr
  }

  # Step 2: Build the R code string using pipes for the mutate operation
  r_code_lines = c()
  
  if (arrange_call != "") {
      r_code_lines = c(r_code_lines, arrange_call)
  }

  pipe_elements = list("data") # Elements for the pipe chain, starting from `data`

  # Add grouping and mutate steps
  if (length(group_vars_list_bare) > 0) {
      group_by_call_str = paste0('dplyr::group_by(!!!dplyr::syms(c("', paste0(group_vars_list_bare, collapse='", "'), '")))')
      pipe_elements = c(pipe_elements, group_by_call_str)
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", new_var, "` = ", calc_expr, ")"))
      pipe_elements = c(pipe_elements, "dplyr::ungroup()")
  } else {
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", new_var, "` = ", calc_expr, ")"))
  }

  # This is the final assignment line for the current command
  # It takes 'data' (potentially already arranged) and pipes it through the rest
  r_code_lines = c(r_code_lines, paste0("data = ", paste(pipe_elements, collapse = " %>% \n  ")))


  return(paste(r_code_lines, collapse="\n"))
}

```
!END_CHANGE_FILE R/t_generate.R

!CHANGE_FILE R/t_keep.R
```R
# Translate Stata 'keep' command
# Can be `keep varlist` or `keep if condition` or `keep in range`

t_keep = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_keep") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  is_if_keep = stringi::stri_startswith_fixed(rest_of_cmd_trimmed, "if ")
  is_in_keep = stringi::stri_startswith_fixed(rest_of_cmd_trimmed, "in ")

  if (is_if_keep) {
    # keep if condition
    stata_if_cond = stringi::stri_sub(rest_of_cmd_trimmed, from = 4)
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context)
    # Using dplyr::filter
    r_code_str = paste0("data = dplyr::filter(data, ", r_if_cond, ")")
  } else if (is_in_keep) {
    # keep in range
    range_str = stringi::stri_sub(rest_of_cmd_trimmed, from = 4)
    range_match = stringi::stri_match_first_regex(range_str, "^(\\d+)(?:/(\\d+))?$")
    if (!is.na(range_match[1,1])) {
      start_row = as.integer(range_match[1,2])
      end_row = range_match[1,3]
      if (is.na(end_row)) {
        slice_expr = paste0(start_row) # Keep single row
      } else {
        slice_expr = paste0(start_row, ":", as.integer(end_row)) # Keep range
      }
      # Using dplyr::slice
      r_code_str = paste0("data = dplyr::slice(data, ", slice_expr, ")")
    } else {
      r_code_str = paste0("# keep in range '", range_str, "' not fully translated (f/l specifiers).")
    }
  } else {
    # keep varlist
    vars_to_keep = stringi::stri_split_regex(rest_of_cmd_trimmed, "\\s+")[[1]]
    vars_to_keep = vars_to_keep[vars_to_keep != ""]

    if (length(vars_to_keep) == 0) {
      return("# keep command with no variables specified.")
    }
    # Using dplyr::select
    r_code_str = paste0("data = dplyr::select(data, dplyr::all_of(c('", paste(vars_to_keep, collapse="','"), "')))")
  }

  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_keep.R

!CHANGE_FILE R/t_label.R
```R
# Translate Stata 'label' command
# Stata: label define lblname value "label" [value "label" ...] [, add|modify|replace]
# Stata: label values varlist lblname
# Stata: label variable varname "label"

t_label = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_label")
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Determine subcommand: define, values, variable
  if (stringi::stri_startswith_fixed(rest_of_cmd_trimmed, "define ")) {
    return(t_label_define(rest_of_cmd_trimmed, cmd_obj, cmd_df, line_num))
  } else if (stringi::stri_startswith_fixed(rest_of_cmd_trimmed, "values ")) {
    return(t_label_values(rest_of_cmd_trimmed, cmd_obj, cmd_df, line_num))
  } else if (stringi::stri_startswith_fixed(rest_of_cmd_trimmed, "variable ")) {
    return(t_label_variable(rest_of_cmd_trimmed, cmd_obj, cmd_df, line_num))
  } else {
    return(paste0("# Unknown label subcommand: ", rest_of_cmd))
  }
}

t_label_define = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_label_define")
  # label define lblname value "label" ... [, add|modify|replace]
  # Parts: "define ", lblname, rules, options
  define_match = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*define\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*(.*?)(?:,\\s*(add|modify|replace))?$")
  if (is.na(define_match[1,1])) {
      return(paste0("# Failed to parse label define command: ", rest_of_cmd))
  }
  lblname = define_match[1,2]
  rules_str = stringi::stri_trim_both(define_match[1,3]) # Trim whitespace around rules
  option_type = define_match[1,4] # add, modify, replace, or NA

  # Parse rules: value "label" value "label" ...
  # Find all pairs of (non-space value) and (quoted label)
  rule_matches = stringi::stri_match_all_regex(rules_str, "(-?\\d*\\.?\\d+e?-?\\d*|-?\\.\\w?|\\S+)\\s+(?:\"([^\"]*)\"|'([^']*)')")[[1]]
  # Regex breakdown:
  # (-?\\d*\\.?\\d+e?-?\\d*|-?\\.\\w?|\\S+)  -> Captures numeric values (incl sci notation), Stata missing (.), extended missing (.a), or any non-space sequence for other values.
  # \\s+                                    -> Space separator
  # (?:\"([^\"]*)\"|'([^']*)')              -> Captures label in double OR single quotes. Group 2 for double, Group 3 for single.

  if (NROW(rule_matches) == 0 && rules_str != "") { # Allow empty rules_str if label define is just to create an empty set
      return(paste0("# Failed to parse label define rules: ", rules_str))
  }

  values_from_regex = rule_matches[,2]
  labels_from_regex = ifelse(!is.na(rule_matches[,3]), rule_matches[,3], rule_matches[,4]) # Pick double or single quoted label


  # Convert Stata values (like ".", ".a", numbers) to R numeric or NA_real_
  numeric_values_for_labels = sapply(values_from_regex, function(v) {
      if (v == ".") return(NA_real_) # Stata system missing
      if (stringi::stri_detect_regex(v, "^\\.[a-zA-Z]$")) return(NA_real_) # Stata extended missing
      as.numeric(v) # Convert numeric strings to numeric
  })

  # Construct the R named numeric vector string for haven::labelled format: c("label_string" = value_numeric)
  if (length(labels_from_regex) > 0) {
    values_vec_str = paste0("c(", paste(ifelse(is.na(numeric_values_for_labels), "NA_real_", format(numeric_values_for_labels, scientific = FALSE, trim = TRUE)), collapse = ", "), ")")
    names_vec_str = paste0("c(", paste0('"', labels_from_regex, '"', collapse = ", "), ")")
    label_map_r_code_str = paste0("stats::setNames(", values_vec_str, ", ", names_vec_str, ")")

  } else {
    label_map_r_code_str = "stats::setNames(numeric(0), character(0))" # Empty label set
  }


  r_code_lines = c()
  # Corrected exists check:
  r_code_lines = c(r_code_lines, "if (!exists(\"label_defs\", envir = stata2r_env)) stata2r_env$label_defs = list()")

  # Default behavior if no option is like 'add' but Stata errors if exists. Here, we'll overwrite like 'modify'.
  # 'replace' means remove old definition entirely first. 'modify' and 'add' merge.
  if (is.na(option_type) || option_type %in% c("replace", "modify")) { # Treat no option or modify as overwrite/merge; replace is clear overwrite
      if (is.na(option_type) || option_type == "replace") { # If replace or no option (Stata default is error if exists, we replace)
          r_code_lines = c(r_code_lines, paste0("stata2r_env$label_defs$`", lblname, "` = ", label_map_r_code_str))
      } else { # modify (same as add for this logic: new overwrites old for same value)
          r_code_lines = c(
            r_code_lines,
            "temp_existing = if (!is.null(stata2r_env$label_defs$`", lblname, "`)) stata2r_env$label_defs$`", lblname, "` else stats::setNames(numeric(0), character(0))",
            "temp_new_defined = ", label_map_r_code_str,
            "values_in_new = as.numeric(temp_new_defined)",
            "temp_existing_filtered = temp_existing[! (as.numeric(temp_existing) %in% values_in_new) ]",
            "stata2r_env$label_defs$`", lblname, "` = c(temp_existing_filtered, temp_new_defined)"
          )
      }
  } else if (option_type == "add") { # Stata 'add' errors if any value already exists.
       r_code_lines = c(
            r_code_lines,
            "temp_existing = if (!is.null(stata2r_env$label_defs$`", lblname, "`)) stata2r_env$label_defs$`", lblname, "` else stats::setNames(numeric(0), character(0))",
            "temp_new_defined = ", label_map_r_code_str,
            "stata2r_env$label_defs$`", lblname, "` = c(temp_existing[! (as.numeric(temp_existing) %in% as.numeric(temp_new_defined)) ], temp_new_defined)"
          )
  }


  return(paste(r_code_lines, collapse="\n"))
}


t_label_values = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_label_values")
  # label values varlist lblname
  # Or: label values varlist . (to remove labels)
  values_match = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*values\\s+(.*?)\\s+([a-zA-Z_][a-zA-Z0-9_]*|\\.)$")
  if (is.na(values_match[1,1])) {
      return(paste0("# Failed to parse label values command: ", rest_of_cmd))
  }
  varlist_str = stringi::stri_trim_both(values_match[1,2])
  lblname_or_dot = values_match[1,3]

  vars_to_label = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_label = vars_to_label[vars_to_label != ""]

  r_code_lines = c()

  if (lblname_or_dot == ".") { # Remove labels
    for (varname in vars_to_label) {
        r_code_lines = c(r_code_lines, paste0("  data[['", varname, "']] = haven::zap_labels(data[['", varname, "']])"))
    }
  } else { # Apply labels from lblname
    lblname = lblname_or_dot
    # Corrected exists check:
    r_code_lines = c(r_code_lines, paste0("if (!exists(\"label_defs\", envir = stata2r_env)) stata2r_env$label_defs = list()"))
    r_code_lines = c(r_code_lines, paste0("label_map_to_apply = stata2r_env$label_defs$`", lblname, "`"))

    for (varname in vars_to_label) {
      # Use a temporary variable for the new labelled object to avoid long line
      temp_labelled_var = paste0("stata_tmp_labelled_L", cmd_obj$line, "_", varname)

      r_code_lines = c(r_code_lines, paste0("if (!is.null(label_map_to_apply)) {"))
      # Ensure existing_var_label is character(1) for haven::labelled
      r_code_lines = c(r_code_lines, paste0("  temp_attr_label = attr(data[['",varname,"']], 'label')"))
      r_code_lines = c(r_code_lines, paste0("  existing_var_label = if (is.null(temp_attr_label) || length(temp_attr_label) == 0 || is.na(temp_attr_label[1])) NA_character_ else as.character(temp_attr_label[1])")) # FIX HERE
      r_code_lines = c(r_code_lines, paste0("  ", temp_labelled_var, " = haven::labelled(data[['", varname, "']], labels = label_map_to_apply, label = existing_var_label)"))
      r_code_lines = c(r_code_lines, paste0("  data[['", varname, "']] = ", temp_labelled_var))
      r_code_lines = c(r_code_lines, paste0("  rm(", temp_labelled_var, ")"))
      r_code_lines = c(r_code_lines, "} else {" )
      r_code_lines = c(r_code_lines, paste0("  warning(paste0('Label definition `", lblname,"` not found for `label values` command on line ", cmd_obj$line, ". Labels removed from ', '",varname,"',' if any.'))"))
      r_code_lines = c(r_code_lines, paste0("  data[['", varname, "']] = haven::zap_labels(data[['", varname, "']])"))
      r_code_lines = c(r_code_lines, "}" )
    }
  }
  return(paste(r_code_lines, collapse="\n"))
}

t_label_variable = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_label_variable")
  # label variable varname "label"
  variable_match = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*variable\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s+(?:\"([^\"]*)\"|'([^']*)')$")
  if (is.na(variable_match[1,1])) {
      return(paste0("# Failed to parse label variable command: ", rest_of_cmd))
  }
  varname = variable_match[1,2]
  label_str_double_quoted = variable_match[1,3]
  label_str_single_quoted = variable_match[1,4]

  label_str = if (!is.na(label_str_double_quoted)) label_str_double_quoted else label_str_single_quoted
  # Escape double quotes within the label string for R string literal
  label_str_escaped = stringi::stri_replace_all_fixed(label_str, '"', '\\"')


  r_code_lines = c(
      paste0("attr(data$`", varname, "`, \"label\") = \"", label_str_escaped, "\"")
  )
  return(paste(r_code_lines, collapse="\n"))
}

```
!END_CHANGE_FILE R/t_label.R

!CHANGE_FILE R/t_merge.R
```R
# Translate Stata 'merge' command
# Stata: merge 1:1 varlist using filename [, options]
# Stata: merge 1:m varlist using filename [, options]
# Stata: merge m:1 varlist using filename [, options]
# Stata: merge m:m varlist using filename [, options]
# Options: keep(match master using all) nogenerate

t_merge = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_merge") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Define a temporary indicator column name for dplyr::join
  indicator_col_name = paste0("stata_merge_indicator_L", line_num)

  # Parse merge type (1:1, 1:m, m:1, m:m), varlist, `using filename`, and options
  # Corrected regex for merge type to allow 'm'
  # Pattern: ^\s*([1m]:[1m])\s+(.*?)\s+using\s+([^,\s]+)(?:,\\s*(.*))?$
  # G1: type, G2: varlist, G3: filename (can be quoted or macro), G4: options

  merge_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*([1m]:[1m])\\s+(.*?)\\s+using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")
  merge_type = NA_character_
  varlist_str = NA_character_
  raw_filename_token = NA_character_
  options_str = NA_character_


  if (is.na(merge_match[1,1])) {
      # Check for older syntax without type: `merge varlist using filename` (defaults to 1:1)
      merge_match_old = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(.*?)\\s+using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")
      if (!is.na(merge_match_old[1,1])) {
           merge_type = "1:1" # Assume 1:1 if type not specified
           varlist_str = stringi::stri_trim_both(merge_match_old[1,2])
           raw_filename_token = stringi::stri_trim_both(merge_match_old[1,3])
           options_str = stringi::stri_trim_both(merge_match_old[1,4])
      } else {
           return(paste0("# Failed to parse merge command: ", rest_of_cmd))
      }
  } else {
      merge_type = merge_match[1,2]
      varlist_str = stringi::stri_trim_both(merge_match[1,3])
      raw_filename_token = stringi::stri_trim_both(merge_match[1,4])
      options_str = stringi::stri_trim_both(merge_match[1,5]) # NA if no options
  }

  vars_to_merge_on = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_merge_on = vars_to_merge_on[vars_to_merge_on != ""]
  if (length(vars_to_merge_on) == 0) {
       return(paste0("# merge command requires varlist: ", rest_of_cmd))
  }
  # For dplyr::join, by argument can be a character vector of column names
  vars_to_merge_on_r_vec_str = paste0('c("', paste(vars_to_merge_on, collapse = '", "'), '")')

  # Changed default_base_dir_var to "working_dir" for consistency with Stata's default file paths
  using_source_r_expr = resolve_stata_filename(raw_filename_token, cmd_df, line_num, default_base_dir_var = "working_dir")


  # Determine join type based on Stata's `keep()` option or default behavior
  # Stata's default merge behavior is to keep matching observations and unmatched master observations (left_join).
  # If no keep() option is specified, default to left_join.
  join_type_r_func = "dplyr::left_join" # Default for Stata merge
  keep_spec_for_comment = "match master" # Default if no keep() specified

  if (!is.na(options_str)) {
      keep_opt_match = stringi::stri_match_first_regex(options_str, "\\bkeep\\s*\\(([^)]+)\\)")
      if (!is.na(keep_opt_match[1,1])) {
          keep_spec = stringi::stri_trim_both(keep_opt_match[1,2])
          if (grepl("\\ball\\b", keep_spec)) {
              join_type_r_func = "dplyr::full_join"
              keep_spec_for_comment = "all"
          } else if (grepl("\\bmaster\\b", keep_spec)) {
              join_type_r_func = "dplyr::left_join" # Keep matched and master unmatched (left join)
              keep_spec_for_comment = "master"
          } else if (grepl("\\busing\\b", keep_spec)) {
              join_type_r_func = "dplyr::right_join" # Keep matched and using unmatched (right join)
               keep_spec_for_comment = "using"
          } else if (grepl("\\bmatch\\b", keep_spec)) {
              join_type_r_func = "dplyr::inner_join" # Keep matched only (inner join)
              keep_spec_for_comment = "match"
          }
          # Other complex keep() specs like `keep(_merge==3)` are not handled here.
      }
  }

  # Handle nogenerate option - FIX: use regex to correctly detect 'nogen' abbreviation
  has_nogenerate = !is.na(options_str) && stringi::stri_detect_regex(options_str, "\\bno(?:generate|gen)\\b")
  
  # Build the R command string using dplyr::*_join

  # Load the using dataset into a temporary variable first
  r_code_lines = c()
  temp_using_data_var = paste0("stata_tmp_using_data_L", line_num)
  r_code_lines = c(r_code_lines, paste0(temp_using_data_var, " = haven::read_dta(", using_source_r_expr, ")"))

  # Identify common columns that are NOT merge keys
  r_code_lines = c(r_code_lines,
    paste0("common_cols = intersect(names(data), names(", temp_using_data_var, "))"),
    paste0("common_cols_not_by = setdiff(common_cols, ", vars_to_merge_on_r_vec_str, ")")
  )

  # Conditional dropping of columns from the using dataset
  # This is a general Stata merge rule: master's non-key variables take precedence.
  r_code_lines = c(r_code_lines,
    paste0("if (length(common_cols_not_by) > 0) { ", temp_using_data_var, " = dplyr::select(", temp_using_data_var, ", -dplyr::all_of(common_cols_not_by)) }")
  )

  # Perform the join with indicator
  r_code_lines = c(r_code_lines,
    paste0("data = ", join_type_r_func, "(data, ", temp_using_data_var, ", by = ", vars_to_merge_on_r_vec_str, ", indicator = \"", indicator_col_name, "\")")
  )

  # Generate _merge variable unless nogenerate option is present
  if (!has_nogenerate) {
      r_code_lines = c(r_code_lines,
          paste0("data = dplyr::mutate(data, `_merge` = dplyr::case_when("),
          paste0("  `", indicator_col_name, "` == \"left_only\" ~ 1L,"),
          paste0("  `", indicator_col_name, "` == \"right_only\" ~ 2L,"),
          paste0("  `", indicator_col_name, "` == \"both\" ~ 3L,"),
          paste0("  TRUE ~ NA_integer_ # Should not happen if join is successful, but for safety"),
          paste0("))")
      )
  } else {
    r_code_lines = c(r_code_lines, paste0(" # _merge variable was not generated due to 'nogenerate' option."))
  }

  # Always remove the temporary indicator column
  # Use dplyr::any_of to prevent error if column somehow not created (e.g. older dplyr or unexpected join result)
  r_code_lines = c(r_code_lines, paste0("data = dplyr::select(data, -dplyr::any_of('", indicator_col_name, "'))"))

  # Clean up temporary variables
  r_code_lines = c(r_code_lines, paste0("rm(", temp_using_data_var, ", common_cols, common_cols_not_by)"))

  # Add comment about options
  merge_comment_line = paste0("# Stata merge type: ", merge_type, ", keep(", keep_spec_for_comment, ")")
  if (has_nogenerate) {
    merge_comment_line = paste0(merge_comment_line, ", nogenerate")
  }
  r_code_lines = c(r_code_lines, merge_comment_line)

  options_str_cleaned = options_str
  if (!is.na(options_str_cleaned)) {
      # Remove keep() and nogenerate from options string for comment
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bkeep\\s*\\([^)]+\\)", "")
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bno(?:generate|gen)\\b", "") # Updated to remove both
      options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
  }
  if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
       r_code_lines = c(r_code_lines, paste0(" # Other options ignored: ", options_str_cleaned))
  }

  return(paste(r_code_lines, collapse="\n"))
}

```
!END_CHANGE_FILE R/t_merge.R

!CHANGE_FILE R/t_order.R
```R
# Translate Stata 'order' command
# Stata: order varlist [options]
# Changes the order of variables in the dataset.

t_order = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_order") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Split varlist from options (like `first`, `last`, `after(var)`)
  # Pattern: ^\s*(.*?)(?:,\\s*(.*))?$
  parts = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(.*?)(?:,\\s*(.*))?$")
  varlist_str = stringi::stri_trim_both(parts[1,2])
  options_str = stringi::stri_trim_both(parts[1,3]) # NA if no options

  vars_to_order = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_order = vars_to_order[vars_to_order != ""]

  if (length(vars_to_order) == 0) {
    return("# order command with no variables specified.")
  }

  # Stata `order varlist` puts varlist at the beginning.
  # Options like `first`, `last`, `after(var)` are not handled here.
  # R equivalent: Select the variables to order, then select all other variables.
  # Using dplyr::select
  # R code: data = dplyr::select(data, var1, var2, ..., dplyr::everything())

  vars_to_order_r_str = paste(vars_to_order, collapse = ", ")

  r_code_str = paste0("data = dplyr::select(data, ", vars_to_order_r_str, ", dplyr::everything())")

  # Add comment about options if any were present but not handled
   if (!is.na(options_str) && options_str != "") {
        r_code_str = paste0(r_code_str, paste0(" # Options ignored: ", options_str))
   }


  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_order.R

!CHANGE_FILE R/t_preserve_restore.R
```R
# Translate Stata 'preserve' and 'restore' commands

# Global stack for preserve/restore if multiple levels are needed
# This should ideally be managed by the calling environment of the translated code.
# For now, we generate code that uses variables like `data_preserved_L<line>`

# preserve_stack_name = "stata_preserve_stack_internal" # Name of list in R environment

t_preserve_restore = function(cmd_obj, type = "preserve") { # line_num implicitly from cmd_obj$line
  restore.point("t_preserve_restore") # Added restore.point
  # Preserve: Make a copy of the current 'data' dataframe.
  # Restore: Replace 'data' with the last preserved version.

  # Stata preserve/restore can be nested. A stack is needed.
  # The translated R code will try to mimic this using uniquely named backup variables.
  # A simpler approach if only one level of preserve/restore is common:
  # preserve -> data_backup = data
  # restore -> data = data_backup

  # To handle nesting, we use line numbers to make backup names unique.
  # This assumes preserve/restore are properly paired.
  # A true stack mechanism would require the list `stata_preserve_stack_internal` to be managed.
  # For now, let's use unique variable names based on line number. This is not a stack,
  # it means a `restore` must correspond to a specific `preserve`'s variable. This is not how Stata works.

  r_code_lines = c(
    "if (!exists('stata_data_preserve_stack_G')) stata_data_preserve_stack_G = list() # Global stack for preserve/restore"
  )

  if (type == "preserve") {
    r_code_lines = c(r_code_lines,
      "stata_data_preserve_stack_G = c(list(data), stata_data_preserve_stack_G)",
      paste0("# Preserved data state from Stata line: ", cmd_obj$line)
    )
  } else if (type == "restore") {
    r_code_lines = c(r_code_lines,
      "if (length(stata_data_preserve_stack_G) > 0) {",
      "  data = stata_data_preserve_stack_G[[1]]",
      "  stata_data_preserve_stack_G = stata_data_preserve_stack_G[-1]",
      paste0("  # Restored data state from Stata line: ", cmd_obj$line),
      "} else {",
      paste0("  warning('Stata restore called on line ", cmd_obj$line, " but preserve stack is empty.')"),
      "}"
    )
  }

  return(paste(r_code_lines, collapse = "\n"))
}

```
!END_CHANGE_FILE R/t_preserve_restore.R

!CHANGE_FILE R/t_recode.R
```R
# Translate Stata 'recode' command
# Stata: recode varlist (rule1)(rule2)... [if] [in] [, options]
# Example: recode income (0=.) (100 thru 200 = 150) (300 301 305 = 300) (else=copy), gen(newincome)

t_recode = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_recode") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varlist, rules, if/in, options (especially gen())
  # This parsing is quite complex due to nested parentheses and optional parts.
  # Let's try to split varlist first, then find rules in parentheses.
  # Example: `recode var1 var2 (0=.) (1/10=1) (else=copy) if cond, gen(new1 new2)`

  # Split at first parenthesis to get varlist
  parts_varlist = stringi::stri_split_fixed(rest_of_cmd_trimmed, "(", n=2)[[1]]
  if (length(parts_varlist) != 2) {
      return(paste0("# Failed to parse recode command (missing rules): ", rest_of_cmd))
  }
  varlist_str = stringi::stri_trim_both(parts_varlist[1])
  vars_to_recode = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_recode = vars_to_recode[vars_to_recode != ""]

  if (length(vars_to_recode) == 0) {
      return(paste0("# recode command requires varlist: ", rest_of_cmd))
  }

  rules_and_rest = paste0("(", parts_varlist[2]) # Put the '(' back

  # Separate if/in and options from rules
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Look for `if` or `in` first
  if_in_match = stringi::stri_match_first_regex(rules_and_rest, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rules_and_rest = stringi::stri_replace_last_regex(rules_and_rest, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rules_and_rest = stringi::stri_trim_both(rules_and_rest)
  }

  # Look for options after the if/in part or after rules
  options_match = stringi::stri_match_first_regex(rules_and_rest, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2]) # Corrected to take group 2 for options string
      rules_part = stringi::stri_replace_last_regex(rules_and_rest, ",\\s*(.*)$", "")
      rules_part = stringi::stri_trim_both(rules_part)
  } else {
      rules_part = rules_and_rest
  }

  # Now parse the rules part: (rule1)(rule2)...
  # Find all rules within parentheses
  rule_matches = stringi::stri_match_all_regex(rules_part, "\\(([^)]*)\\)")[[1]] # Match content inside ()
  if (NROW(rule_matches) == 0) {
      return(paste0("# Failed to parse recode rules: ", rules_part))
  }
  recode_rules_raw = rule_matches[,2] # Extract the content within parentheses


  # Parse options, specifically `gen()`
  gen_vars = NA_character_
  if (!is.na(options_str)) {
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgen\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars = stringi::stri_trim_both(gen_opt_match[1,2])
       }
  }

  new_vars = NULL
  if (!is.na(gen_vars)) {
      new_vars = stringi::stri_split_regex(gen_vars, "\\s+")[[1]]
      new_vars = new_vars[new_vars != ""]
      if (length(new_vars) != length(vars_to_recode)) {
          return(paste0("# recode gen() option requires same number of new variables as old variables."))
      }
  } else {
      # If no gen() option, recode is done in place. New vars are the same as old vars.
      new_vars = vars_to_recode
  }

  # --- Determine the target variable type and collect labels if applicable ---
  target_var_will_be_string_in_R = FALSE
  target_var_is_numeric_with_labels = FALSE
  # Use a temporary list to collect labels (name=label string, value=numeric code)
  collected_labels_temp = list() 

  for (rule_raw in recode_rules_raw) {
      rule_str_trimmed = stringi::stri_trim_both(rule_raw)
      parts_eq = stringi::stri_split_fixed(rule_str_trimmed, "=", n=2)[[1]]
      if (length(parts_eq) != 2) next # Skip malformed rules
      new_part_raw = stringi::stri_trim_both(parts_eq[2])

      # Check for plain string literal (e.g., "new_string_value")
      if ( (stringi::stri_startswith_fixed(new_part_raw, '"') && stringi::stri_endswith_fixed(new_part_raw, '"')) ||
           (stringi::stri_startswith_fixed(new_part_raw, "'") && stringi::stri_endswith_fixed(new_part_raw, "'")) ) {
          target_var_will_be_string_in_R = TRUE
          # If any rule implies string, the whole var becomes string. Labels are not applicable.
          target_var_is_numeric_with_labels = FALSE
          break 
      }

      # Check for 'value "label"' syntax
      label_match = stringi::stri_match_first_regex(new_part_raw, "^\\s*([^\\s]+)\\s+(?:\"([^\"]*)\"|'([^']*)')\\s*$")
      if (!is.na(label_match[1,1])) {
          target_var_is_numeric_with_labels = TRUE
          numeric_val_part = stringi::stri_trim_both(label_match[1,2])
          string_label_part = ifelse(!is.na(label_match[1,3]), label_match[1,3], label_match[1,4])

          # Convert numeric value to R numeric (handling Stata's missing values)
          r_numeric_val = NA_real_
          if (numeric_val_part == ".") r_numeric_val = NA_real_
          else if (stringi::stri_detect_regex(numeric_val_part, "^\\.[a-zA-Z]$")) r_numeric_val = NA_real_
          else r_numeric_val = as.numeric(numeric_val_part)

          if (!is.na(r_numeric_val)) {
            # Collect label: key is numeric value, value is label string
            # This is for haven::labelled(..., labels = c(num_val = "label_str"))
            # For haven, labels are names, values are the actual codes. So we store label=value.
            collected_labels_temp[[string_label_part]] = r_numeric_val
          }
      }
  }

  # After loop, convert collected_labels_temp to the final named numeric vector for labels
  # `collected_labels_temp` has label strings as keys and numeric values as values.
  # haven::labelled expects labels = c("Label A" = 1, "Label B" = 2).
  # So, the final format should be: names are labels, values are numeric codes.

  final_labels_map = stats::setNames(numeric(0), character(0)) # Initialize empty named numeric vector
  if (target_var_is_numeric_with_labels && length(collected_labels_temp) > 0) {
      # Convert to a data.frame for easier manipulation and duplicate handling
      # If a label is reused for different values, haven::labelled will just use it.
      # If a value is given multiple labels, the last one for that value applies.
      temp_df_labels = data.frame(
          label = names(collected_labels_temp),
          value = unlist(collected_labels_temp, use.names = FALSE),
          stringsAsFactors = FALSE
      )
      
      # Handle duplicates: Stata's recode takes the last definition for a value.
      # So, if same value is assigned different labels, the last label for that value wins.
      # Or if different values get the same label, all are kept.
      # For haven::labelled, if multiple labels point to the same value, it's fine.
      # If a value has multiple labels, haven will use the first one.
      # To match Stata's "last rule wins" for value redefinition, we'll ensure
      # that if a numeric value is assigned multiple times, only the last assignment is kept.
      
      # Sort by value, then by rule order to ensure last rule wins for a value.
      temp_df_labels$order_idx = seq_len(NROW(temp_df_labels)) # Preserve original order
      temp_df_labels = temp_df_labels[order(temp_df_labels$value, temp_df_labels$order_idx), ]
      temp_df_labels = temp_df_labels[!duplicated(temp_df_labels$value, fromLast = TRUE), ] # Keep last entry for duplicate values
      
      # Create the final named vector: names are labels, values are the numeric codes
      final_labels_map = stats::setNames(temp_df_labels$value, temp_df_labels$label)
      # Reorder by numeric value for consistency, if desired, but not strictly necessary for functionality
      final_labels_map = final_labels_map[order(unname(final_labels_map))]
  }

  # This is the variable that was missing in the test:
  final_r_var_type_is_labelled_numeric = target_var_is_numeric_with_labels


  # Translate the if/in condition for subsetting
  r_subset_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for recode: ", stata_if_in_cond))
       }
  }


  # Translate rules into R case_when clauses
  # Rule format: old_value = new_value
  # old_value can be: single value, range (val1/val2, val1 thru val2), list (val1 val2), else, missing (.)
  # new_value can be: single value, copy (use original value), missing (.)

  translate_recode_rule = function(rule_str, source_var_r, target_var_will_be_string_in_R) { # Corrected parameter name
      restore.point("translate_recode_rule_inner")
      rule_str = stringi::stri_trim_both(rule_str)
      parts_eq = stringi::stri_split_fixed(rule_str, "=", n=2)[[1]]
      if (length(parts_eq) != 2) {
          return(paste0("## Error parsing rule: ", rule_str))
      }
      old_part_raw = stringi::stri_trim_both(parts_eq[1])
      new_part_raw = stringi::stri_trim_both(parts_eq[2])

      # Translate old_part into R condition (left side of case_when ~ )
      r_condition = ""
      if (old_part_raw == "else") {
          r_condition = "TRUE" # This rule is the fallback
      } else if (old_part_raw == "missing" || stringi::stri_detect_regex(old_part_raw, "^\\.\\w?$")) { # Added regex for .a, .b, etc.
           r_condition = paste0("sfun_missing(", source_var_r, ")") # Missing value rule (all Stata missing types to R's NA)
      } else if (old_part_raw == "nonmissing") {
           r_condition = paste0("!sfun_missing(", source_var_r, ")") # Non-missing value rule
      } else if (grepl("\\s+thru\\s+", old_part_raw)) {
           # Range: val1 thru val2
           range_parts = stringi::stri_split_regex(old_part_raw, "\\s+thru\\s+", n=2)[[1]]
           val1 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[1]), context=list(is_by_group=FALSE))
           val2 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[2]), context=list(is_by_group=FALSE))
           if (is.na(val1) || is.na(val2)) return(paste0("## Error translating range values in rule: ", rule_str))
           r_condition = paste0(source_var_r, " >= ", val1, " & ", source_var_r, " <= ", val2)
      } else if (grepl("/", old_part_raw)) {
          # Range: val1/val2
           range_parts = stringi::stri_split_regex(old_part_raw, "/", n=2)[[1]]
           val1 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[1]), context=list(is_by_group=FALSE))
           val2 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[2]), context=list(is_by_group=FALSE))
           if (is.na(val1) || is.na(val2)) return(paste0("## Error translating range values in rule: ", rule_str))
           r_condition = paste0(source_var_r, " >= ", val1, " & ", source_var_r, " <= ", val2) # Stata / is inclusive range
      }
      else {
          # List of values or single value
          old_values = stringi::stri_split_regex(old_part_raw, "\\s+")[[1]]
          old_values = old_values[old_values != ""]
          r_values = sapply(old_values, function(val) {
               # Use translate_stata_expression_to_r for each value in the list
               # Stata missing values like '.' or '.a' should be handled as NA in R
               if (val == ".") return("NA_real_")
               if (stringi::stri_detect_regex(val, "^\\.[a-zA-Z]$")) return("NA_real_")
               translate_stata_expression_to_r(val, context=list(is_by_group=FALSE))
          })
          r_values = r_values[!is.na(r_values)] # Filter out any NA from translation for safety
          if (length(r_values) == 0) return(paste0("## Error translating old values in rule: ", rule_str))
          # For comparison, ensure values are cast to same type as source_var_r or handled by %in%
          # The `translate_stata_expression_to_r` should return string literals for string values, numeric literals for numeric.
          r_condition = paste0(source_var_r, " %in% c(", paste(r_values, collapse = ", "), ")")
      }


      # Translate new_part into R value (right side of case_when ~ )
      r_new_value = ""
      if (new_part_raw == "copy") {
          r_new_value = source_var_r # Use the original variable value
          # If target is string but source is not, need to convert source to string
          if (target_var_will_be_string_in_R) {
            r_new_value = paste0("as.character(", r_new_value, ")")
          }
      } else {
          # Check for numeric value with optional label, e.g., '1 "Very Low"'
          label_match = stringi::stri_match_first_regex(new_part_raw, "^\\s*([^\\s]+)\\s+(?:\"([^\"]*)\"|'([^']*)')\\s*$")
          if (!is.na(label_match[1,1])) {
              # It's a "value label" syntax
              numeric_val_part = stringi::stri_trim_both(label_match[1,2])
              # If target is string, return the label as a string literal
              if (target_var_will_be_string_in_R) {
                  string_label_part = ifelse(!is.na(label_match[1,3]), label_match[1,3], label_match[1,4])
                  r_new_value = quote_for_r_literal(string_label_part)
              } else {
                  # If target is numeric (possibly labelled numeric), return the numeric value, translated
                  r_new_value = translate_stata_expression_to_r(numeric_val_part, context=list(is_by_group=FALSE))
              }
          } else {
              # It's a plain expression or literal (numeric or string)
              r_new_value = translate_stata_expression_to_r(new_part_raw, context=list(is_by_group=FALSE))
              # If target is string, ensure the expression result is cast to string
              if (target_var_will_be_string_in_R) {
                  # This is the crucial change for Stata's missing value conversion to empty string
                  if (r_new_value == "NA_real_") {
                      r_new_value = '""' # Stata recode for missing numeric to empty string for string variables
                  } else if (!stringi::stri_startswith_fixed(r_new_value, '"') && !stringi::stri_startswith_fixed(r_new_value, "'")) {
                      # Only wrap in as.character() if it's not already a quoted string
                      r_new_value = paste0("as.character(", r_new_value, ")")
                  }
              }
          }
      }

      return(paste0(r_condition, " ~ ", r_new_value))
  }

  # Generate case_when expression for each variable
  mutate_exprs = character(length(vars_to_recode))
  r_code_lines = c()

  for (k in seq_along(vars_to_recode)) {
      old_var = vars_to_recode[k]
      new_var = new_vars[k]
      source_var_r = old_var # R variable name for the source column

      # Translate all rules for this variable
      # Pass the determined target type
      r_rules = sapply(recode_rules_raw, translate_recode_rule, source_var_r = source_var_r, target_var_will_be_string_in_R = target_var_will_be_string_in_R)

      # Combine rules into a case_when statement
      case_when_expr = paste0("dplyr::case_when(\n    ", paste(r_rules, collapse = ",\n    "), "\n  )")

      # Apply global if/in condition around the case_when
      if (!is.na(r_subset_cond) && r_subset_cond != "") {
          # If condition is met, apply case_when. Otherwise, keep original value.
          # Stata's `if` condition treats missing as FALSE, so use coalesce.
          final_value_expr = paste0("dplyr::if_else(dplyr::coalesce(", r_subset_cond, ", FALSE),\n",
                                    "    ", case_when_expr, ",\n",
                                    "    `", source_var_r, "`)") # Keep original value if condition not met.
      } else {
          final_value_expr = case_when_expr
      }


      mutate_exprs[k] = paste0("`", new_var, "` = ", final_value_expr)
  }

  # Combine mutate expressions
  mutate_exprs_str = paste(mutate_exprs, collapse = ",\n  ")

  # Build the final R code using dplyr::mutate
  r_code_lines = c(r_code_lines, paste0("data = dplyr::mutate(data, ", mutate_exprs_str, ")"))

  # Apply labels if the target variable is determined to be numeric with labels
  if (final_r_var_type_is_labelled_numeric && length(final_labels_map) > 0) {
      # The `final_labels_map` is already in the format `labels = c("label1" = value1, ...)`
      labels_vector_r_code = paste0("c(", paste0('"', names(final_labels_map), '" = ', unname(final_labels_map), collapse=", "), ")")

      for (new_var in new_vars) {
          # Need to update the labels attribute directly, as haven::labelled only sets it on creation
          r_code_lines = c(r_code_lines, paste0("attr(data$`", new_var, "`, \"labels\") = ", labels_vector_r_code))
          # Ensure it remains a labelled class, or re-apply haven::labelled
          # For simplicity, if it was just mutated to numeric, this attribute should suffice
          # If it was already a labelled numeric, this will update/overwrite its labels.
      }
  }


  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about options if any were present but not handled (excluding gen)
   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bgen\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ",")) # Clean up multiple commas
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0("\n# Other options ignored: ", options_str_cleaned))
   }


  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_recode.R

!CHANGE_FILE R/t_rename.R
```R
# Translate Stata 'rename' command
# Stata: rename old_var new_var
t_rename = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_rename") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Split into old_var and new_var
  parts = stringi::stri_split_regex(rest_of_cmd_trimmed, "\\s+", n = 2)[[1]]

  if (length(parts) != 2) {
    return(paste0("# Failed to parse rename command: ", rest_of_cmd))
  }

  old_var = parts[1]
  new_var = parts[2]

  # Using collapse::frename
  # collapse::frename(data, old_name = new_name)
  r_code_str = paste0("data = collapse::frename(data, `", old_var, "` = `", new_var, "`)")
  # Alternative dplyr: data = dplyr::rename(data, new_var = old_var)
  # r_code_str = paste0("data = dplyr::rename(data, `", new_var, "` = `", old_var, "`)")

  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_rename.R

!CHANGE_FILE R/t_replace.R
```R
t_replace = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_replace")
  # Capture explicit type declaration (e.g., `str10`)
  explicit_type_match = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*(byte|int|long|float|double|str\\d+|strL)\\s+")
  declared_type_str = NA_character_
  if (!is.na(explicit_type_match[1,1])) {
    declared_type_str = explicit_type_match[1,2]
  }

  # Strip type if present (e.g. replace double oldvar = ...)
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^(?:byte|int|long|float|double|str\\d+|strL)\\s+", "")

  match = stringi::stri_match_first_regex(rest_of_cmd_no_type, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  if (is.na(match[1,1])) {
    return(paste0("# Failed to parse replace command: ", rest_of_cmd))
  }

  var_to_replace = stringi::stri_trim_both(match[1,2])
  stata_expr = stringi::stri_trim_both(match[1,3])
  stata_if_cond = stringi::stri_trim_both(match[1,4]) # Might be NA

  current_context = list(is_by_group = cmd_obj$is_by_prefix && length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1]))
  # Translate the Stata expression to R first
  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, current_context)

  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  # Determine arrange step if needed
  arrange_call = ""
  group_vars_list_bare = character(0) # For dplyr::group_by

  # Variables that define the sort order (from by-prefix)
  vars_for_initial_sort = character(0)

  if (cmd_obj$is_by_prefix) {
    if (length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1])) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[!is.na(group_vars_list) & group_vars_list != ""]
      if (length(group_vars_list) > 0) {
        group_vars_list_bare = group_vars_list # Assign just the bare names
        vars_for_initial_sort = c(vars_for_initial_sort, group_vars_list)
      }
    }

    if (length(cmd_obj$by_sort_vars) > 0 && !is.na(cmd_obj$by_sort_vars[1])) {
      sort_vars_list = stringi::stri_split_fixed(cmd_obj$by_sort_vars, ",")[[1]]
      sort_vars_list = sort_vars_list[!is.na(sort_vars_list) & sort_vars_list != ""]
      vars_for_initial_sort = c(vars_for_initial_sort, sort_vars_list)
    }

    if (length(vars_for_initial_sort) > 0) {
      vars_for_initial_sort = unique(vars_for_initial_sort)
      arrange_call = paste0("data = dplyr::arrange(data, !!!dplyr::syms(c(", paste0('"', vars_for_initial_sort, '"', collapse = ", "), ")))")
    }
  }

  # Determine if the target variable is a string type.
  # For 'replace', we should check the current type of the variable in the data,
  # or if an explicit `str#` type is declared.
  # The existing variable `var_to_replace`'s type is difficult to know at translation time.
  # However, `is_stata_expr_string_type` for the expression itself is a good proxy.
  # If the target variable *was* string, and the expression *is* string, it stays string.
  # If the target variable *was* numeric, and the expression *is* string, it becomes string.
  # If the target variable *was* string, and the expression *is* numeric, it tries to convert (Stata warns/errors).
  # The most robust approach is to rely on `is_stata_expr_string_type` and explicit `str#` declaration.
  target_var_will_be_string = FALSE
  if (!is.na(declared_type_str) && stringi::stri_startswith_fixed(declared_type_str, "str")) {
      target_var_will_be_string = TRUE
  } else if (is_stata_expr_string_type(stata_expr)) {
      target_var_will_be_string = TRUE
  }
  # If not explicitly declared and not string expression, assume numeric.

  # The value to assign if the condition is false/missing.
  # For 'replace', if condition is false, the *original value* is kept, not NA or "".
  # So, `na_or_empty_str_for_false_cond` is not needed in the `if_else` 'false' branch;
  # instead, it's `data$`var_to_replace`.

  # The expression result itself might need casting, e.g. logical expr to numeric 0/1
  calculated_value_expr = r_expr
  if (!target_var_will_be_string && stringi::stri_detect_regex(stata_expr, "==|!=|~=|<=|>=|<|>|&|\\|")) {
    calculated_value_expr = paste0("as.numeric(", r_expr, ")")
  }

  # For 'replace' command, if condition is FALSE or NA, the value should be left unchanged.
  # Use dplyr::coalesce(condition, FALSE) to treat NA condition as FALSE.
  if (!is.na(r_if_cond) && r_if_cond != "") {
    calc_expr = paste0("dplyr::if_else(dplyr::coalesce(", r_if_cond, ", FALSE), ", calculated_value_expr, ", data$`", var_to_replace, "`)")
  } else {
    calc_expr = calculated_value_expr
  }

  # Step 2: Build the R code string using pipes for the mutate operation
  r_code_lines = c()

  if (arrange_call != "") {
      r_code_lines = c(r_code_lines, arrange_call)
  }

  pipe_elements = list("data") # Elements for the pipe chain, starting from `data`

  if (length(group_vars_list_bare) > 0) { # Check if group_vars_list_bare is not empty
      group_by_call_str = paste0('dplyr::group_by(!!!dplyr::syms(c("', paste0(group_vars_list_bare, collapse='", "'), '")))')
      pipe_elements = c(pipe_elements, group_by_call_str)
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", var_to_replace, "` = ", calc_expr, ")"))
      pipe_elements = c(pipe_elements, "dplyr::ungroup()")
  } else {
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", var_to_replace, "` = ", calc_expr, ")"))
  }

  r_code_lines = c(r_code_lines, paste0("data = ", paste(pipe_elements, collapse = " %>% \n  ")))

  return(paste(r_code_lines, collapse="\n"))
}

```
!END_CHANGE_FILE R/t_replace.R

!CHANGE_FILE R/t_reshape.R
```R
# Translate Stata 'reshape' command
# Stata: reshape wide/long stubnames, i(varlist) [j(varname) | j(varname) string] [options]
# This is a complex command. Basic translation using tidyr.

t_reshape = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_reshape") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse wide/long, stubnames, options
  # Pattern: ^\s*(wide|long)\s+(.*?)(?:,\\s*(.*))?$
  # G1: type (wide/long), G2: stubnames/varlist, G3: options

  reshape_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(wide|long)\\s+(.*?)(?:,\\s*(.*))?$")

  if (is.na(reshape_match[1,1])) {
    return(paste0("# Failed to parse reshape command: ", rest_of_cmd))
  }

  reshape_type = reshape_match[1,2]
  stubnames_or_varlist_str = stringi::stri_trim_both(reshape_match[1,3])
  options_str = stringi::stri_trim_both(reshape_match[1,4]) # NA if no options

  stubnames_or_varlist = stringi::stri_split_regex(stubnames_or_varlist_str, "\\s+")[[1]]
  stubnames_or_varlist = stubnames_or_varlist[stubnames_or_varlist != ""]
  if (length(stubnames_or_varlist) == 0) {
       return(paste0("# reshape command requires stubnames or varlist: ", rest_of_cmd))
  }


  # Parse required options: i() and j()
  i_vars = NA_character_
  j_var = NA_character_
  j_is_string = FALSE # Stata j() can create numeric or string j variable

  if (!is.na(options_str)) {
      i_opt_match = stringi::stri_match_first_regex(options_str, "\\bi\\s*\\(([^)]+)\\)")
      if (!is.na(i_opt_match[1,1])) {
           i_vars = stringi::stri_trim_both(i_opt_match[1,2])
      }

      j_opt_match = stringi::stri_match_first_regex(options_str, "\\bj\\s*\\(([^)]+)\\)")
      if (!is.na(j_opt_match[1,1])) {
           j_part = stringi::stri_trim_both(j_opt_match[1,2])
           # Check if j part contains 'string' option
           j_string_match = stringi::stri_match_first_regex(j_part, "^\\s*([a-zA-Z_][a-zA-Z0-9_]*)(?:\\s+string)?$")
           if (!is.na(j_string_match[1,1])) {
               j_var = j_string_match[1,2]
               j_is_string = !is.na(stringi::stri_match_first_regex(j_part, "\\s+string$")[1,1])
           }
      }
  }

  if (is.na(i_vars) || i_vars == "") {
      return(paste0("# reshape command requires i() variable(s): ", rest_of_cmd))
  }
  i_vars_list = stringi::stri_split_regex(i_vars, "\\s+")[[1]]
  i_vars_list = i_vars_list[i_vars_list != ""]
  i_vars_r_vec_str = paste0('c("', paste(i_vars_list, collapse = '", "'), '")')

  if (is.na(j_var) || j_var == "") {
       # j() is required unless the data is already structured s.t. it's obvious.
       # Stata infers j if possible, but usually j() is explicitly required.
       # For translation, let's assume j() is required.
       return(paste0("# reshape command requires j() variable: ", rest_of_cmd))
  }


  r_code_str = ""

  if (reshape_type == "wide") {
      # Stata `reshape wide stubnames, i(i) j(j)`
      # R `tidyr::pivot_wider(data, id_cols = i_vars, names_from = j_var, values_from = stubnames)`
      # Multiple stubnames means values_from is a vector of stubnames.
      # If stubnames are `inc limit`, R columns become inc_1990, inc_1991, limit_1990, limit_1991
      # Stata by default creates `stubnamejvalue` columns.
      # tidyr default is `stubname_jvalue`. Can control with `names_sep` or `names_from` + `values_from`.
      # Let's use default `names_sep = "_"` for now.

      stubnames_r_vec_str = paste0('c("', paste(stubnames_or_varlist, collapse = '", "'), '")')

      r_code_str = paste0("data = tidyr::pivot_wider(data, id_cols = dplyr::all_of(", i_vars_r_vec_str, "), names_from = ", j_var, ", values_from = dplyr::all_of(", stubnames_r_vec_str, "))")

  } else if (reshape_type == "long") {
      # Stata `reshape long stubnames, i(i) j(jname)`
      # R `tidyr::pivot_longer(data, cols = c(list of stubnames), names_to = jname, values_to = value_name)`
      # Stata: `reshape long inc limit, i(id) j(year)` -> creates `id`, `year`, `inc`, `limit`
      # tidyr: `pivot_longer(..., names_to = "year", values_to = "value")` default puts all values in 'value'.
      # If multiple stubnames, tidyr can gather them separately.
      # `pivot_longer(..., names_to = c(".value", "year"), names_sep = "_")` if original cols were `inc_1990`, `limit_1990`, etc.

      # The `stubnames_or_varlist` for long format lists the *stubnames* (e.g., "inc", "limit").
      # The actual columns to gather are inferred from these stubs and the values of the `j` variable.
      # This translation assumes that the wide variables are named `stubname` + `j_value`.
      # e.g., for `stubnames = c("inc", "limit")` and `j_var = "year"`,
      # it expects columns like `inc1990`, `inc1991`, `limit1990`, `limit1991`.

      # Construct the `cols` argument for `pivot_longer`
      # Stata's reshape long can infer columns, e.g., `reshape long income, i(id) j(year)` implies `income*`
      # `reshape long income educ, i(id) j(year)` implies `income*` and `educ*`
      # dplyr::matches is suitable for this.
      cols_to_gather_regex = paste0("^(", paste(stubnames_or_varlist, collapse = "|"), ")")
      cols_to_gather_expr = paste0("dplyr::matches(\"", cols_to_gather_regex, "\")")


      # Construct the `names_pattern` to capture stubname and j_value
      # e.g., (inc|limit)(\\d+)
      names_pattern = paste0("^(", paste(stubnames_or_varlist, collapse = "|"), ")(.*)$")

      # names_to should be c(".value", j_var) to create new columns for each stubname
      # .value will map the captured stubname part to the correct column name (e.g., "income", "educ")
      names_to_r = paste0('c(".value", "', j_var, '")')

      r_code_str = paste0("data = tidyr::pivot_longer(data, cols = ", cols_to_gather_expr, ", names_to = ", names_to_r, ", names_pattern = \"", names_pattern, "\")")

      # If j() string option was NOT used, need to convert the resulting j_var to numeric.
      # tidyr's names_pattern captures as string by default.
      if (!j_is_string) {
         # Convert j_var to numeric after reshape
         r_code_str = paste0(r_code_str, " %>%\n  dplyr::mutate(", j_var, " = as.numeric(", j_var, "))")
      }

  } else {
      r_code_str = paste0("# Unknown reshape type: ", reshape_type)
  }

  # Add comment about options if any were present but not handled
  if (!is.na(options_str) && !grepl("\\bi\\s*\\([^)]+\\)", options_str) && !grepl("\\bj\\s*\\([^)]+\\)", options_str)) {
       r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str))
  }


  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_reshape.R

!CHANGE_FILE R/t_save.R
```R
# Translate Stata 'save' command
# Stata: save [filename] [, options]
# Options: replace, emptyok, old (version control)
t_save = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_save") # Added restore.point
  # Parse filename and options
  # Example: save "mydata.dta", replace
  # Example: save `tempfile_macro`, replace

  parts = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*([^,]*?)(?:,\\s*(.*))?$")
  raw_filename_token = stringi::stri_trim_both(parts[1,2]) # Can be empty (uses last used filename)
  options_part = stringi::stri_trim_both(parts[1,3])  # NA if no options

  filename_r_expr = "" # Resulting R path string or variable name

  if (is.na(raw_filename_token) || raw_filename_token == "") {
    return("# `save` without filename not fully supported yet. Needs to track original data filename.")
  }

  filename_r_expr = resolve_stata_filename(raw_filename_token, cmd_df, line_num, default_base_dir_var = "working_dir")

  r_code = paste0("haven::write_dta(data, path = ", filename_r_expr, ")")
  
  if (!is.na(options_part) && options_part != "") {
    r_code = paste0(r_code, paste0(" # Options ignored: ", options_part))
  }

  return(r_code)
}

```
!END_CHANGE_FILE R/t_save.R

!CHANGE_FILE R/t_sort.R
```R
# Translate Stata 'sort' and 'gsort' commands
# Stata: sort varlist
# Stata: gsort [+|-]varname [[+|-]varname ...]
t_sort = function(rest_of_cmd, cmd_obj, cmd_df, line_num, type = "sort") {
  restore.point("t_sort") # Added restore.point
  if (is.na(rest_of_cmd) || rest_of_cmd == "") {
    return("# sort/gsort command with no variables specified.")
  }

  varlist = stringi::stri_trim_both(rest_of_cmd)
  vars = stringi::stri_split_regex(varlist, "\\s+")[[1]]
  vars = vars[vars != ""] # Filter out empty strings from splitting

  if (length(vars) == 0) {
    return("# sort/gsort command with no effectively parsed variables.")
  }

  if (type == "sort") {
    # Plain sort is ascending for all variables
    # Using dplyr::arrange with !!!dplyr::syms for consistency and robustness
    sort_vars_r = paste0('!!!dplyr::syms(c("', paste(vars, collapse='", "'), '"))')
    r_code_str = paste0("data = dplyr::arrange(data, ", sort_vars_r, ")")

  } else if (type == "gsort") {
    # gsort allows specifying ascending (+) or descending (-) for each variable
    # +var (ascending, default if no sign)
    # -var (descending)
    # dplyr: arrange(var1, desc(var2), ...)
    arrange_expressions = character(length(vars))
    for (i in seq_along(vars)) {
      var_spec = vars[i]
      if (stringi::stri_startswith_fixed(var_spec, "-")) {
        var_name = stringi::stri_sub(var_spec, 2)
        arrange_expressions[i] = paste0("dplyr::desc(!!!dplyr::syms(\"", var_name, "\"))")
      } else if (stringi::stri_startswith_fixed(var_spec, "+")) {
        var_name = stringi::stri_sub(var_spec, 2)
        arrange_expressions[i] = paste0("!!!dplyr::syms(\"", var_name, "\")")
      } else {
        arrange_expressions[i] = paste0("!!!dplyr::syms(\"", var_spec, "\")")
      }
    }
    r_code_str = paste0("data = dplyr::arrange(data, ", paste(arrange_expressions, collapse = ", "), ")")
  } else {
    r_code_str = paste0("# Unknown sort type: ", type)
  }

  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_sort.R

!CHANGE_FILE R/t_summarize.R
```R
# Translate Stata 'summarize' or 'su' command
t_summarize = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_summarize") # Added restore.point
  # Stata: summarize varlist [if] [in] [weight] [, options]
  # Options: detail, meanonly, format, separator(#), nolabel
  # Stores results in r()

  parts = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*([^,]*?)(?:,\\s*(.*))?$")
  varlist_and_cond_str = stringi::stri_trim_both(parts[1,2]) # This may contain "var1 var2 if condition"
  options_str = stringi::stri_trim_both(parts[1,3]) # NA if no options

  # Separate varlist from if condition
  stata_if_cond_expr = NA_character_
  varlist_str = varlist_and_cond_str
  if_cond_match = stringi::stri_match_first_regex(varlist_and_cond_str, "\\s+if\\s+(.*)$")
  if(!is.na(if_cond_match[1,1])) {
      stata_if_cond_expr = if_cond_match[1,2]
      varlist_str = stringi::stri_replace_all_fixed(varlist_and_cond_str, if_cond_match[1,1], "")
      varlist_str = stringi::stri_trim_both(varlist_str)
  }

  vars_to_summarize = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_summarize = vars_to_summarize[vars_to_summarize != ""]

  # For r() values, Stata's summarize without a varlist summarizes all variables,
  # but r() values like r(mean) refer to the mean of the *last* variable in the dataset.
  # If a varlist is specified, r() values refer to the *last* variable in the varlist.
  # This makes it hard to perfectly emulate without knowing data column order.
  # For now, if varlist is empty, we only set r(N). If not empty, we use the last variable.
  var_for_r_vals = NA_character_
  if (length(vars_to_summarize) > 0) {
      var_for_r_vals = vars_to_summarize[length(vars_to_summarize)] # Last variable in varlist
  } else {
      # If no varlist, r(N) is total observations. Other r() values are for the last variable.
      # We cannot reliably determine the "last variable" in R without knowing the dataframe's current state and order.
      # For now, if no varlist, we only define r(N).
  }


  is_meanonly = !is.na(options_str) && stringi::stri_detect_fixed(options_str, "meanonly")
  is_detail = !is.na(options_str) && stringi::stri_detect_fixed(options_str, "detail")

  r_code_lines = c()
  line_prefix = paste0("stata_r_val_L", cmd_obj$line, "_") # Use cmd_obj$line

  # Prepare data subset if "if condition" is present
  data_source_for_summary = "data"
  if (!is.na(stata_if_cond_expr)) {
    r_subset_cond = translate_stata_expression_with_r_values(stata_if_cond_expr, cmd_obj$line, cmd_df, context = list(is_by_group = FALSE))
    data_subset_varname = paste0("data_subset_L", cmd_obj$line)
    r_code_lines = c(r_code_lines, paste0(data_subset_varname, " = dplyr::filter(data, ", r_subset_cond, ")"))
    data_source_for_summary = data_subset_varname
  }

  # Always set r(N) as it's for the number of observations processed.
  r_code_lines = c(r_code_lines, paste0(line_prefix, "N = NROW(", data_source_for_summary, ")"))

  if (!is.na(var_for_r_vals)) {
      # Use base R / dplyr functions for summaries
      if (is_meanonly) {
        r_code_lines = c(
          r_code_lines,
          paste0(line_prefix, "mean = mean(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)")
        )
      } else { # Default summarize or with other options (detail implies more)
        r_code_lines = c(
          r_code_lines,
          paste0(line_prefix, "mean = mean(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"),
          paste0(line_prefix, "sd = stats::sd(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"),
          paste0(line_prefix, "min = min(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"),
          paste0(line_prefix, "max = max(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"),
          paste0(line_prefix, "sum = sum(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)")
        )
        if (is_detail) {
          r_code_lines = c(
            r_code_lines,
            paste0(line_prefix, "p50 = stats::median(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)")
            # Further percentiles (p1, p5, etc.), variance, skewness, kurtosis for detail are not yet implemented.
          )
        }
      }
  } else {
      r_code_lines = c(r_code_lines, paste0("# No variable specified for summarize: r(mean), r(sd), etc. not set."))
  }


  if (data_source_for_summary != "data") {
      # Clean up temporary subsetted dataframe
      r_code_lines = c(r_code_lines, paste0("rm(", data_subset_varname, ")"))
  }

  return(paste(r_code_lines, collapse="\n"))
}

```
!END_CHANGE_FILE R/t_summarize.R

!CHANGE_FILE R/t_tempfile.R
```R
# Translate Stata 'tempfile' command
# Stata: tempfile macroname1 [macroname2 ...]
t_tempfile = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_tempfile") # Added restore.point
  macro_names = stringi::stri_split_regex(stringi::stri_trim_both(rest_of_cmd), "\\s+")[[1]]
  macro_names = macro_names[macro_names != ""]

  if (length(macro_names) == 0) {
    return("# tempfile command with no macro names specified.")
  }

  r_code_lines = c()
  for (macro_name in macro_names) {
    # Stata `tempfile t1` creates a temporary filename and stores it in macro `t1`.
    # R equivalent: `temp_file_path = tempfile()`
    # We need to store this path in an R variable that subsequent commands (`save`, `use`, `merge`) can find
    # Convention: R_tempfile_L<line_num>_<macroname>_path
    # If the tempfile is used to store an R dataframe object (not just path), then R_tempdata_L...

    r_var_path = paste0("R_tempfile_L", line_num, "_", macro_name, "_path")
    # The R code generated will create this variable in its execution environment.
    r_code_lines = c(r_code_lines, paste0(r_var_path, " = tempfile(fileext = '.dta') # Stata tempfile '", macro_name, "'"))
  }

  return(paste(r_code_lines, collapse="\n"))
}

```
!END_CHANGE_FILE R/t_tempfile.R

!CHANGE_FILE R/t_use.R
```R
t_use = function(rest_of_cmd, cmd_obj, cmd_df, line_num) {
  restore.point("t_use")
  # Example: use "filename.dta", clear
  #          use "`macroname'", clear

  parts = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*(\"[^\"]+\"|`[^']+'|[^,\\s]+)\\s*(?:,\\s*(clear))?")
  # Group 1: filename (quoted or macro or unquoted literal)
  # Group 2: clear (optional)

  if (is.na(parts[1,1])) {
    return(paste0("# Failed to parse use command: ", rest_of_cmd))
  }

  raw_filename_token = parts[1,2]
  clear_opt = parts[1,3] # NA if not present, "clear" if present

  # Stata 'use filename' defaults to look in current working directory.
  # The 'working_dir' in stata2r_env represents this.
  # 'data_dir' is primarily for reference comparison files, or when explicitly specified via `using`.
  filename_r_expr = resolve_stata_filename(raw_filename_token, cmd_df, line_num, default_base_dir_var = "working_dir")

  r_code = paste0("data = haven::read_dta(", filename_r_expr, ")")

  # Add a column to preserve the original row order, for use in `egen group()`/`tag()`
  r_code = paste0(r_code, " %>%\n  dplyr::mutate(stata2r_original_order_idx = dplyr::row_number())")

  # `clear` option in Stata allows overwriting. R `read_dta` just overwrites.
  # So no special handling needed for `clear` in R code.
  # Using haven::read_dta
  # Assuming Stata .dta files. If other types, logic needs extension.

  # Add a comment about 'clear' if it was used
  if (!is.na(clear_opt)) {
    r_code = paste0(r_code, " # 'clear' was used")
  }

  return(r_code)
}

```
!END_CHANGE_FILE R/t_use.R
