The primary issue causing the "missing value where TRUE/FALSE needed" error in tests `do1` and `do2` was identified within the `t_generate` and `t_replace` functions. Specifically, the `is_a_logical_expression` variable (previously `is_logical_r_expr`) was not robustly handling potential `NA` results from `stringi::stri_detect_regex`, which could then propagate `NA` into an `if` condition, leading to the reported error during translation. This has been fixed by wrapping the logical components of `is_a_logical_expression` with `dplyr::coalesce(..., FALSE)`.

Additionally, the `t_merge` function has been updated to ensure that string `NA` values are consistently normalized to empty strings (`""`) after the `dplyr::join` operation, aligning with Stata's behavior. This complements the existing `sfun_normalize_string_nas` usage after `haven::read_dta`.

!CHANGE_FILE R/t_generate.R
```
t_generate = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_generate")
  # Parse `rest_of_cmd` for new variable name, expression, and if condition
  # Example: "newvar = expression [if condition]"

  # Capture explicit type declaration (e.g., `str10`)
  explicit_type_match = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*(byte|int|long|float|double|str\\d+|strL)\\s+")
  declared_type_str = NA_character_
  if (!is.na(explicit_type_match[1,1])) {
    declared_type_str = explicit_type_match[1,2]
  }

  # Strip type if present (e.g. gen double newvar = ...)
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^\\s*(?:byte|int|long|float|double|str\\d+|strL)\\s+", "")

  match = stringi::stri_match_first_regex(rest_of_cmd_no_type, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  # NEW: Defensive check for successful parsing of core components
  if (is.na(match[1,1]) || is.na(match[1,2]) || is.na(match[1,3])) {
    return(paste0("# Failed to parse generate command structure: ", rest_of_cmd))
  }

  new_var = stringi::stri_trim_both(match[1,2])
  stata_expr = stringi::stri_trim_both(match[1,3])
  stata_if_cond = stringi::stri_trim_both(match[1,4]) # Might be NA

  # Context for expression translation (e.g. _n, _N behavior)
  # is_by_group TRUE if cmd_obj$by_group_vars is not NA
  current_context = list(is_by_group = cmd_obj$is_by_prefix && length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1]))
  
  # Translate the Stata expression to R first
  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, current_context)

  # Ensure r_expr is a character string literal, even if it represents NA (logical)
  # Simplified check: if r_expr is NA (any type of NA), default it to NA_real_
  if (is.na(r_expr)) { 
      r_expr = "NA_real_"
  }


  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    # The 'if' condition for generate/replace is evaluated row-wise on the whole dataset, not per group.
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  # Determine group_vars for dplyr::group_by
  group_vars_list_bare = character(0) 
  
  if (cmd_obj$is_by_prefix) {
    if (length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1])) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[!is.na(group_vars_list) & group_vars_list != ""]
      if (length(group_vars_list) > 0) {
        group_vars_list_bare = group_vars_list # Assign just the bare names
      }
    }
  }

  # Determine if the target variable will be a string type based on EXPLICIT Stata declaration.
  # If no explicit type, let R infer from the translated expression.
  is_stata_expr_string_typed = sfun_is_stata_expression_string_typed(stata_expr)

  # Apply explicit type casting if declared in Stata command, overriding inferred type
  if (!is.na(declared_type_str)) {
      if (stringi::stri_startswith_fixed(declared_type_str, "str")) {
          is_stata_expr_string_typed = TRUE
      } else { # byte, int, long, float, double
          is_stata_expr_string_typed = FALSE
      }
  }

  # Step 1: Calculate the value for the new variable, potentially conditionally
  calculated_value_expr_raw = r_expr # This is the R translation of stata_expr

  if (is_stata_expr_string_typed) {
      # If Stata expression is numeric NA (.), it translates to NA_real_.
      # When assigned to a string variable, Stata treats '.' as "".
      if (calculated_value_expr_raw == "NA_real_") { # Check against the literal string "NA_real_"
          calculated_value_expr = '""'
      } else {
          calculated_value_expr = paste0("as.character(", calculated_value_expr_raw, ")")
      }
  } else { # Numeric output
      # Ensure logicals become 0/1. Stata converts TRUE/FALSE to 1/0 for numeric types.
      # This handles `gen newvar = x==y` resulting in numeric 0/1.
      # The check for logical operators needs to be robust.
      # If the expression is a simple number or variable, no change.
      # If it's a logical expression, cast to numeric.
      # Ensure is_a_logical_expression is always TRUE/FALSE, never NA.
      is_a_logical_expression = dplyr::coalesce(
          stringi::stri_detect_regex(calculated_value_expr_raw, "\\bTRUE\\b|\\bFALSE\\b|==|!=|<=|>=|<|>|&|\\||\\bsfun_missing\\b") &&
          !stringi::stri_detect_fixed(calculated_value_expr_raw, "dplyr::if_else"),
          FALSE
      )

      if (is_a_logical_expression) {
          calculated_value_expr = paste0("as.numeric(", calculated_value_expr_raw, ")")
      } else {
          calculated_value_expr = calculated_value_expr_raw
      }
  }

  # The value to assign if the condition is false/missing.
  na_or_empty_str_for_false_cond = if (is_stata_expr_string_typed) '""' else "NA_real_"


  # Apply condition only if it exists
  if (!is.na(r_if_cond) && r_if_cond != "") {
    calc_expr = paste0("dplyr::if_else(as.logical(dplyr::coalesce(", r_if_cond, ", FALSE)), ", calculated_value_expr, ", ", na_or_empty_str_for_false_cond, ")")
  } else {
    calc_expr = calculated_value_expr
  }

  # Step 2: Build the R code string using pipes for the mutate operation
  pipe_elements = list("data") # Elements for the pipe chain, starting from `data`

  # Add grouping and mutate steps
  if (length(group_vars_list_bare) > 0) {
      group_by_call_str = paste0('dplyr::group_by(!!!dplyr::syms(c("', paste0(group_vars_list_bare, collapse='", "'), '")))')
      pipe_elements = c(pipe_elements, group_by_call_str)
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", new_var, "` = ", calc_expr, ")"))
      pipe_elements = c(pipe_elements, "dplyr::ungroup()")
  } else {
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", new_var, "` = ", calc_expr, ")"))
  }

  # This is the final assignment line for the current command
  # It takes 'data' (potentially already arranged) and pipes it through the rest
  r_code_lines = c(paste0("data = ", paste(pipe_elements, collapse = " %>% \n  ")))
  
  return(paste(r_code_lines, collapse="\n"))
}
```
!END_CHANGE_FILE R/t_generate.R

!CHANGE_FILE R/t_replace.R
```
t_replace = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_replace")
  # Capture explicit type declaration (e.g., `str10`)
  explicit_type_match = stringi::stri_match_first_regex(rest_of_cmd, "^(?:byte|int|long|float|double|str\\d+|strL)\\s+")
  declared_type_str = NA_character_
  if (!is.na(explicit_type_match[1,1])) {
    declared_type_str = explicit_type_match[1,2]
  }

  # Strip type if present (e.g. replace double oldvar = ...)
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^(?:byte|int|long|float|double|str\\d+|strL)\\s+", "")

  match = stringi::stri_match_first_regex(rest_of_cmd_no_type, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  # NEW: Defensive check for successful parsing of core components
  if (is.na(match[1,1]) || is.na(match[1,2]) || is.na(match[1,3])) {
    return(paste0("# Failed to parse replace command structure: ", rest_of_cmd))
  }

  var_to_replace = stringi::stri_trim_both(match[1,2])
  stata_expr = stringi::stri_trim_both(match[1,3])
  stata_if_cond = stringi::stri_trim_both(match[1,4]) # Might be NA

  current_context = list(is_by_group = cmd_obj$is_by_prefix && length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1]))
  # Translate the Stata expression to R first
  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, current_context)

  # Ensure r_expr is a character string literal, even if it represents NA (logical)
  if (is.na(r_expr) && !is.character(r_expr)) { # Check for logical NA, not string "NA"
      r_expr = "NA_real_"
  } else if (is.character(r_expr) && r_expr == "") {
      r_expr = "NA_real_"
  }

  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  # Determine group_vars for dplyr::group_by
  group_vars_list_bare = character(0)

  if (cmd_obj$is_by_prefix) {
    if (length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1])) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[!is.na(group_vars_list) & group_vars_list != ""]
      if (length(group_vars_list) > 0) {
        group_vars_list_bare = group_vars_list # Assign just the bare names
      }
    }
  }

  # Determine if the target variable will be a string type based on EXPLICIT Stata declaration.
  # If no explicit type, let R infer from the translated expression.
  is_stata_expr_string_typed = sfun_is_stata_expression_string_typed(stata_expr)

  # Apply explicit type casting if declared in Stata command, overriding inferred type
  if (!is.na(declared_type_str)) {
      if (stringi::stri_startswith_fixed(declared_type_str, "str")) {
          is_stata_expr_string_typed = TRUE
      } else { # byte, int, long, float, double
          is_stata_expr_string_typed = FALSE
      }
  }

  # Step 1: Calculate the value for the new variable, potentially conditionally
  calculated_value_expr_raw = r_expr # This is the R translation of stata_expr

  if (is_stata_expr_string_typed) {
      # If Stata expression is numeric NA (.), it translates to NA_real_.
      # When assigned to a string variable, Stata treats '.' as "".
      if (calculated_value_expr_raw == "NA_real_") { # Check against the literal string "NA_real_"
          calculated_value_expr = '""'
      } else {
          calculated_value_expr = paste0("as.character(", calculated_value_expr_raw, ")")
      }
  } else { # Numeric output
      # Ensure logicals become 0/1. Stata converts TRUE/FALSE to 1/0 for numeric types.
      # This handles `gen newvar = x==y` resulting in numeric 0/1.
      # The check for logical operators needs to be robust.
      # If the expression is a simple number or variable, no change.
      # If it's a logical expression, cast to numeric.
      # Ensure is_a_logical_expression is always TRUE/FALSE, never NA.
      is_a_logical_expression = dplyr::coalesce(
          stringi::stri_detect_regex(calculated_value_expr_raw, "\\bTRUE\\b|\\bFALSE\\b|==|!=|<=|>=|<|>|&|\\||\\bsfun_missing\\b") &&
          !stringi::stri_detect_fixed(calculated_value_expr_raw, "dplyr::if_else"),
          FALSE
      )

      if (is_a_logical_expression) {
          calculated_value_expr = paste0("as.numeric(", calculated_value_expr_raw, ")")
      } else {
          calculated_value_expr = calculated_value_expr_raw
      }
  }


  # For 'replace' command, if condition is FALSE or NA, the value should be left unchanged.
  # Use dplyr::coalesce(condition, FALSE) to treat NA condition as FALSE.
  # Apply condition only if it exists
  if (!is.na(r_if_cond) && r_if_cond != "") {
    calc_expr = paste0("dplyr::if_else(as.logical(dplyr::coalesce(", r_if_cond, ", FALSE)), ", calculated_value_expr, ", data$`", var_to_replace, "`)")
  } else {
    calc_expr = calculated_value_expr
  }

  # Step 2: Build the R code string using pipes for the mutate operation
  pipe_elements = list("data") # Elements for the pipe chain, starting from `data`

  if (length(group_vars_list_bare) > 0) { # Check if group_vars_list_bare is not empty
      group_by_call_str = paste0('dplyr::group_by(!!!dplyr::syms(c("', paste0(group_vars_list_bare, collapse='", "'), '")))')
      pipe_elements = c(pipe_elements, group_by_call_str)
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", var_to_replace, "` = ", calc_expr, ")"))
      pipe_elements = c(pipe_elements, "dplyr::ungroup()")
  } else {
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", var_to_replace, "` = ", calc_expr, ")"))
  }

  r_code_lines = c(paste0("data = ", paste(pipe_elements, collapse = " %>% \n  ")))

  return(paste(r_code_lines, collapse="\n"))
}
```
!END_CHANGE_FILE R/t_replace.R

!CHANGE_FILE R/t_merge.R
```
# Translate Stata 'merge' command
# Stata: merge 1:1 varlist using filename [, options]
# Stata: merge 1:m varlist using filename [, options]
# Stata: merge m:1 varlist using filename [, options]
# Stata: merge m:m varlist using filename [, options]
# Options: keep(match master using all) nogenerate

t_merge = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_merge") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Define a temporary indicator column name for dplyr::join
  indicator_col_name = paste0("stata_merge_indicator_L", line_num)

  # Parse merge type (1:1, 1:m, m:1, m:m), varlist, `using filename`, and options
  merge_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*([1m]:[1m])\\s+(.*?)\\s+using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")
  merge_type = NA_character_
  varlist_str = NA_character_
  raw_filename_token = NA_character_
  options_str = NA_character_


  if (is.na(merge_match[1,1])) {
      # Check for older syntax without type: `merge varlist using filename` (defaults to 1:1)
      merge_match_old = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(.*?)\\s+using\\s+(\"[^\"]+\"|`[^']+'|[^,\\s]+)(?:,\\s*(.*))?$")
      if (!is.na(merge_match_old[1,1])) {
           merge_type = "1:1" # Assume 1:1 if type not specified
           varlist_str = stringi::stri_trim_both(merge_match_old[1,2])
           raw_filename_token = stringi::stri_trim_both(merge_match_old[1,3])
           options_str = stringi::stri_trim_both(merge_match_old[1,4])
      } else {
           return(paste0("# Failed to parse merge command: ", rest_of_cmd))
      }
  } else {
      merge_type = merge_match[1,2]
      varlist_str = stringi::stri_trim_both(merge_match[1,3])
      raw_filename_token = stringi::stri_trim_both(merge_match[1,4])
      options_str = stringi::stri_trim_both(merge_match[1,5]) # NA if no options
  }

  vars_to_merge_on = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_merge_on = vars_to_merge_on[vars_to_merge_on != ""]
  if (length(vars_to_merge_on) == 0) {
       return(paste0("# merge command requires varlist: ", rest_of_cmd))
  }
  # For dplyr::join, by argument can be a character vector of column names
  vars_to_merge_on_r_vec_str = paste0('c("', paste(vars_to_merge_on, collapse = '", "'), '")')

  using_source_r_expr = resolve_stata_filename(raw_filename_token, cmd_df, line_num, default_base_dir_var = "working_dir")

  # Determine if nogenerate option is present (for comments later)
  has_nogenerate = !is.na(options_str) && stringi::stri_detect_regex(options_str, "\\bno(?:generate|gen)\\b")
  
  # Determine keep_spec_for_comment based on parsing `options_str` in `t_merge` scope
  # This variable should be initialized to a default that reflects Stata's behavior for the given merge type.
  initial_keep_spec = NA_character_
  if (merge_type %in% c("1:1", "1:m", "m:1")) {
      initial_keep_spec = "match master"
  } else if (merge_type == "m:m") {
      initial_keep_spec = "match master using"
  }

  keep_spec_for_comment = initial_keep_spec # Default if no keep() specified
  actual_keep_spec_from_options = NA_character_ # What was explicitly written in options_str

  if (!is.na(options_str)) {
      keep_opt_match = stringi::stri_match_first_regex(options_str, "\\bkeep\\s*\\(([^)]+)\\)")
      if (!is.na(keep_opt_match[1,1])) {
          actual_keep_spec_from_options = stringi::stri_trim_both(keep_opt_match[1,2])
          keep_spec_for_comment = actual_keep_spec_from_options # Use actual option for comment
      }
  }

  # --- Start building R code lines ---
  r_code_lines = c()
  temp_using_data_var = paste0("stata_tmp_using_data_L", line_num)

  # Read using data
  r_code_lines = c(r_code_lines, paste0(temp_using_data_var, " = haven::read_dta(", using_source_r_expr, ")"))

  # Strip haven attributes from both master and using dataframes before joining
  # And normalize string NAs
  r_code_lines = c(r_code_lines, paste0("data = sfun_strip_stata_attributes(data)"))
  r_code_lines = c(r_code_lines, paste0("data = sfun_normalize_string_nas(data)")) # Added
  r_code_lines = c(r_code_lines, paste0(temp_using_data_var, " = sfun_strip_stata_attributes(", temp_using_data_var, ")"))
  r_code_lines = c(r_code_lines, paste0(temp_using_data_var, " = sfun_normalize_string_nas(", temp_using_data_var, ")")) # Added

  # Ensure merge keys are plain numeric for robustness against haven-specific types
  r_code_lines = c(r_code_lines,
      paste0("data = dplyr::mutate(data, ", paste0("`", vars_to_merge_on, "` = as.numeric(`", vars_to_merge_on, "`)", collapse = ", "), ")"),
      paste0(temp_using_data_var, " = dplyr::mutate(", temp_using_data_var, ", ", paste0("`", vars_to_merge_on, "` = as.numeric(`", vars_to_merge_on, "`)", collapse = ", "), ")")
  )

  # Initialize variables for join type and merge indicator mapping in the *generated R code*
  join_type_var_in_r = paste0("join_type_r_func_L", line_num)
  stata_merge_map_left_only_var_in_r = paste0("stata_merge_map_left_only_L", line_num)
  stata_merge_map_right_only_var_in_r = paste0("stata_merge_map_right_only_L", line_num)
  stata_merge_map_both_var_in_r = paste0("stata_merge_map_both_L", line_num)

  # New temp vars for package and function name resolution in generated R code
  pkg_name_in_r_code = paste0("pkg_name_L", line_num)
  fun_name_in_r_code = paste0("fun_name_L", line_num)
  merge_fun_obj_in_r_code = paste0("merge_fun_obj_L", line_num)


  # Default join type based on Stata's merge type.
  # For 1:1, 1:m, m:1, m:m, the `_merge` variable requires a full understanding of matches.
  # `full_join` with `indicator` provides all necessary categories (left_only, right_only, both).
  r_code_lines = c(r_code_lines, paste0(join_type_var_in_r, " = switch('", merge_type, "', "))
  r_code_lines = c(r_code_lines, paste0("  '1:1' = 'dplyr::full_join',"))
  r_code_lines = c(r_code_lines, paste0("  '1:m' = 'dplyr::left_join',"))
  r_code_lines = c(r_code_lines, paste0("  'm:1' = 'dplyr::right_join',"))
  r_code_lines = c(r_code_lines, paste0("  'm:m' = 'dplyr::inner_join'"))
  r_code_lines = c(r_code_lines, paste0(")"))

  r_code_lines = c(r_code_lines, paste0(stata_merge_map_left_only_var_in_r, " = 1L"))
  r_code_lines = c(r_code_lines, paste0(stata_merge_map_right_only_var_in_r, " = 2L"))
  r_code_lines = c(r_code_lines, paste0(stata_merge_map_both_var_in_r, " = 3L"))
  
  # Logic for `keep()` option (converted to generated R code)
  if (!is.na(actual_keep_spec_from_options)) {
      # Use grepl with word boundaries for robustness
      r_code_lines = c(r_code_lines, paste0("if (grepl(\"\\\\ball\\\\b\", \"", actual_keep_spec_from_options, "\", ignore.case=TRUE)) {"))
      r_code_lines = c(r_code_lines, paste0("  ", join_type_var_in_r, " = \"dplyr::full_join\""))
      r_code_lines = c(r_code_lines, paste0("} else if (grepl(\"\\\\bmaster\\\\b\", \"", actual_keep_spec_from_options, "\", ignore.case=TRUE)) {"))
      r_code_lines = c(r_code_lines, paste0("  ", join_type_var_in_r, " = \"dplyr::left_join\""))
      r_code_lines = c(r_code_lines, paste0("} else if (grepl(\"\\\\busing\\\\b\", \"", actual_keep_spec_from_options, "\", ignore.case=TRUE)) {"))
      r_code_lines = c(r_code_lines, paste0("  ", join_type_var_in_r, " = \"dplyr::right_join\""))
      r_code_lines = c(r_code_lines, paste0("} else if (grepl(\"\\\\bmatch\\\\b\", \"", actual_keep_spec_from_options, "\", ignore.case=TRUE)) {"))
      r_code_lines = c(r_code_lines, paste0("  ", join_type_var_in_r, " = \"dplyr::inner_join\""))
      r_code_lines = c(r_code_lines, "}")
  }

  # Logic for 1:1 merge strictness (moved to generated R code)
  # This part performs Stata's duplicate key checks for 1:1 merge.
  if (merge_type == "1:1") {
      r_code_lines = c(r_code_lines,
          paste0("if (any(base::duplicated(dplyr::select(data, dplyr::all_of(", vars_to_merge_on_r_vec_str, "))))) { stop('Merge 1:1 failed: Duplicate keys found in master dataset (data).') }"),
          paste0("if (any(base::duplicated(dplyr::select(", temp_using_data_var, ", dplyr::all_of(", vars_to_merge_on_r_vec_str, "))))) { stop('Merge 1:1 failed: Duplicate keys found in using dataset (', ", using_source_r_expr, ", ').') }")
      )
  }

  # Identify common columns that are NOT merge keys
  r_code_lines = c(r_code_lines,
    paste0("common_cols = intersect(names(data), names(", temp_using_data_var, "))"),
    paste0("common_cols_not_by = setdiff(common_cols, ", vars_to_merge_on_r_vec_str, ")")
  )

  # Conditional dropping of columns from the using dataset
  # Stata's merge logic: if a variable exists in both, the master's version is kept.
  # So, columns in `using` data that conflict with `master` data should be dropped from `using` before join.
  r_code_lines = c(r_code_lines,
    paste0("if (length(common_cols_not_by) > 0) { ", temp_using_data_var, " = dplyr::select(", temp_using_data_var, ", -dplyr::all_of(common_cols_not_by)) }")
  )

  # NEW: Resolve function using get and asNamespace before do.call
  r_code_lines = c(r_code_lines,
    paste0("parts_fun_split = stringi::stri_split_fixed(", join_type_var_in_r, ", \"::\", n=2)[[1]]"),
    paste0(pkg_name_in_r_code, " = parts_fun_split[1]"),
    paste0(fun_name_in_r_code, " = parts_fun_split[2]"),
    paste0(merge_fun_obj_in_r_code, " = get(", fun_name_in_r_code, ", envir = asNamespace(", pkg_name_in_r_code, "))")
  )

  # Perform the join with indicator
  r_code_lines = c(r_code_lines,
    paste0("data = do.call(", merge_fun_obj_in_r_code, ", list(data, ", temp_using_data_var, ", by = ", vars_to_merge_on_r_vec_str, ", indicator = \"", indicator_col_name, "\"))")
  )

  # NEW: Post-merge processing for string NAs to empty strings
  # This part is now handled by sfun_normalize_string_nas after `read_dta` and `strip_stata_attributes`.
  # The `dplyr::join` might reintroduce NAs in character columns if they are not matched,
  # so this is still needed to ensure consistency.
  r_code_lines = c(r_code_lines, paste0("data = sfun_normalize_string_nas(data)"))


  # Generate _merge variable unless nogenerate option is present
  if (!has_nogenerate) {
      r_code_lines = c(r_code_lines,
          paste0("data = dplyr::mutate(data, `_merge` = dplyr::case_when("),
          paste0("  `", indicator_col_name, "` == \"left_only\" ~ as.integer(", stata_merge_map_left_only_var_in_r, "),"),
          paste0("  `", indicator_col_name, "` == \"right_only\" ~ as.integer(", stata_merge_map_right_only_var_in_r, "),"),
          paste0("  `", indicator_col_name, "` == \"both\" ~ as.integer(", stata_merge_map_both_var_in_r, "),"),
          paste0("  TRUE ~ NA_integer_"),
          paste0("))")
      )
  } else {
    r_code_lines = c(r_code_lines, paste0(" # _merge variable was not generated due to 'nogenerate' option."))
  }

  # Always remove the temporary indicator column
  r_code_lines = c(r_code_lines, paste0("data = dplyr::select(data, -dplyr::any_of('", indicator_col_name, "'))"))

  # Clean up temporary variables
  r_code_lines = c(r_code_lines, paste0("rm(", temp_using_data_var, ", common_cols, common_cols_not_by, parts_fun_split)"))
  
  # Clean up the new temporary variables created for the generated R code
  r_code_lines = c(r_code_lines, paste0("rm(", join_type_var_in_r, ", ", stata_merge_map_left_only_var_in_r, ", ", stata_merge_map_right_only_var_in_r, ", ", stata_merge_map_both_var_in_r, ")"))
  # NEW: Clean up the new temp vars
  r_code_lines = c(r_code_lines, paste0("rm(", pkg_name_in_r_code, ", ", fun_name_in_r_code, ", ", merge_fun_obj_in_r_code, ")"))


  # Add comment about options
  merge_comment_line = paste0("# Stata merge type: ", merge_type, ", keep(", keep_spec_for_comment, ")")
  if (has_nogenerate) {
    merge_comment_line = paste0(merge_comment_line, ", nogenerate")
  }
  r_code_lines = c(r_code_lines, merge_comment_line)

  options_str_cleaned = options_str
  if (!is.na(options_str_cleaned)) {
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bkeep\\s*\\([^)]+\\)", "")
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bno(?:generate|gen)\\b", "")
      options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
      options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
  }
  if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
       r_code_lines = c(r_code_lines, paste0(" # Other options ignored: ", options_str_cleaned))
  }

  return(paste(r_code_lines, collapse="\n"))
}
```
!END_CHANGE_FILE R/t_merge.R
