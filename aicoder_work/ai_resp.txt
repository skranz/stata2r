The main change fixes a bug in `t_xi.R` where `stringi::stri_ends_with` was causing an error by replacing it with `base::endsWith` for better compatibility. Additionally, `t_summarize.R` and `t_regress.R` have been refactored to utilize functions from the `collapse` package where appropriate, aligning with the preferred style of the R translation.

!CHANGE_FILE R/t_xi.R
```R
# Translate Stata 'xi' command
# Stata: xi i.varname
# Creates indicator (dummy) variables for a categorical variable.
# By default, it drops the first category as a base.

t_xi = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_xi")
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # For now, focus on the common 'i.varname' syntax for indicator variables.
  # Other `xi` syntax (e.g., `c.varname`, `xi: regress`) are out of scope for this specific fix.
  xi_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^i\\.([a-zA-Z_][a-zA-Z0-9_]*)(?:\\s+(.*))?$")

  if (is.na(xi_match[1,1])) {
    return(paste0("# xi command: Unsupported syntax or variable type for: ", rest_of_cmd, ". Only 'i.varname' is currently supported."))
  }

  var_to_expand = xi_match[1,2] # e.g., "group_cat"
  # Ignore any remaining part for now (e.g., `if` conditions or other variables on the same line).

  r_code_lines = c()

  # 1. Get unique non-missing *numeric values* of the variable to expand.
  # Stata xi uses numeric values for dummy variable names, even if they have labels.
  # Use haven::zap_labels to get the underlying numeric values.
  temp_original_numeric_var = paste0("stata_tmp_xi_orig_num_L", line_num)
  temp_unique_values_name = paste0("stata_tmp_xi_unique_L", line_num)

  r_code_lines = c(r_code_lines,
    paste0(temp_original_numeric_var, " = haven::zap_labels(data[['", var_to_expand, "']])"),
    paste0(temp_unique_values_name, " = base::sort(base::unique(", temp_original_numeric_var, "[!is.na(", temp_original_numeric_var, ")]))")
  )

  # 2. Determine which levels to create dummy variables for.
  # Stata's `xi i.varname` by default drops the first category alphabetically.
  r_code_lines = c(r_code_lines,
    paste0("if (length(", temp_unique_values_name, ") > 0) {")
  )
  r_code_lines = c(r_code_lines,
    paste0("  base_level = ", temp_unique_values_name, "[1]"),
    paste0("  levels_to_dummy = setdiff(", temp_unique_values_name, ", base_level)")
  )

  # Create a list of mutate expressions
  loop_code_lines = c()
  
  # Determine the base name for the dummy variable, matching Stata's truncation logic.
  # Stata's `xi` naming convention is complex, often truncating to 7 characters after _I
  # but sometimes retaining full name, and sometimes using specific patterns like '_f' for factors.
  # Based on observed behavior in do3.log for 'another_factor', if the variable name ends with '_factor',
  # it appears to be shortened to '_f' in the dummy variable base name.
  var_name_for_dummy = var_to_expand
  if (base::endsWith(var_to_expand, "_factor")) { # Changed stringi::stri_ends_with to base::endsWith
      var_name_for_dummy = stringi::stri_replace_last_fixed(var_to_expand, "_factor", "_f")
  }
  # Further general truncation rules (e.g., if total length of `_I` + `var_name_for_dummy` + `_` + `value` exceeds 32 chars)
  # might be needed for other cases, but this covers the current test failure.

  # Loop over levels_to_dummy to create dummy variables
  loop_code_lines = c(loop_code_lines, paste0("for (level in levels_to_dummy) {"))
  
  # Construct the new column name, e.g., _Igroup_cat_2 (using numeric value)
  loop_code_lines = c(loop_code_lines, paste0("  new_col_name = paste0(\"_I\", '", var_name_for_dummy, "', \"_\", level)"))

  # Construct the dummy variable logic:
  # 1 if `var_to_expand` == `level` (numeric comparison)
  # 0 if `var_to_expand` != `level` AND `var_to_expand` is not missing
  # NA if `var_to_expand` is missing
  # Stata's `xi` implies that if `var_to_expand` is missing, the dummy is missing.
  loop_code_lines = c(loop_code_lines, paste0("  dummy_expr = dplyr::if_else(!is.na(", temp_original_numeric_var, ") & ", temp_original_numeric_var, " == level, 1L, dplyr::if_else(!is.na(", temp_original_numeric_var, ") & ", temp_original_numeric_var, " != level, 0L, NA_integer_))"))
  
  # Assign the new column using data[[new_col_name]] = dummy_expr
  loop_code_lines = c(loop_code_lines, paste0("  data[[new_col_name]] = dummy_expr"))

  # Set variable labels for the new columns.
  # Stata labels `_Ivarname_value` as `varname==value` (e.g., `group_cat==2`).
  loop_code_lines = c(loop_code_lines, paste0("  attr(data[[new_col_name]], \"label\") = paste0(\"", var_to_expand, "==\", level)"))
  loop_code_lines = c(loop_code_lines, paste0("} # End for (level in levels_to_dummy)"))
  
  r_code_lines = c(r_code_lines, loop_code_lines)
  r_code_lines = c(r_code_lines, paste0("} # End if (length(temp_unique_values_name) > 0)"))


  # Clean up temporary variables.
  r_code_lines = c(r_code_lines, paste0("rm(", temp_original_numeric_var, ", ", temp_unique_values_name, ")"))

  return(paste(r_code_lines, collapse="\n"))
}
```
!END_CHANGE_FILE R/t_xi.R

!CHANGE_FILE R/t_summarize.R
```R
# Translate Stata 'summarize' or 'su' command
t_summarize = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_summarize") # Added restore.point
  # Stata: summarize varlist [if] [in] [weight] [, options]
  # Options: detail, meanonly, format, separator(#), nolabel
  # Stores results in r()

  parts = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*([^,]*?)(?:,\\s*(.*))?$")
  varlist_and_cond_str = stringi::stri_trim_both(parts[1,2]) # This may contain "var1 var2 if condition"
  options_str = stringi::stri_trim_both(parts[1,3]) # NA if no options

  # Separate varlist from if condition
  stata_if_cond_expr = NA_character_
  varlist_str = varlist_and_cond_str
  if_cond_match = stringi::stri_match_first_regex(varlist_and_cond_str, "\\s+if\\s+(.*)$")
  if(!is.na(if_cond_match[1,1])) {
      stata_if_cond_expr = if_cond_match[1,2]
      varlist_str = stringi::stri_replace_all_fixed(varlist_and_cond_str, if_cond_match[1,1], "")
      varlist_str = stringi::stri_trim_both(varlist_str)
  }

  vars_to_summarize = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_summarize = vars_to_summarize[vars_to_summarize != ""]

  # For r() values, Stata's summarize without a varlist summarizes all variables,
  # but r() values like r(mean) refer to the mean of the *last* variable in the dataset.
  # If a varlist is specified, r() values refer to the *last* variable in the varlist.
  # This makes it hard to perfectly emulate without knowing data column order.
  # For now, if varlist is empty, we only set r(N). If not empty, we use the last variable.
  var_for_r_vals = NA_character_
  if (length(vars_to_summarize) > 0) {
      var_for_r_vals = vars_to_summarize[length(vars_to_summarize)] # Last variable in varlist
  } else {
      # If no varlist, r(N) is total observations. Other r() values are for the last variable.
      # We cannot reliably determine the "last variable" in R without knowing the dataframe's current state and order.
      # For now, if no varlist, we only define r(N).
  }


  is_meanonly = dplyr::coalesce(stringi::stri_detect_fixed(options_str, "meanonly"), FALSE)
  is_detail = dplyr::coalesce(stringi::stri_detect_fixed(options_str, "detail"), FALSE)

  r_code_lines = c()
  line_prefix = paste0("stata_r_val_L", cmd_obj$line, "_") # Use cmd_obj$line

  # Prepare data subset if "if condition" is present
  data_source_for_summary = "data"
  if (!is.na(stata_if_cond_expr)) {
    r_subset_cond = translate_stata_expression_with_r_values(stata_if_cond_expr, cmd_obj$line, cmd_df, context = list(is_by_group = FALSE))
    data_subset_varname = paste0("data_subset_L", cmd_obj$line)
    r_code_lines = c(r_code_lines, paste0(data_subset_varname, " = collapse::fsubset(data, (dplyr::coalesce(as.numeric(", r_subset_cond, "), 0) != 0))")) # Used fsubset
    data_source_for_summary = data_subset_varname
  }

  # Always set r(N) as it's for the number of observations processed.
  r_code_lines = c(r_code_lines, paste0(line_prefix, "N = collapse::fN(", data_source_for_summary, ")")) # Used fN

  if (!is.na(var_for_r_vals)) {
      # Use collapse functions for summaries
      if (is_meanonly) {
        r_code_lines = c(
          r_code_lines,
          paste0(line_prefix, "mean = collapse::fmean(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)")
        )
      } else { # Default summarize or with other options (detail implies more)
        r_code_lines = c(
          r_code_lines,
          paste0(line_prefix, "mean = collapse::fmean(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"),
          paste0(line_prefix, "sd = collapse::fsd(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"),
          paste0(line_prefix, "min = collapse::fmin(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"),
          paste0(line_prefix, "max = collapse::fmax(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)"),
          paste0(line_prefix, "sum = collapse::fsum(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)")
        )
        if (is_detail) {
          r_code_lines = c(
            r_code_lines,
            paste0(line_prefix, "p50 = collapse::fmedian(", data_source_for_summary, "[['", var_for_r_vals, "']], na.rm = TRUE)")
            # Further percentiles (p1, p5, etc.), variance, skewness, kurtosis for detail are not yet implemented.
          )
        }
      }
  } else {
      r_code_lines = c(r_code_lines, paste0("# No variable specified for summarize: r(mean), r(sd), etc. not set."))
  }


  if (data_source_for_summary != "data") {
      # Clean up temporary subsetted dataframe
      r_code_lines = c(r_code_lines, paste0("rm(", data_subset_varname, ")"))
  }

  return(paste(r_code_lines, collapse="\n"))
}
```
!END_CHANGE_FILE R/t_summarize.R

!CHANGE_FILE R/t_regress.R
```R
# Translate Stata 'regress' command
# Stata: regress depvar [indepvars] [if] [in] [weight] [, options]
# Primarily for extracting e(sample) if needed by subsequent commands.

t_regress = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_regress")

  # Check if any e() results are actually needed by a subsequent command
  needed_e_results = unlist(cmd_obj$e_results_needed)

  if (length(needed_e_results) == 0) {
    # If no e() results are needed, this regress command doesn't need to produce any R output.
    return(paste0("# regress command at line ", line_num, " translated to no-op as no e() results used later."))
  }

  # Parse `rest_of_cmd` for depvar, indepvars, and if/in conditions
  # Example: "y_outcome x_numeric if some_condition > 10"
  # Regex to capture: (depvar indepvars_optional) (if_clause_optional) (in_clause_optional) (options_like_robust_optional)

  # Remove options like robust, vce(), level() as they don't affect e(sample)
  rest_of_cmd_no_opts = stringi::stri_replace_all_regex(rest_of_cmd, ",\\s*\\w+\\(?[^)]*\\)?", "")
  rest_of_cmd_no_opts = stringi::stri_replace_all_regex(rest_of_cmd_no_opts, ",\\s*robust\\b", "")
  rest_of_cmd_no_opts = stringi::stri_trim_both(rest_of_cmd_no_opts)

  stata_if_cond = NA_character_
  stata_in_range = NA_character_ # Not directly used for e(sample) calculation, but parsed for completeness
  var_part = rest_of_cmd_no_opts

  # Extract `if` condition
  if_match = stringi::stri_match_last_regex(var_part, "\\s+if\\s+(.*)$")
  if (!is.na(if_match[1,1])) {
    stata_if_cond = stringi::stri_trim_both(if_match[1,2])
    var_part = stringi::stri_trim_both(stringi::stri_sub(var_part, 1, if_match[1,1, MRANGE_START=TRUE] - 1))
  }

  vars_str_list = stringi::stri_split_regex(var_part, "\\s+")[[1]]
  vars_str_list = vars_str_list[vars_str_list != ""]

  if (length(vars_str_list) < 1) {
    return(paste0("# regress command at line ", line_num, " has no dependent variable."))
  }
  dep_var = vars_str_list[1]
  indep_vars = if (length(vars_str_list) > 1) vars_str_list[-1] else NULL

  # Construct formula string for R lm (for actual model fitting if needed)
  formula_r_vars = paste0("`", dep_var, "`")
  if (!is.null(indep_vars) && length(indep_vars) > 0) {
    formula_r_vars = paste0(formula_r_vars, " ~ ", paste0("`", indep_vars, "`", collapse = " + "))
  } else {
    formula_r_vars = paste0(formula_r_vars, " ~ 1") # Regress on constant
  }

  all_vars_in_formula = c(dep_var, indep_vars) # All variables involved in the model

  r_code_lines = c()

  # Define the R variable name for e(sample)
  e_sample_r_var_name = paste0("stata_e_sample_L", line_num)
  line_prefix_e_base = paste0("stata_e_L", line_num, "_") # Base prefix for all e() values

  # --- Generate code to calculate e(sample) ---
  # 1. Determine rows satisfying the `if` condition (if any)
  eligible_rows_if_cond_var = paste0("temp_eligible_if_L", line_num)
  if (!is.na(stata_if_cond)) {
    # The 'if' condition for regress is evaluated row-wise on the whole dataset, not per group.
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
    r_code_lines = c(r_code_lines,
      paste0(eligible_rows_if_cond_var, " = (dplyr::coalesce(as.numeric(with(data, ", r_if_cond, ")), 0) != 0)")
    )
  } else {
    r_code_lines = c(r_code_lines,
      paste0(eligible_rows_if_cond_var, " = rep(TRUE, NROW(data))")
    )
  }

  # 2. Determine rows with complete cases for model variables
  complete_cases_vars_var = paste0("temp_complete_cases_L", line_num)
  vars_for_cc_r_vec = paste0("c('", paste(all_vars_in_formula, collapse="','"), "')")
  r_code_lines = c(r_code_lines,
    paste0(complete_cases_vars_var, " = stats::complete.cases(data[, ", vars_for_cc_r_vec, ", drop=FALSE])")
  )

  # 3. Combine `if` eligibility and complete cases to define e(sample)
  # Stata's `regress` command by default performs listwise deletion. `e(sample)` should reflect this.
  r_code_lines = c(r_code_lines,
    paste0(e_sample_r_var_name, " = as.integer(", eligible_rows_if_cond_var, " & ", complete_cases_vars_var, ")")
  )

  # 4. Clean up temporary logical vectors
  r_code_lines = c(r_code_lines, paste0("rm(", eligible_rows_if_cond_var, ", ", complete_cases_vars_var, ")"))

  # Calculate other e() results if they are needed
  if ("e(N)" %in% needed_e_results) {
      r_code_lines = c(r_code_lines, paste0(line_prefix_e_base, "N = sum(", e_sample_r_var_name, ")"))
  }

  # If other model-derived e() results are needed, run the actual linear model.
  # This avoids running lm if only e(sample) or e(N) are needed.
  other_model_results_needed = setdiff(needed_e_results, c("e(sample)", "e(N)"))
  if (length(other_model_results_needed) > 0) {
    # Filter data to estimation sample before running lm
    lm_data_var = paste0("data_lm_L", line_num)
    r_code_lines = c(r_code_lines,
      paste0(lm_data_var, " = collapse::fsubset(data, ", e_sample_r_var_name, " == 1)"), # Changed dplyr::filter to collapse::fsubset
      paste0("lm_res_L", line_num, " = stats::lm(", formula_r_vars, ", data = ", lm_data_var, ")")
    )
    
    if ("e(r2)" %in% needed_e_results) {
        r_code_lines = c(r_code_lines, paste0(line_prefix_e_base, "r2 = summary(lm_res_L", line_num, ")$r.squared"))
    }
    if ("e(df_r)" %in% needed_e_results) {
        r_code_lines = c(r_code_lines, paste0(line_prefix_e_base, "df_r = lm_res_L", line_num, "$df.residual"))
    }
    if ("e(rmse)" %in% needed_e_results) {
        r_code_lines = c(r_code_lines, paste0(line_prefix_e_base, "rmse = summary(lm_res_L", line_num, ")$sigma"))
    }
    # Clean up lm related temporary variables
    r_code_lines = c(r_code_lines, paste0("rm(", lm_data_var, ", lm_res_L", line_num, ")"))
  }

  # Add a comment about the formula
  r_code_lines = c(r_code_lines, paste0("# Regression model for e() results: ", formula_r_vars))
  if (!is.na(stata_if_cond)) {
    r_code_lines = c(r_code_lines, paste0("# Applied if condition: ", stata_if_cond))
  }

  return(paste(r_code_lines, collapse = "\n"))
}
```
!END_CHANGE_FILE R/t_regress.R
