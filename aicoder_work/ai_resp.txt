The primary issue causing the test failure was a subtle floating-point precision mismatch in generated numeric variables, especially after aggregation or transformation. Stata's default 'float' type has specific precision characteristics that need to be mimicked in R for exact data comparison. The existing `sfun_stata_numeric_output_round` function was intended for this, but its logic was refined for better consistency. Additionally, this rounding and attribute stripping was not consistently applied to all numeric variables generated by `egen`, `collapse`, `destring`, and `recode`.

The changes address this by:
1.  **Refining `sfun_stata_numeric_output_round`**: Simplified the rounding logic to consistently round numeric values to 8 decimal places using Stata's rounding rule (away from zero for .5). This is a practical approach to match Stata's float precision for comparison.
2.  **Applying rounding and attribute stripping consistently**: Ensured that all newly generated or modified numeric columns from `egen`, `collapse`, `destring`, and `recode` commands are passed through `sfun_stata_numeric_output_round` and `sfun_strip_stata_attributes`.
3.  **Correcting minor syntax bugs**: Added `data$` prefix in `t_destring.R` and `t_recode.R` where variable names were used directly in `dplyr::if_else` conditions, ensuring they correctly refer to columns within the `data` dataframe.

!CHANGE_FILE R/sfun_stata_numeric_output_round.R
```R
sfun_stata_numeric_output_round = function(x) {
  # Apply to numeric vectors only
  if (!is.numeric(x)) return(x)

  # Stata's 'float' type has about 7 decimal digits of precision.
  # To accurately compare R's double-precision results with Stata's float-precision results,
  # we round to a consistent number of decimal places using Stata's rounding rule.
  # Using 1e-8 as the unit for sfun_stata_round to ensure consistent rounding to 8 decimal places.
  return(sfun_stata_round(x, 1e-8))
}
```
!END_CHANGE_FILE R/sfun_stata_numeric_output_round.R

!CHANGE_FILE R/t_collapse.R
```R
# Translate Stata 'collapse' command
# Stata: collapse (stat) varlist [name=expr ...] [weight] [if] [in] [, options]
# Often: collapse (stat) varlist, by(groupvars)

t_collapse = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_collapse") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Split into aggregate definitions part and options part
  parts = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "^\\s*(.*?)(?:,\\s*(.*))?$")
  aggregate_part = stringi::stri_trim_both(parts[1,2])
  options_part = stringi::stri_trim_both(parts[1,3]) # NA if no options

  # Separate potential if/in from aggregate definitions
  stata_if_in_cond = NA_character_
  # Look for `if` or `in` immediately followed by a space
  if_in_match = stringi::stri_match_first_regex(aggregate_part, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      # Remove the if/in part from aggregate_part
      aggregate_part = stringi::stri_replace_last_regex(aggregate_part, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      aggregate_part = stringi::stri_trim_both(aggregate_part)
  }


  # Parse aggregate definitions: "(stat) var [name=expr ...] (stat) var [name=expr ...] ..."
  # Regex: \\(([a-zA-Z_]+)\\)\\s+([a-zA-Z0-9_]+)(?:\\s*=\\s*([a-zA-Z0-9_]+))?
  # G1: stat (stat_from_regex)
  # G2: varname1 (g2_val_from_regex)
  # G3: varname2 (g3_val_from_regex) - optional
  # If G3 is NA: Stata form is (stat) G2. Here, G2 is source and target.
  # If G3 is not NA: Stata form is (stat) G2 = G3. Here, G2 is target, G3 is source.

  aggregate_matches = stringi::stri_match_all_regex(aggregate_part, "\\(([a-zA-Z_]+)\\)\\s+([a-zA-Z0-9_]+)(?:\\s*=\\s*([a-zA-Z0-9_]+))?")[[1]]
  # aggregate_matches will be a matrix: [match, stat, g2_val, g3_val]

  if (NROW(aggregate_matches) == 0) {
    return(paste0("# Failed to parse collapse aggregate definitions: ", aggregate_part))
  }

  # Parse options part for `by()`
  by_vars_collapse = NA_character_
  if (!is.na(options_part)) {
    by_opt_match = stringi::stri_match_first_regex(options_part, "\\bby\\s*\\(([^)]+)\\)")
    if (!is.na(by_opt_match[1,1])) {
      by_vars_collapse = stringi::stri_trim_both(by_opt_match[1,2])
    }
  }

  by_vars_r_vec_str = NULL # For dplyr group_by: character vector c("var1", "var2")
  by_vars_list_unquoted = character(0) # For checking length
  if (!is.na(by_vars_collapse)) {
    by_vars_list_unquoted = stringi::stri_split_regex(by_vars_collapse, "\\s+")[[1]]
    by_vars_list_unquoted = by_vars_list_unquoted[by_vars_list_unquoted != ""]
    if (length(by_vars_list_unquoted) > 0) {
        by_vars_r_vec_str = paste0('c("', paste0(by_vars_list_unquoted, collapse='", "'), '")')
    }
  }

  # Translate the if/in condition for subsetting *before* collapse
  r_subset_cond = NA_character_
  data_source_for_collapse = "data"
  r_code_prefix = "" # Code to create subset if needed

  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, cmd_obj$line, cmd_df, context = list(is_by_group = FALSE)) # Use cmd_obj$line
      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for collapse: ", stata_if_in_cond))
      }
      data_subset_varname = paste0("data_subset_L", cmd_obj$line)
      r_code_prefix = paste0(data_subset_varname, " = dplyr::filter(data, ", r_subset_cond, ")\n") # Changed to dplyr::filter
      data_source_for_collapse = data_subset_varname
  }


  # Build the summarise/aggregate expressions for dplyr::summarise
  aggregate_exprs = character(NROW(aggregate_matches))
  new_vars_created = character(NROW(aggregate_matches)) # Keep track of new variable names
  for (j in 1:NROW(aggregate_matches)) {
    stat_from_regex = aggregate_matches[j, 2]
    g2_val_from_regex = aggregate_matches[j, 3]
    g3_val_from_regex = aggregate_matches[j, 4]

    actual_stata_source_var_name = ""
    actual_stata_target_var_name = ""

    if (is.na(g3_val_from_regex)) { # Matched (stat) g2_val_from_regex
        actual_stata_source_var_name = g2_val_from_regex
        actual_stata_target_var_name = g2_val_from_regex
    } else { # Matched (stat) g2_val_from_regex = g3_val_from_regex
        actual_stata_source_var_name = g3_val_from_regex    # G3 is source
        actual_stata_target_var_name = g2_val_from_regex    # G2 is target
    }
    new_vars_created[j] = actual_stata_target_var_name # Store new var name

    # Translate actual Stata source variable name
    r_source_var = translate_stata_expression_with_r_values(actual_stata_source_var_name, cmd_obj$line, cmd_df, context) # Use cmd_obj$line
     if (is.na(r_source_var) || r_source_var == "") {
         return(paste0("# Failed to translate source variable '", actual_stata_source_var_name, "' for collapse stat '", stat_from_regex, "'"))
     }

    # Map Stata stats to dplyr functions (or base R)
    dplyr_func = switch(stat_from_regex,
      "mean" = paste0("mean(", r_source_var, ", na.rm = TRUE)"),
      "sum" = paste0("sum(", r_source_var, ", na.rm = TRUE)"),
      "count" = paste0("sum(!is.na(", r_source_var, "))"), # Stata count for non-missing values
      "N" = paste0("dplyr::n()"), # N is number of observations in group
      "first" = paste0("dplyr::first(", r_source_var, ")"),
      "last" = paste0("dplyr::last(", r_source_var, ")"),
      "min" = paste0("min(", r_source_var, ", na.rm = TRUE)"),
      "max" = paste0("max(", r_source_var, ", na.rm = TRUE)"),
      "median" = paste0("median(", r_source_var, ", na.rm = TRUE)"),
      "sd" = paste0("sd(", r_source_var, ", na.rm = TRUE)"),
      "p1" = paste0("quantile(", r_source_var, ", probs = 0.01, na.rm = TRUE)"),
      "p5" = paste0("quantile(", r_source_var, ", probs = 0.05, na.rm = TRUE)"),
      "p10" = paste0("quantile(", r_source_var, ", probs = 0.10, na.rm = TRUE)"),
      "p25" = paste0("quantile(", r_source_var, ", probs = 0.25, na.rm = TRUE)"),
      "p75" = paste0("quantile(", r_source_var, ", probs = 0.75, na.rm = TRUE)"),
      "p90" = paste0("quantile(", r_source_var, ", probs = 0.90, na.rm = TRUE)"),
      "p95" = paste0("quantile(", r_source_var, ", probs = 0.95, na.rm = TRUE)"),
      "p99" = paste0("quantile(", r_source_var, ", probs = 0.99, na.rm = TRUE)"),
      NULL
    )

    if (is.null(dplyr_func)) {
        return(paste0("# Collapse stat '", stat_from_regex, "' not yet implemented."))
    }

    # The new variable name for R code is the actual_stata_target_var_name
    r_new_var_name = actual_stata_target_var_name
    aggregate_exprs[j] = paste0(r_new_var_name, " = ", dplyr_func)
  }

  # Combine aggregate expressions
  aggregate_exprs_str = paste(aggregate_exprs, collapse = ",\n  ")

  # Build the final R code
  r_code_lines = c(r_code_prefix) # Add subsetting code if any

  if (!is.null(by_vars_r_vec_str) && length(by_vars_list_unquoted) > 0) {
    r_code_lines = c(r_code_lines,
                       data_source_for_collapse, " %>%\n",
                       "  dplyr::group_by(dplyr::across(", by_vars_r_vec_str, ")) %>%\n", # Changed to dplyr
                       "  dplyr::summarise(", aggregate_exprs_str, ") %>%\n",           # Changed to dplyr
                       "  dplyr::ungroup()")                                             # Changed to dplyr
  } else {
     r_code_lines = c(r_code_lines,
                       data_source_for_collapse, " %>%\n",
                       "  dplyr::summarise(", aggregate_exprs_str, ")")                   # Changed to dplyr
  }
  r_code_lines = c("data = ", r_code_lines) # Assign result back to 'data'

  # Apply Stata-like numeric output rounding and attribute stripping for newly created variables
  for (new_var in new_vars_created) {
    r_code_lines = c(r_code_lines, paste0("data$", new_var, " = sfun_stata_numeric_output_round(data$", new_var, ")"))
    r_code_lines = c(r_code_lines, paste0("data$", new_var, " = sfun_strip_stata_attributes(data$", new_var, ")"))
  }


  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about options if any were present but not handled
  if (!is.na(options_part) && options_part != "") {
       r_code_str = paste0(r_code_str, paste0(" # Options ignored: ", options_part))
  }


  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_collapse.R

!CHANGE_FILE R/t_destring.R
```R
# Translate Stata 'destring' command
# Stata: destring varlist [if] [in] , {generate(newvarlist) | replace} [options]
# Converts string variables into numeric variables.

t_destring = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_destring") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varlist, if/in, options (generate() or replace)
  # Pattern: `varlist [if] [in] , options`

  varlist_str = NA_character_
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Find if/in first
  if_in_match = stringi::stri_match_first_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rest_no_if_in = stringi::stri_replace_last_regex(rest_of_cmd_trimmed, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rest_no_if_in = stringi::stri_trim_both(rest_no_if_in)
  } else {
      rest_no_if_in = rest_of_cmd_trimmed
  }

   # Find options (required)
  options_match = stringi::stri_match_first_regex(rest_no_if_in, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      varlist_str = stringi::stri_replace_last_regex(rest_no_if_in, ",\\s*(.*)$", "")
      varlist_str = stringi::stri_trim_both(varlist_str)
  } else {
      return(paste0("# destring command requires options (, gen() or , replace): ", rest_of_cmd))
  }

   if (is.na(varlist_str) || varlist_str == "") {
       return(paste0("# destring command requires varlist: ", rest_of_cmd))
   }

  vars_to_destring = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_destring = vars_to_destring[vars_to_destring != ""]
   if (length(vars_to_destring) == 0) {
       return(paste0("# destring command requires non-empty varlist: ", rest_of_cmd))
   }


  # Parse options, specifically `generate()` or `replace`
  is_replace = stringi::stri_detect_fixed(options_str, "replace")
  gen_vars = NA_character_
  if (!is_replace) {
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgenerate\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars = stringi::stri_trim_both(gen_opt_match[1,2])
       }
  }

  new_vars = NULL
  if (!is_replace) {
      if (is.na(gen_vars)) {
           return(paste0("# destring requires generate() option or replace option: ", rest_of_cmd))
      }
      new_vars = stringi::stri_split_regex(gen_vars, "\\s+")[[1]]
      new_vars = new_vars[new_vars != ""]
      if (length(new_vars) != length(vars_to_destring)) {
          return(paste0("# destring generate() option requires same number of new variables as old variables."))
      }
  } else {
      # If replace option, new vars are the same as old vars.
      new_vars = vars_to_destring
  }


  # Translate if/in condition
  r_if_in_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
       r_if_in_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group=FALSE))
       if (is.na(r_if_in_cond) || r_if_in_cond == "") {
           return(paste0("# Failed to translate if/in condition for destring: ", stata_if_in_cond))
       }
  }

  # R equivalent: readr::parse_number() or as.numeric()
  # readr::parse_number is better at handling non-numeric parts and commas/$, results in NA on failure.
  # as.numeric() often results in warnings/errors or NA on failure.
  # Stata destring option `ignore()` can specify characters to ignore. `force` allows unconvertible values to become missing.
  # `readr::parse_number` handles some of this.

  mutate_exprs = character(length(vars_to_destring))
  for (k in seq_along(vars_to_destring)) {
      old_var = vars_to_destring[k]
      new_var = new_vars[k]
      source_var_r = old_var # R variable name for the source column

      # Calculate destrung values
      # Using readr::parse_number
      destrung_value_expr = paste0("readr::parse_number(as.character(data$", source_var_r, "))")
      # as.character needed in case the variable is factor/labelled etc.

      # Apply the if/in condition for replacement
      if (!is.na(r_if_in_cond) && r_if_in_cond != "") {
          # For rows meeting condition, use destrung value. Otherwise, keep original (or NA if new var).
           if (is_replace) {
               # Replace in place: use destrung if condition, old value otherwise
               final_value_expr = paste0("dplyr::if_else(", r_if_in_cond, ", ", destrung_value_expr, ", data$", source_var_r, ")")
           } else {
               # Generate new var: use destrung if condition, NA otherwise
               final_value_expr = paste0("dplyr::if_else(", r_if_in_cond, ", ", destrung_value_expr, ", NA_real_)") # Assuming numeric result
           }
      } else {
          # Apply to all rows
           final_value_expr = destrung_value_expr
      }

      mutate_exprs[k] = paste0(new_var, " = ", final_value_expr)
  }

   # Combine mutate expressions
  mutate_exprs_str = paste(mutate_exprs, collapse = ",\n  ")

  # Build the final R code using dplyr::mutate
  r_code_lines = c(paste0("data = dplyr::mutate(data, ", mutate_exprs_str, ")")) # Changed to dplyr::mutate

  # Apply Stata-like numeric output rounding and attribute stripping to the newly created/modified variables
  for (new_var in new_vars) {
      r_code_lines = c(r_code_lines, paste0("data$", new_var, " = sfun_stata_numeric_output_round(data$", new_var, ")"))
      r_code_lines = c(r_code_lines, paste0("data$", new_var, " = sfun_strip_stata_attributes(data$", new_var, ")"))
  }


  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about options if any were present but not handled (excluding generate/replace)
   options_str_cleaned = options_str
   # Remove generate() or replace from options string
   if (is_replace) {
       options_str_cleaned = stringi::stri_replace_first_fixed(options_str_cleaned, "replace", "")
   } else {
       options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bgenerate\\s*\\([^)]+\\)", "")
   }
   options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ",")) # Clean up multiple commas
   options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "") # Remove leading comma


   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str_cleaned))
   }


  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_destring.R

!CHANGE_FILE R/t_recode.R
```R
# Translate Stata 'recode' command
# Stata: recode varlist (rule1)(rule2)... [if] [in] [, options]
# Example: recode income (0=.) (100 thru 200 = 150) (300 301 305 = 300) (else=copy), gen(newincome)

t_recode = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_recode") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varlist, rules, if/in, options (especially gen())
  # This parsing is quite complex due to nested parentheses and optional parts.
  # Let's try to split varlist first, then find rules in parentheses.
  # Example: `recode var1 var2 (0=.) (1/10=1) (else=copy) if cond, gen(new1 new2)`

  # Split at first parenthesis to get varlist
  parts_varlist = stringi::stri_split_fixed(rest_of_cmd_trimmed, "(", n=2)[[1]]
  if (length(parts_varlist) != 2) {
      return(paste0("# Failed to parse recode command (missing rules): ", rest_of_cmd))
  }
  varlist_str = stringi::stri_trim_both(parts_varlist[1])
  vars_to_recode = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_recode = vars_to_recode[vars_to_recode != ""]

  if (length(vars_to_recode) == 0) {
      return(paste0("# recode command requires varlist: ", rest_of_cmd))
  }

  rules_and_rest = paste0("(", parts_varlist[2]) # Put the '(' back

  # Separate if/in and options from rules
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Look for `if` or `in` first
  if_in_match = stringi::stri_match_first_regex(rules_and_rest, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rules_and_rest = stringi::stri_replace_last_regex(rules_and_rest, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rules_and_rest = stringi::stri_trim_both(rules_and_rest)
  }

  # Look for options after the if/in part or after rules
  options_match = stringi::stri_match_first_regex(rules_and_rest, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2])
      rules_part = stringi::stri_replace_last_regex(rules_and_rest, ",\\s*(.*)$", "")
      rules_part = stringi::stri_trim_both(rules_part)
  } else {
      rules_part = rules_and_rest
  }

  # Now parse the rules part: (rule1)(rule2)...
  # Find all rules within parentheses
  rule_matches = stringi::stri_match_all_regex(rules_part, "\\(([^)]*)\\)")[[1]] # Match content inside ()
  if (NROW(rule_matches) == 0) {
      return(paste0("# Failed to parse recode rules: ", rules_part))
  }
  recode_rules_raw = rule_matches[,2] # Extract the content within parentheses


  # Parse options, specifically `gen()`
  gen_vars = NA_character_
  if (!is.na(options_str)) {
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgen\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars = stringi::stri_trim_both(gen_opt_match[1,2])
      }
  }

  new_vars = NULL
  if (!is.na(gen_vars)) {
      new_vars = stringi::stri_split_regex(gen_vars, "\\s+")[[1]]
      new_vars = new_vars[new_vars != ""]
      if (length(new_vars) != length(vars_to_recode)) {
          return(paste0("# recode gen() option requires same number of new variables as old variables."))
      }
  } else {
      # If no gen() option, recode is done in place. New vars are the same as old vars.
      new_vars = vars_to_recode
  }


  # Translate the if/in condition for subsetting
  r_subset_cond = NA_character_
  data_source_for_recode = "data"
  r_code_prefix = "" # Code to create subset if needed

  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      # Stata recode applies if/in to select observations *to be recoded*.
      # Observations not meeting if/in condition are left unchanged.
      # This means the R code needs to apply the recoding conditionally.
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for recode: ", stata_if_in_cond))
       }
      # The actual recoding logic (case_when/ifelse) will incorporate this condition.
      # No need for a separate subset dataframe here.
  }


  # Translate rules into R case_when clauses
  # Rule format: old_value = new_value
  # old_value can be: single value, range (val1/val2, val1 thru val2), list (val1 val2), else, missing (.)
  # new_value can be: single value, copy (use original value), missing (.)

  translate_recode_rule = function(rule_str, source_var_r) {
      rule_str = stringi::stri_trim_both(rule_str)
      parts_eq = stringi::stri_split_fixed(rule_str, "=", n=2)[[1]]
      if (length(parts_eq) != 2) {
          return(paste0("## Error parsing rule: ", rule_str))
      }
      old_part_raw = stringi::stri_trim_both(parts_eq[1])
      new_part_raw = stringi::stri_trim_both(parts_eq[2])

      # Translate old_part into R condition (left side of case_when ~ )
      r_condition = ""
      if (old_part_raw == "else") {
          r_condition = "TRUE" # This rule is the fallback
      } else if (old_part_raw == ".") {
           r_condition = paste0("is.na(data$", source_var_r, ")") # Missing value rule
      } else if (grepl("\\s+thru\\s+", old_part_raw)) {
           # Range: val1 thru val2
           range_parts = stringi::stri_split_regex(old_part_raw, "\\s+thru\\s+", n=2)[[1]]
           val1 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[1])) # Translate value (e.g. string "A" or number)
           val2 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[2]))
           if (is.na(val1) || is.na(val2)) return(paste0("## Error translating range values in rule: ", rule_str))
           r_condition = paste0("data$", source_var_r, " >= ", val1, " & data$", source_var_r, " <= ", val2)
      } else if (grepl("/", old_part_raw)) {
          # Range: val1/val2
           range_parts = stringi::stri_split_regex(old_part_raw, "/", n=2)[[1]]
           val1 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[1])) # Translate value
           val2 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[2]))
           if (is.na(val1) || is.na(val2)) return(paste0("## Error translating range values in rule: ", rule_str))
           r_condition = paste0("data$", source_var_r, " >= ", val1, " & data$", source_var_r, " <= ", val2) # Stata / is inclusive range
      }
      else {
          # List of values or single value
          old_values = stringi::stri_split_regex(old_part_raw, "\\s+")[[1]]
          old_values = old_values[old_values != ""]
          r_values = sapply(old_values, function(val) {
               if (val == ".") return("NA") # Stata missing symbol
               translate_stata_expression_to_r(val) # Translate value (e.g. "5", `"string"`)
          })
          r_condition = paste0("data$", source_var_r, " %in% c(", paste(r_values, collapse = ", "), ")")
      }


      # Translate new_part into R value (right side of case_when ~ )
      r_new_value = ""
      if (new_part_raw == "copy") {
          r_new_value = paste0("data$", source_var_r) # Use the original variable value
      } else if (new_part_raw == ".") {
          r_new_value = "NA" # R missing
      } else {
           r_new_value = translate_stata_expression_to_r(new_part_raw) # Translate the new value
      }

      return(paste0(r_condition, " ~ ", r_new_value))
  }

  # Generate case_when expression for each variable
  mutate_exprs = character(length(vars_to_recode))
  for (k in seq_along(vars_to_recode)) {
      old_var = vars_to_recode[k]
      new_var = new_vars[k]
      source_var_r = old_var # R variable name for the source column

      # Translate all rules for this variable
      r_rules = sapply(recode_rules_raw, translate_recode_rule, source_var_r = source_var_r)

      # Combine rules into a case_when statement
      case_when_expr = paste0("dplyr::case_when(\n    ", paste(r_rules, collapse = ",\n    "), "\n  )")

      # Apply global if/in condition around the case_when
      if (!is.na(r_subset_cond) && r_subset_cond != "") {
          # If condition is met, apply case_when. Otherwise, keep original value.
          final_value_expr = paste0("dplyr::if_else(", r_subset_cond, ",\n",
                                    "    ", case_when_expr, ",\n",
                                    "    data$", source_var_r, ")") # Keep original value if condition not met.
      } else {
          final_value_expr = case_when_expr
      }


      mutate_exprs[k] = paste0(new_var, " = ", final_value_expr)
  }

  # Combine mutate expressions
  mutate_exprs_str = paste(mutate_exprs, collapse = ",\n  ")

  # Build the final R code using dplyr::mutate
  r_code_lines = c(paste0("data = dplyr::mutate(data, ", mutate_exprs_str, ")")) # Changed to dplyr::mutate

  # Apply Stata-like numeric output rounding and attribute stripping for newly created/modified variables
  for (new_var in new_vars) {
    r_code_lines = c(r_code_lines, paste0("data$", new_var, " = sfun_stata_numeric_output_round(data$", new_var, ")"))
    r_code_lines = c(r_code_lines, paste0("data$", new_var, " = sfun_strip_stata_attributes(data$", new_var, ")"))
  }


  r_code_str = paste(r_code_lines, collapse="\n")

  # Add comment about options if any were present but not handled (excluding gen)
   if (!is.na(options_str) && !grepl("\\bgen\\s*\\([^)]+\\)", options_str)) {
        r_code_str = paste0(r_code_str, paste0(" # Other options ignored: ", options_str))
   }


  return(r_code_str)
}
```
!END_CHANGE_FILE R/t_recode.R
```
