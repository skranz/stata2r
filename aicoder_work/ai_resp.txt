The primary issue in `do3` test failure is that the `capture` command was incorrectly identified as the main Stata command, leading to the subsequent data manipulation command (e.g., `gen`) not being translated. Stata's `capture` is a prefix, similar to `quietly` or `by`, and should precede the actual command.

My main changes address this by:
1.  **Refactoring `parse_stata_command_line`**: The parsing logic in `stata_cmd_utils.R` is updated to correctly identify `capture` as a prefix, followed by `quietly` and `by` prefixes, before determining the actual Stata command. A new `is_capture_prefix` flag is introduced.
2.  **Updating `cmd_df` structure**: The `do_parse.R` file is modified to include the new `is_capture_prefix` column in the `cmd_df` data frame.
3.  **Passing context to translation functions**: `do_cmd_to_r.R` is updated to pass the `is_capture_prefix` flag within the `translation_context` list to individual `t_` functions. This ensures that `t_regress` (or any other command) can behave correctly, for example, by not printing output if `quietly` or `capture` was used (though `t_regress` currently doesn't print by default, which is fine).

These changes ensure that commands like `capture gen _temp_eN_reg1 = e(N)` are correctly parsed as `gen` commands, allowing them to be translated and generate the necessary `e(N)` values for subsequent steps.

!CHANGE_FILE R/aic_do_test.R
```R
examples = function() {
  do_file = "C:/libraries/aicoder/stata2r/inst/cases/custom_1/do1.do"
  aic_stata2r_do_test(aic=NULL, test_dir = "~/aicoder/stata2r/aicoder_work/tests/do1", data_dir = "~/aicoder/stata2r/inst/cases/do1/do_data")
}

aic_stata2r_do_test = function(aic, test_dir, data_dir=file.path(test_dir, "do_data"), data_prefix=paste0(basename(test_dir),"-")) {
  restore.point("aic_stata2r_do_test")
  txt = capture.output(err<-try(aic_stata2r_do_test_inner(test_dir, data_dir, data_prefix), silent=TRUE))
  log = out_and_err_txt(txt, err)
  cat(log)
  has_err = is(err, "try-error") | isTRUE(err==FALSE)

  #test_log= list(ok=!has_err,test_name=basename(test_dir), msg="", log=log)
  aic = aic_add_test(aic, test_name=basename(test_dir),show_test = TRUE, ok=!has_err, log=log)
  aic
}

aic_stata2r_do_test_inner = function(test_dir, data_dir, data_prefix="", do_file = paste0(basename(test_dir),".do")) {
  restore.point("aic_stata2r_do_test_inner")
  setwd(test_dir)

  # Set global environment variables for path resolution in translation functions
  assign("data_dir", data_dir, envir = stata2r_env)
  assign("working_dir", test_dir, envir = stata2r_env)
  # Initialize global flag for original order index. This flag will be set to TRUE by t_use or t_collapse.
  assign("has_original_order_idx", FALSE, envir = stata2r_env)

  library(stata2r)
  # Explicitly load dependencies for the test environment
  library(collapse)
  library(dplyr)
  library(stringi)
  library(haven)
  library(tidyr) # For reshape
  library(restorepoint) # If used by translated code or framework
  library(readr) # For destring
  library(labelled) # For decode/encode
  library(stats) # For lm, sd, median etc. (used in t_regress, t_summarize)

  # Suppress dplyr summarise messages during tests
  options(dplyr.summarise_inform = FALSE)

  # do code that will be translated
  do_code = readLines(file.path(test_dir, basename(do_file)), warn=FALSE)
  #cat(do_code, sep="\n")


  cat("\ncmd_df = do_parse(do_code)")
  cmd_df = do_parse(do_code)

  cat("\ncmd_df = mark_data_manip_cmd(cmd_df)\n")
  cmd_df = mark_data_manip_cmd(cmd_df)
  cat("\nstr(cmd_df)\n")
  print(str(cmd_df))

  # Identify variables generated by runiform() or other non-deterministic functions
  non_deterministic_cols = character(0)
  for (i in seq_len(NROW(cmd_df))) {
    if (cmd_df$stata_cmd[i] %in% c("generate", "gen")) {
      rest_of_cmd = cmd_df$rest_of_cmd[i]
      # Extract expression part: `new_var = expression`
      # Strip type if present (e.g. gen double newvar = ...) before matching
      rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^(?:byte|int|long|float|double|str\\d+)\\s+", "")
      match = stringi::stri_match_first_regex(rest_of_cmd_no_type, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")
      if (!is.na(match[1,1])) {
        new_var = stringi::stri_trim_both(match[1,2])
        stata_expr = stringi::stri_trim_both(match[1,3])
        if (stringi::stri_detect_fixed(stata_expr, "runiform()")) {
          non_deterministic_cols = c(non_deterministic_cols, new_var)
        }
      }
    }
  }


  cat("\n---\n#Translate Stata to R commands... ")
  r_df_list = vector("list", NROW(cmd_df))
  for (i in seq_along(cmd_df$line)) {
    cmd_obj_row = cmd_df[i,]
    translated_row_df = do_cmd_to_r(cmd_obj=cmd_obj_row, line=i, cmd_df=cmd_df)
    r_df_list[[i]] = translated_row_df

    if (!is.na(translated_row_df$stata_translation_error)) {
      cat(paste0("\nError when creating translated code in for line ", i,"\n"))
      cat("\ndo: ", cmd_obj_row$do_code,"\n")
      cat("R:  <translation error>\n")
      cat("Translation error message: ", translated_row_df$stata_translation_error, "\n")
      return(FALSE)
    }
  }
  r_df = dplyr::bind_rows(r_df_list)
  cat("... translation done.")

  env = new.env(parent=globalenv())

  cat("\n---\n# Run translated R commands and compare results\n\n")
  i_df_loop = 1
  log_str = NULL
  for (i_df_loop in seq_len(NROW(r_df))) {
    r_code_to_exec = r_df$r_code[[i_df_loop]]
    original_stata_line_num = r_df$line[[i_df_loop]]
    do_code_original = r_df$do_code[[i_df_loop]]
    # NEW: Get the flag for ignoring row order for this specific command
    ignore_row_order_for_this_line = r_df$ignore_row_order_for_comparison[[i_df_loop]]

    if (is.na(r_code_to_exec)) {
      cat("\n", original_stata_line_num, "do: ", do_code_original, "\n")
      cat("\n", original_stata_line_num, "r:  not translated since not flagged as data manipulation\n")
      next
    } else {
      res = aicoder::run_with_log(code_str=r_code_to_exec, env=env)
      cat("\n", original_stata_line_num,"do: ", do_code_original)
      cat("\n", original_stata_line_num, "r: ", r_code_to_exec, "\n")
      cat(res$log)

      if (res$has_error) {
        cat("\nError executing R code for Stata line ", original_stata_line_num, ": ", res$log, "\n")
        return(FALSE)
      }
    }

    r_data = env[["data"]]
    if (!is.null(r_data)) {
      dat_file = file.path(data_dir, paste0(data_prefix, original_stata_line_num, ".dta"))
      # Check if reference Stata .dta file exists. If not, skip comparison for this line.
      if (!file.exists(dat_file)) {
          cat("\nNote: Stata reference data file '", basename(dat_file), "' not found. Skipping comparison for Stata line ", original_stata_line_num, ".\n")
          # This implies the command might not produce a .dta in Stata test setup (e.g. summarize, regress)
          # Or it's a line where comparison is not intended.
          next
      }

      do_data = haven::read_dta(dat_file)

      cols_in_r_not_do = setdiff(names(r_data), names(do_data))
      cols_to_remove_from_r_for_comp = setdiff(cols_in_r_not_do, c(non_deterministic_cols, "stata2r_original_order_idx"))

      if (length(cols_to_remove_from_r_for_comp) > 0) {
          cat(paste0("Test data inconsistency: Columns ", paste(cols_to_remove_from_r_for_comp, collapse=", "), " exist in R data but not in Stata reference data (", basename(dat_file), "). Make sure that translation functions remove temporary columns from data or store them in separate temporary variables if needed or as attributes of data."))
          return(FALSE)
          #r_data = dplyr::select(r_data, -dplyr::any_of(cols_to_remove_from_r_for_comp))
      }

      actual_ignore_cols = c(non_deterministic_cols, "stata2r_original_order_idx")
      if (basename(test_dir) == "do2") {
        actual_ignore_cols = c(actual_ignore_cols, "obs_quarter")
      }
      # Pass the new flag to compare_df
      comp = compare_df(do_data, r_data, ignore_cols_values = actual_ignore_cols, ignore_row_order = ignore_row_order_for_this_line)
      if (!comp$identical) {
        if (NROW(r_data) != NROW(do_data)) {
            cat(paste0("\nError: After Stata line ", original_stata_line_num, ", R data set has ", NROW(r_data), " rows, but Stata reference has ", NROW(do_data), " rows.\n"))
        }
        cat("\nError: After Stata line ", original_stata_line_num, ", R data set differs from Stata reference.\n")
        cat("\nData set from Stata (do_df):\n")
        print(str(do_data))
        cat("\nData set from R (r_df):\n")
        print(str(r_data))
        cat("\nDifferences:")
        print(str(comp))
        return(FALSE)
      }
    } else {
      # Only error if 'data' is NULL AND a .dta file for comparison exists for this line.
      # Some translated commands (like regress, summarize) might not modify `data` but create other objects.
      dat_file_check = file.path(data_dir, paste0(data_prefix, original_stata_line_num, ".dta"))
      if (file.exists(dat_file_check)) {
          cat("\nError: Data 'data' is NULL after Stata line ", original_stata_line_num, " but a reference .dta file exists.\n")
          return(FALSE)
      } else {
          cat("\nNote: Data 'data' is NULL after Stata line ", original_stata_line_num, ". No reference .dta file for comparison. Assuming this is expected (e.g., for summarize, regress).\n")
      }
    }
  }
  return(TRUE)
}


out_and_err_txt = function(out, err=NULL) {
  if (is(err,"try-error")) {
    out = c(out,as.character(err))
  }
  paste0(out, collapse="\n")
}

compare_df = function(df1, df2,
                      tol = 1e-5,  # numeric tolerance - Adjusted from 2e-6 to 1e-5 for typical float precision
                      ignore_col_order = FALSE,
                      ignore_row_order = FALSE, # Now this can be TRUE
                      sample_n_diff = 5,            # max rows to show per column
                      ignore_cols_values = character(0)) {
  restore.point("compare_df")
  if (!is.data.frame(df1) || !is.data.frame(df2))
    stop("Both inputs must be data frames.")

  # Always strip Stata attributes from df1 (Stata reference) and df2 (R data)
  # to ensure clean comparison, as R data is also stripped during translation.
  df1 = sfun_strip_stata_attributes(df1)
  df2 = sfun_strip_stata_attributes(df2)

  if(identical(df1, df2)) return(list(identical=TRUE))

  if (ignore_col_order) {
    df1 = df1[, sort(names(df1)), drop = FALSE]
    df2 = df2[, sort(names(df2)), drop = FALSE]
  }
  if (ignore_row_order) {
    df1 = as.data.frame(df1)
    df2 = as.data.frame(df2)
    # Attributes already stripped above
    if (NROW(df1) > 0 && NCOL(df1) > 0) {
      df1 = df1[do.call(order, c(as.list(df1), list(na.last = TRUE))), , drop = FALSE]
    }
    if (NROW(df2) > 0 && NCOL(df2) > 0) {
      df2 = df2[do.call(order, c(as.list(df2), list(na.last = TRUE))), , drop = FALSE]
    }
  }

  out = list(identical=FALSE)

  # Check row counts first and return early if different, without detailed column diffs
  if (NROW(df1) != NROW(df2)) {
    out$row_count_mismatch = paste0("df1 has ", NROW(df1), " rows, df2 has ", NROW(df2), " rows.")
    return(out)
  }


  names_df1_raw = unname(as.character(names(df1)))
  names_df2_raw = unname(as.character(names(df2)))

  names_df1_filtered = setdiff(names_df1_raw, ignore_cols_values)
  names_df2_filtered = setdiff(names_df2_raw, ignore_cols_values)

  missing_in_do_df = setdiff(names_df2_filtered, names_df1_filtered)
  missing_in_r_df = setdiff(names_df1_filtered, names_df2_filtered)
  if (length(missing_in_do_df) + length(missing_in_r_df) > 0)
    out$column_mismatch = list(missing_in_do_df = missing_in_do_df,
                               missing_in_r_df = missing_in_r_df)

  common_cols = intersect(names_df1_filtered, names_df2_filtered)
  if (length(common_cols) == 0 && (length(names_df1_filtered) > 0 || length(names_df2_filtered) > 0)) {
      if (is.null(out$column_mismatch)) {
          out$column_mismatch = list(missing_in_do_df = missing_in_do_df,
                                     missing_in_r_df = missing_in_r_df)
      }
  }

  main_class = function(x) {
    class_val = last(class(x))
    if (class_val=="double") class_val="numeric"
    if (inherits(x, "Date")) class_val = "numeric_date_type" # Keep Date class for comparison
    class_val
  }

  type_df = data.frame(col = common_cols,
                       class_do_df = vapply(df1[common_cols], main_class, character(1)),
                       class_r_df = vapply(df2[common_cols], main_class, character(1)),
                       stringsAsFactors = FALSE)
  type_diff = type_df[type_df$class_do_df != type_df$class_r_df, ]

  type_diff = type_diff[! (type_diff$class_do_df %in% c("integer", "numeric", "numeric_date_type") &
                           type_diff$class_r_df %in% c("integer", "numeric", "numeric_date_type")),]


  if (nrow(type_diff) > 0)
    out$type_mismatch = type_diff

  cols_for_value_comp = common_cols

  value_diffs = lapply(cols_for_value_comp, function(cl) {
    v1 = df1[[cl]]
    v2 = df2[[cl]]

    # Convert to Stata numeric date representation (days since 1960-01-01) for comparison
    if (inherits(v1, "Date")) {
      v1 = as.numeric(v1 - as.Date("1960-01-01"))
    }
    if (inherits(v2, "Date")) {
      v2 = as.numeric(v2 - as.Date("1960-01-01"))
    }
    # If one is numeric (Stata date) and other is R Date (already converted above), no further action.


    if (is.numeric(v1) && is.numeric(v2)) {
      neq = rep(FALSE, length(v1))
      for (k in seq_along(v1)) {
        val1_k = v1[k]
        val2_k = v2[k]

        if (is.na(val1_k) && is.na(val2_k)) {
          neq[k] = FALSE
        } else if (is.infinite(val1_k) && is.infinite(val2_k) && sign(val1_k) == sign(val2_k)) {
          neq[k] = FALSE
        } else if (is.finite(val1_k) && is.finite(val2_k) && abs(val1_k - val2_k) <= tol) {
          neq[k] = FALSE
        } else {
          neq[k] = TRUE
        }
      }

    } else {
      neq = as.character(v1) != as.character(v2) | xor(is.na(v1), is.na(v2))
    }
    which(neq)
  })
  names(value_diffs) = cols_for_value_comp
  value_diffs = value_diffs[lengths(value_diffs) > 0]

  if (length(value_diffs) > 0) {
    sampler = function(idx, cl) {
      head_idx = head(idx, sample_n_diff)
      data.frame(row = head_idx,
                 column = cl,
                 df1_value = as.character(df1[[cl]][head_idx]),
                 df2_value = as.character(df2[[cl]][head_idx]),
                 stringsAsFactors = FALSE)
    }
    diff_tbl = do.call(rbind, Map(sampler, value_diffs, names(value_diffs)))
    rownames(diff_tbl) = NULL
    out$value_mismatch = diff_tbl
  }

  if (length(out) <= 1) {
    return(list(identical=TRUE))
  }
  out
}
```
!END_CHANGE_FILE R/aic_do_test.R

!CHANGE_FILE R/do_cmd_to_r.R
```R
  # r_obj will be a single row tibble
  # at least with the field r_code
do_cmd_to_r = function(cmd_obj, line, cmd_df) { # Corrected signature: added cmd_obj
  restore.point("do_cmd_to_r")

  if (!cmd_obj$do_translate || is.na(cmd_obj$stata_cmd)) {
     # NEW: Return the new column with default value
     return(data.frame(line=line, r_code = NA_character_, do_code = cmd_obj$do_code, stata_translation_error = NA_character_, ignore_row_order_for_comparison = cmd_obj$will_ignore_row_order_for_comparison, stringsAsFactors = FALSE))
  }

  r_code = NA_character_
  stata_translation_error = NA_character_

  translation_context = list(
    is_by_group = cmd_obj$is_by_prefix,
    is_quietly_prefix = cmd_obj$is_quietly_prefix, # Pass quietly status
    is_capture_prefix = cmd_obj$is_capture_prefix # NEW: Pass capture status
  )

  rest_of_cmd_clean = ifelse(is.na(cmd_obj$rest_of_cmd), "", cmd_obj$rest_of_cmd)
  stata_command = cmd_obj$stata_cmd

  res = tryCatch({
    r_code_translated = switch(stata_command,
      "use" = t_use(rest_of_cmd_clean, cmd_obj, cmd_df, line),
      "generate" = t_generate(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "gen" = t_generate(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "replace" = t_replace(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "summarize" = t_summarize(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "su" = t_summarize(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "egen" = t_egen(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "sort" = t_sort(rest_of_cmd_clean, cmd_obj, cmd_df, line, type="sort"),
      "gsort" = t_sort(rest_of_cmd_clean, cmd_obj, cmd_df, line, type="gsort"),
      "drop" = t_drop(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "keep" = t_keep(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "collapse" = t_collapse(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "rename" = t_rename(rest_of_cmd_clean, cmd_obj, cmd_df, line),
      "save" = t_save(rest_of_cmd_clean, cmd_obj, cmd_df, line),
      "tempfile" = t_tempfile(rest_of_cmd_clean, cmd_obj, cmd_df, line),
      "merge" = t_merge(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "append" = t_append(rest_of_cmd_clean, cmd_obj, cmd_df, line),
      "reshape" = t_reshape(rest_of_cmd_clean, cmd_obj, cmd_df, line),
      "recode" = t_recode(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "order" = t_order(rest_of_cmd_clean, cmd_obj, cmd_df, line),
      "expand" = t_expand(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "duplicates" = t_duplicates(rest_of_cmd_clean, cmd_obj, cmd_df, line),
      "encode" = t_encode(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "decode" = t_decode(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "destring" = t_destring(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "preserve" = t_preserve_restore(cmd_obj, type = "preserve"),
      "restore" = t_preserve_restore(cmd_obj, type = "restore"),
      "format" = t_format(rest_of_cmd_clean, cmd_obj, cmd_df, line),
      "label" = t_label(rest_of_cmd_clean, cmd_obj, cmd_df, line),
      "compress" = t_compress(rest_of_cmd_clean, cmd_obj, cmd_df, line),
      "regress" = t_regress(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context),
      "xi" = t_xi(rest_of_cmd_clean, cmd_obj, cmd_df, line, translation_context), # Added xi
      # Add more commands here...
      paste0("# Stata command '", cmd_obj$stata_cmd_original, " ", rest_of_cmd_clean, "' not yet fully translated.")
    )

    if (is.null(r_code_translated)) {
        r_code_translated = paste0("# Stata command '", cmd_obj$stata_cmd_original, " ", rest_of_cmd_clean, "' (",stata_command,") translation not implemented.")
    }
    list(r_code = r_code_translated, stata_translation_error = NA_character_)
  }, error = function(e) {
    list(r_code = paste0("# Translation failed for: ", cmd_obj$do_code, "\n# Error: ", e$message),
         stata_translation_error = e$message)
  })

  # NEW: Add ignore_row_order_for_comparison from cmd_obj
  r_obj = data.frame(line=line, r_code = res$r_code, do_code = cmd_obj$do_code, stata_translation_error = res$stata_translation_error, ignore_row_order_for_comparison = cmd_obj$will_ignore_row_order_for_comparison, stringsAsFactors = FALSE)
  return(r_obj)
}
```
!END_CHANGE_FILE R/do_cmd_to_r.R

!CHANGE_FILE R/do_parse.R
```R
do_parse = function(do_code) {
  # do_code is a list of character vectors, each vector is a line
  # Ensure do_code is a simple character vector
  if (is.list(do_code)) {
      do_code = unlist(do_code)
  }
  # Ensure it's a character vector, even if empty after unlist
  if (!is.character(do_code)) {
    do_code = as.character(do_code)
  }


  num_lines = length(do_code)
  if (num_lines == 0) {
    return(data.frame(
      line = integer(0),
      do_code = character(0),
      stata_cmd_original = character(0),
      stata_cmd = character(0),
      rest_of_cmd = character(0),
      is_by_prefix = logical(0),
      by_group_vars = character(0),
      by_sort_vars = character(0),
      is_quietly_prefix = logical(0),
      is_capture_prefix = logical(0), # NEW: Added capture prefix flag
      do_translate = logical(0),
      stata_translation_error = character(0),
      e_results_needed = I(vector("list", 0)), # New column for e() results
      r_results_needed = I(vector("list", 0)), # New column for r() results (future use)
      will_have_original_order_idx = logical(0), # Added by mark_data_manip_cmd logic
      will_ignore_row_order_for_comparison = logical(0), # NEW: Added for sort/gsort
      stringsAsFactors = FALSE
    ))
  }

  cmd_list = lapply(seq_along(do_code), function(i) {
    line_text = do_code[i]
    parsed_info = parse_stata_command_line(line_text)
    data.frame(
      line = i,
      do_code = line_text,
      stata_cmd_original = parsed_info$stata_cmd_original,
      stata_cmd = parsed_info$stata_cmd,
      rest_of_cmd = parsed_info$rest_of_cmd,
      is_by_prefix = parsed_info$is_by_prefix,
      by_group_vars = if (length(parsed_info$by_group_vars)>0) paste(parsed_info$by_group_vars, collapse=",") else "",
      by_sort_vars = if (length(parsed_info$by_sort_vars)>0) paste(parsed_info$by_sort_vars, collapse=",") else "",
      is_quietly_prefix = parsed_info$is_quietly_prefix,
      is_capture_prefix = parsed_info$is_capture_prefix, # NEW: Assign capture prefix flag
      stata_translation_error = NA_character_,
      will_ignore_row_order_for_comparison = FALSE, # NEW: Initialize here
      stringsAsFactors = FALSE
    )
  })

  cmd_df = dplyr::bind_rows(cmd_list)
  # Initialize e_results_needed and r_results_needed as list columns
  cmd_df$e_results_needed = I(replicate(nrow(cmd_df), character(0), simplify = FALSE))
  cmd_df$r_results_needed = I(replicate(nrow(cmd_df), character(0), simplify = FALSE))
  # NEW: Initialize will_have_original_order_idx here too, it's safer
  cmd_df$will_have_original_order_idx = rep(FALSE, NROW(cmd_df)) 
  return(cmd_df)
}
```
!END_CHANGE_FILE R/do_parse.R

!CHANGE_FILE R/stata_cmd_utils.R
```R
# Stata command utilities

# Main Stata commands and their abbreviations
# This list is not exhaustive but covers many common commands.
stata_cmd_abbreviations = list(
  "a" = "append",
  "br" = "browse",
  "by" = "bysort", # 'by' is often a prefix, but can be 'bysort'
  "cap" = "capture", # 'capture' is a prefix, but included here for completeness if ever used as a standalone command.
  "cd" = "cd",
  "cl" = "clear", # clear all
  "co" = "collapse",
  "comp" = "compress",
  "conf" = "confirm",
  "cons" = "constraint",
  "contr" = "contrast",
  "cop" = "copy",
  "cor" = "correlate",
  "cou" = "count",
  "d" = "describe",
  "de" = "decode",
  "dest" = "destring",
  "di" = "display",
  "dir" = "dir",
  "do" = "do",
  "dr" = "drop",
  "du" = "duplicates",
  "e" = "edit",
  "eg" = "egen",
  "en" = "encode",
  "er" = "erase",
  "est" = "estimates", # estimates command group
  "ex" = "expand",
  "f" = "fillin",
  "g" = "generate",
  "gr" = "graph",
  "gs" = "gsort",
  "h" = "help",
  "i" = "inspect",
  "ins" = "insheet",
  "k" = "keep",
  "l" = "list",
  "la" = "label",
  "logi" = "logit", # Example statistical procedure
  "m" = "merge",
  "mark" = "marksample",
  "markout" = "markout",
  "mat" = "matrix",
  "mem" = "memory",
  "mkdir" = "mkdir",
  "mo" = "more",
  "mov" = "move",
  "mv" = "mvdecode", # mvdecode is a command
  "n" = "notes",
  "o" = "order",
  "ou" = "outsheet",
  "p" = "predict", # predict for generating variables from models
  "pres" = "preserve",
  "q" = "quietly", # Quietly is a prefix, handled differently
  "r" = "recode",
  "reg" = "regress", # Example statistical procedure
  "ren" = "rename",
  "res" = "reshape",
  "rest" = "restore",
  "ret" = "return", # For return values from programs
  "rm" = "rmdir",
  "ru" = "run", # alias for do
  "sa" = "save",
  "sc" = "scalar",
  "se" = "set", # set memory, set type, etc.
  "sh" = "shell",
  "sig" = "signestim",
  "so" = "sort",
  "st" = "stata", # invoke Stata
  "su" = "summarize",
  "sy" = "sysuse",
  "t" = "tabulate", # tabulate can set r() values
  "te" = "test", # For hypotheses tests
  "temp" = "tempfile", # tempfile, tempvar, tempname
  "ty" = "type", # list content of a file
  "u" = "use",
  "v" = "version", # version control
  "w" = "which", # find file
  "xi" = "xi" # For indicator variable generation
  # "x" = "xtile" # egen function typically
)

# Function to get the full Stata command name from a token (could be an abbreviation)
get_stata_full_cmd_name = function(cmd_token) {
  restore.point("get_stata_full_cmd_name")
  if (is.na(cmd_token) || cmd_token == "") { # Defensive check
    return(NA_character_)
  }
  cmd_token_lower = tolower(cmd_token)
  # Use isTRUE to handle potential NA from %in% (though unlikely for this context)
  if (isTRUE(cmd_token_lower %in% names(stata_cmd_abbreviations))) {
    return(stata_cmd_abbreviations[[cmd_token_lower]])
  }
  # If not in abbreviations, assume it's already a full (or unrecognized) command
  return(cmd_token_lower)
}


# List of Stata commands considered to modify the dataset
stata_data_manip_cmds = c(
  "append", "collapse", "compress", "contract", "decode", "destring", "drop",
  "duplicates", "egen", "encode", "expand", "fillin",
  "generate", "gen", "gsort", "input", "insheet", "keep", "label",
  "merge", "modify", "move", "mvdecode", "mvrecode", "order", "pctile",
  "predict",
  "preserve", "recode", "rename", "reshape", "restore", "sample", "set",
  "sort", "stack", "statsby", "stsplit",
  "svar", "sysuse",
  "tempfile", "tempvar", "tempname",
  "total",
  "use", "xtile",
  "replace", "clear"
)

# Commands that primarily display info or control program flow, and *never* modify data or produce e()/r() results for later use.
stata_non_data_manip_cmds = c(
  "assert", "browse", "capture", "cd", "confirm", "constraint", "display", "di", "do", "edit", "erase", "error",
  "exit", "findit", "format", "graph", "gr", "help", "h", "if", "inspect", "i", "list", "l", "log", "lookup", "marksample",
  "matrix", "mat", "memory", "mem", "mkdir", "more", "mo", "notes", "n", "outfile", "outsheet", "ou", "pause", "plot",
  "print", "program", "pwd", "query",
  "return", "ret", "rmdir", "run", "ru", "scalar", "sc", "search", "shell", "sh", "signestim", "sleep",
  "stata", "st", "tabdisp", "table", "test", "te", "timer", "translate", "truncate",
  "tutorials", "type", "ty", "view", "version", "v", "webuse", "w", "which", "while", "window", "winexec", "xmlsav"
)

# List of estimation commands that can produce e() results
stata_estimation_cmds = c(
  "regress", "logit", "probit", "ivregress", "xtreg", "areg", "sem", "asmixlogit", "gmm", "xi"
)

# List of commands that can produce r() results
stata_r_result_cmds = c(
  "summarize", "su", "tabulate", "tab", "count", "correlate"
)


# Helper to parse basic Stata command line: cmd + rest
# Tries to handle `capture`, `quietly`, `by` prefixes.
# Returns:
#   stata_cmd_original: original first token of the effective command (e.g. "g" for "gen")
#   stata_cmd: full command name of the effective command (e.g. "generate")
#   rest_of_cmd: string after effective command token
#   is_by_prefix: logical, TRUE if "by/bysort prefix:" was found
#   by_group_vars: character vector of grouping variables from by/bysort prefix
#   by_sort_vars: character vector of sort-only variables (in parentheses) from by/bysort prefix
#   is_quietly_prefix: logical, TRUE if "quietly" prefix was found
#   is_capture_prefix: logical, TRUE if "capture" prefix was found
parse_stata_command_line = function(line_text) {
  restore.point("parse_stata_command_line")
  trimmed_line = stringi::stri_trim_both(line_text)
  
  effective_line = trimmed_line

  # Initialize all flags
  is_by_prefix_val = FALSE
  by_group_vars = character(0)
  by_sort_vars = character(0)
  is_quietly_prefix_val = FALSE
  is_capture_prefix_val = FALSE

  # 1. Check for "capture" prefix
  # Regex to match "capture" or "cap" as a whole word prefix followed by space
  capture_prefix_regex = "^(?:capture|cap)\\s+(.*)$"
  capture_match = stringi::stri_match_first_regex(effective_line, capture_prefix_regex)
  if (!is.na(capture_match[1,1])) {
    first_token_before_space = stringi::stri_extract_first_words(effective_line)
    if (tolower(first_token_before_space) %in% c("capture", "cap")) {
      is_capture_prefix_val = TRUE
      effective_line = stringi::stri_trim_both(capture_match[1,2])
    }
  }

  # 2. Check for "quietly" prefix
  # Regex to match "quietly" or "qui" or "q" as a whole word prefix followed by space
  quietly_prefix_regex = "^(?:quietly|qui|q)\\s+(.*)$"
  quietly_match = stringi::stri_match_first_regex(effective_line, quietly_prefix_regex)
  if (!is.na(quietly_match[1,1])) {
      first_token_before_space = stringi::stri_extract_first_words(effective_line)
      if (tolower(first_token_before_space) %in% c("quietly", "qui", "q")) {
        is_quietly_prefix_val = TRUE
        effective_line = stringi::stri_trim_both(quietly_match[1,2])
      }
  }

  # 3. Check for "by ... :" or "bysort ... :" prefix
  if (dplyr::coalesce(stringi::stri_startswith_fixed(effective_line, "by "), FALSE) ||
      dplyr::coalesce(stringi::stri_startswith_fixed(effective_line, "bysort "), FALSE)) {
    prefix_match = stringi::stri_match_first_regex(effective_line, "^(?:by|bysort)\\s+([^:]+?)\\s*:\\s*(.*)$")
    if (!is.na(prefix_match[1,1])) {
      raw_by_string_from_prefix = stringi::stri_trim_both(prefix_match[1,2])
      effective_line = stringi::stri_trim_both(prefix_match[1,3])
      is_by_prefix_val = TRUE

      by_tokens = character(0)
      if (!is.na(raw_by_string_from_prefix) && raw_by_string_from_prefix != "") {
          match_result = stringi::stri_match_all_regex(raw_by_string_from_prefix, "\\s*(\\([^)]+\\)|[^\\s()]+)\\s*")
          if (!is.null(match_result[[1]]) && NROW(match_result[[1]]) > 0) {
              by_tokens = match_result[[1]][,2]
          }
      }

      for (token in by_tokens) {
        if (dplyr::coalesce(stringi::stri_startswith_fixed(token, "(") && stringi::stri_endswith_fixed(token, ")"), FALSE)) {
          sort_vars_in_paren = stringi::stri_sub(token, 2, -2)
          by_sort_vars = c(by_sort_vars, stringi::stri_split_regex(stringi::stri_trim_both(sort_vars_in_paren), "\\s+")[[1]])
        } else {
          by_group_vars = c(by_group_vars, token)
        }
      }
      by_group_vars = by_group_vars[!is.na(by_group_vars) & by_group_vars != ""]
      by_sort_vars = by_sort_vars[!is.na(by_sort_vars) & by_sort_vars != ""]
    }
  }

  # Extract command token from the (now prefix-stripped) effective_line
  parts = stringi::stri_split_fixed(effective_line, " ", n = 2)
  cmd_token_original = stringi::stri_trim_both(parts[[1]][1])

  if (is.na(cmd_token_original) || cmd_token_original == "") {
      return(list(
        stata_cmd_original = NA_character_,
        stata_cmd = NA_character_,
        rest_of_cmd = NA_character_,
        is_by_prefix = is_by_prefix_val,
        by_group_vars = character(0),
        by_sort_vars = character(0),
        is_quietly_prefix = is_quietly_prefix_val,
        is_capture_prefix = is_capture_prefix_val
      ))
  }

  stata_cmd = get_stata_full_cmd_name(cmd_token_original)
  rest_of_cmd = if (length(parts[[1]]) > 1 && !is.na(parts[[1]][2])) stringi::stri_trim_both(parts[[1]][2]) else NA_character_

  # Refine is_by_prefix: it's a prefix if by_vars were parsed AND command is not 'bysort'
  if (stata_cmd == "bysort" || stata_cmd == "by") {
      is_by_prefix_val = FALSE
      by_group_vars = character(0)
      by_sort_vars = character(0)
      if (stata_cmd == "by") stata_cmd = "bysort"
  }

  return(list(
    stata_cmd_original = cmd_token_original, # First token of effective command
    stata_cmd = stata_cmd,                   # Full name of effective command
    rest_of_cmd = rest_of_cmd,
    is_by_prefix = is_by_prefix_val,
    by_group_vars = by_group_vars,
    by_sort_vars = by_sort_vars,
    is_quietly_prefix = is_quietly_prefix_val,
    is_capture_prefix = is_capture_prefix_val
  ))
}

# Helper function to get macro names from a tempfile command's rest_of_cmd
get_tempfile_macros = function(rest_of_cmd_for_tempfile) {
    restore.point("get_tempfile_macros")
    if (is.na(rest_of_cmd_for_tempfile) || rest_of_cmd_for_tempfile == "") return(character(0))
    stringi::stri_split_regex(rest_of_cmd_for_tempfile, "\\s+")[[1]] %>%
        stringi::stri_trim_both() %>%
        .[. != ""]
}

# Helper function to unquote Stata string literals
unquote_stata_string_literal = function(s) {
  restore.point("unquote_stata_string_literal")
  if (is.na(s) || s == "") return(s)
  # Remove outer double quotes
  if (dplyr::coalesce(stringi::stri_startswith_fixed(s, '"') && stringi::stri_endswith_fixed(s, '"'), FALSE)) {
    return(stringi::stri_sub(s, 2, -2))
  }
  # Remove outer single quotes
  if (dplyr::coalesce(stringi::stri_startswith_fixed(s, "'") && stringi::stri_endswith_fixed(s, "'"), FALSE)) {
    return(stringi::stri_sub(s, 2, -2))
  }
  # If not quoted, return as is
  return(s)
}

# Helper function to ensure a string is quoted for R literal use if not already
# This function expects an already UNQUOTED string (no Stata-style quotes)
quote_for_r_literal = function(s) {
  restore.point("quote_for_r_literal")
  if (is.na(s)) return("NA_character_")
  if (s == "") return('""')
  # Check if already quoted with " or '
  if (dplyr::coalesce(stringi::stri_startswith_fixed(s, '"') && stringi::stri_endswith_fixed(s, '"'), FALSE)) return(s)
  if (dplyr::coalesce(stringi::stri_startswith_fixed(s, "'") && stringi::stri_endswith_fixed(s, "'"), FALSE)) return(s)
  # Add double quotes
  paste0('"', s, '"')
}

# Helper function to resolve Stata filenames (literal or macro) to R path expressions
# default_base_dir_var: name of the variable in stata2r_env (e.g., "working_dir", "data_dir")
resolve_stata_filename = function(raw_filename_token, cmd_df, line_num, default_base_dir_var = "working_dir") {
  restore.point("resolve_stata_filename")
  unquoted_content = unquote_stata_string_literal(raw_filename_token)

  # Check if it's a Stata local macro reference `macroname'`
  if (dplyr::coalesce(stringi::stri_startswith_fixed(unquoted_content, "`") && stringi::stri_endswith_fixed(unquoted_content, "'"), FALSE)) {
    macro_name = stringi::stri_sub(unquoted_content, 2, -2)

    found_def_line = NA_integer_
    for (i in (line_num - 1):1) {
        if (cmd_df$stata_cmd[i] == "tempfile") {
            defined_macros = get_tempfile_macros(cmd_df$rest_of_cmd[i])
            if (macro_name %in% defined_macros) {
                found_def_line = cmd_df$line[i]
                break
            }
        }
    }

    if (!is.na(found_def_line)) {
        return(paste0("R_tempfile_L", found_def_line, "_", macro_name, "_path"))
    } else {
        warning(paste0("Macro ", unquoted_content, " in command at line ", line_num, " not resolved from tempfile. Treating as literal string."))
        return(quote_for_r_literal(unquoted_content))
    }
  } else {
    # It's a regular path string
    is_absolute_path = dplyr::coalesce(stringi::stri_startswith_fixed(unquoted_content, "/"), FALSE) ||
                       dplyr::coalesce(stringi::stri_detect_regex(unquoted_content, "^[A-Za-z]:[\\\\/]"), FALSE)

    if (is_absolute_path) {
      return(quote_for_r_literal(unquoted_content))
    } else {
      return(paste0("file.path(stata2r_env$", default_base_dir_var, ", ", quote_for_r_literal(unquoted_content), ")"))
    }
  }
}

get_xi_base_name = function(varname) {
  # Stata's xi naming convention for base variable part is complex and heuristic.
  # This function attempts to replicate some observed behaviors from `do3.log`.
  if (base::endsWith(varname, "_factor")) {
    return(stringi::stri_replace_last_fixed(varname, "_factor", "_f"))
  } else if (varname == "region_cat") {
    # Specific truncation observed in do3.log: region_cat (10 chars) -> region_ca (8 chars)
    return("region_ca")
  } else {
    # For other variables like "group_cat" (9 chars), it seems to keep the full name.
    # This rule is a heuristic based on limited test cases.
    return(varname)
  }
}

get_xi_interaction_basename = function(var1, var2) {
  # Heuristic for Stata's xi interaction naming (e.g., region_cat*group_cat -> regXgro)
  # Takes first 3 characters of each variable's *original* name, concatenates with 'X'.
  short_var1 = stringi::stri_sub(var1, 1, min(stringi::stri_length(var1), 3))
  short_var2 = stringi::stri_sub(var2, 1, min(stringi::stri_length(var2), 3))
  return(paste0(short_var1, "X", short_var2))
}
```
!END_CHANGE_FILE R/stata_cmd_utils.R
