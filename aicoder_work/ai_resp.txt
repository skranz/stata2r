The main task is to fix the two failing tests, `do1` and `do2`, which both report a "missing value where TRUE/FALSE needed" error during the translation phase. This error typically arises when a logical condition (e.g., in an `if` statement or a boolean operation like `&&`) evaluates to `NA`.

Upon detailed analysis, the existing code already uses `dplyr::coalesce(..., FALSE)` or `isTRUE(...)` in most places where `NA` propagation could lead to such an error. However, a very subtle issue might exist if intermediate `stringi` operations produce `NA` values in a way that is not fully caught, or if there's a type mismatch in inputs to these functions.

The following changes are made to enhance robustness and ensure that `NA` values are handled explicitly, particularly at the entry points of expression translation functions and in the parsing of command arguments:

1.  **Increased Robustness for Input Handling (`sfun_is_stata_expression_string_typed`, `translate_stata_expression_to_r`):** Explicitly ensure that input expressions are single `character` strings, converting `NULL` or `character(0)` to `NA_character_` at the very beginning of these functions. This prevents potential issues if `stringi` functions receive unexpected input types or lengths.
2.  **Refined `NA` Handling in `t_generate` and `t_replace`:** Ensure that when a `stata_expr` translates to `NA_character_`, the subsequent R code correctly uses `NA_real_` or `""` as appropriate for numerical or string contexts, rather than propagating `NA_character_` directly into R expressions that might then cause type coercion errors. This includes more explicit checks for string-typed expressions and their `NA` representation.
3.  **Improved `t_recode` label processing:** Ensured that the logic for collecting and sorting labels for `haven::labelled` variables correctly handles potential `NA` values and maintains consistency with Stata's behavior of prioritizing the last defined label for a given value. This also ensures correct type casting for the target variable (string, labelled numeric, or plain numeric).

These changes aim to prevent `NA` values from being implicitly used in logical contexts within the translation logic, which is the most common cause of the reported error.

!CHANGE_FILE R/sfun_is_stata_expression_string_typed.R
```R
sfun_is_stata_expression_string_typed = function(stata_expr_original) {
  restore.point("sfun_is_stata_expression_string_typed")
  
  # Ensure stata_expr_original is a single character string or NA
  if (is.null(stata_expr_original) || length(stata_expr_original) == 0 || !is.character(stata_expr_original)) {
      stata_expr_original = NA_character_
  } else {
      stata_expr_original = as.character(stata_expr_original[1])
  }

  if (is.na(stata_expr_original) || stata_expr_original == "") return(FALSE)

  # 1. Contains any string literal (text enclosed in double or single quotes)
  # Ensure stri_detect_regex result is explicitly logical. If NA, treat as FALSE.
  if (dplyr::coalesce(stringi::stri_detect_regex(stata_expr_original, '"[^"]*"|\'[^\']*\'' ), FALSE)) {
    return(TRUE)
  }

  # 2. Check for explicitly numeric-returning functions. If found, return FALSE immediately.
  numeric_producing_functions = c(
    "log", "sqrt", "int", "round", "mod", "runiform", "mdy", "date",
    "year", "month", "day", "qofd", "dow", "missing",
    # Stata type casting functions that convert to numeric:
    "float", "double", "long", "int", "byte"
  )
  for (func in numeric_producing_functions) {
    if (dplyr::coalesce(stringi::stri_detect_regex(stata_expr_original, paste0("\\b", func, "\\s*\\(")), FALSE)) {
      return(FALSE)
    }
  }

  # 3. Check for explicitly string-returning functions.
  string_producing_functions = c(
    "char", "itrim", "lower", "ltrim", "proper", "rtrim", "string", "subinstr",
    "substr", "strl", "strpos", "strreverse", "strtrim", "trim", "upper",
    "ustrleft", "ustrlower", "ustrpos", "ustrright", "ustrtrim", "ustrunescape",
    "ustrupper", "ustrword", "ustrwordcount", "word", "wordcount",
    # Stata type casting functions that convert to string:
    "string"
  )
  for (func in string_producing_functions) {
    if (dplyr::coalesce(stringi::stri_detect_regex(stata_expr_original, paste0("\\b", func, "\\s*\\(")), FALSE)) {
      return(TRUE)
    }
  }

  # 4. `cond(condition, val_if_true, val_if_false)`: if any value (val_if_true, val_if_false) is string, result is string.
  cond_match = stringi::stri_match_first_regex(stata_expr_original, "\\bcond\\(([^,]+),([^,]+),([^)]+)\\)")
  if (!is.na(cond_match[1,1])) {
      val_if_true_str = stringi::stri_trim_both(cond_match[1,3])
      val_if_false_str = stringi::stri_trim_both(cond_match[1,4])
      # Recursively check the arguments for string type
      # FIX: Ensure results of recursive calls are not NA before ORing them
      if (dplyr::coalesce(sfun_is_stata_expression_string_typed(val_if_true_str), FALSE) ||
          dplyr::coalesce(sfun_is_stata_expression_string_typed(val_if_false_str), FALSE)) {
          return(TRUE)
      } else {
          # If both are numeric, cond is numeric
          return(FALSE)
      }
  }

  # If none of the above rules apply, default to numeric.
  # This implies that if it's a variable reference, it's numeric unless explicitly string.
  # Or if it's a simple arithmetic expression, it's numeric.
  return(FALSE)
}

```
!END_CHANGE_FILE R/sfun_is_stata_expression_string_typed.R

!CHANGE_FILE R/stata_expression_translator.R
```R
translate_stata_expression_to_r = function(stata_expr, context = list(is_by_group = FALSE), r_value_mappings = NULL) {
  restore.point("translate_stata_expression_to_r")
  
  # Ensure stata_expr is a single character string or NA
  if (is.null(stata_expr) || length(stata_expr) == 0 || !is.character(stata_expr)) {
      stata_expr = NA_character_
  } else {
      stata_expr = as.character(stata_expr[1]) # Ensure it's a single string
  }

  if (is.na(stata_expr) || stata_expr == "") {
    return("NA_real_") 
  }

  r_expr = stata_expr

  # --- New: Handle string literals by replacing them with unique placeholders ---
  # This prevents them from being backticked or otherwise mangled by other regexes.
  string_literal_map = list()
  # Find all string literals (double or single quoted)
  literal_matches = stringi::stri_match_all_regex(r_expr, '"[^"]*"|\'[^\']*\'')[[1]]
  
  if (!is.null(literal_matches) && NROW(literal_matches) > 0) {
      # Iterate and replace. Sorting by end position descending is safer for overlapping regexes
      # but here we are replacing fixed strings, so order doesn't strictly matter.
      # However, to avoid issues if a placeholder becomes part of a later literal,
      # it's good to replace in a way that doesn't affect other parts of the string being processed.
      # For this simple replacement, a simple loop over matches is fine.
      
      # Use a unique counter for placeholders
      placeholder_counter = 0
      for (k in seq_len(NROW(literal_matches))) {
          literal_text = literal_matches[k, 1]
          # Check if this literal_text is already a placeholder from a previous iteration (unlikely but safe)
          if (stringi::stri_startswith_fixed(literal_text, "STATA2R_STR_LITERAL_PLACEHOLDER_") && stringi::stri_endswith_fixed(literal_text, "_")) {
            next # Already a placeholder, skip
          }
          placeholder_counter = placeholder_counter + 1
          placeholder = paste0("STATA2R_STR_LITERAL_PLACEHOLDER_", placeholder_counter, "_")
          r_expr = stringi::stri_replace_first_fixed(r_expr, literal_text, placeholder)
          string_literal_map[[placeholder]] = literal_text # Store after replacement to avoid issues with already replaced text
      }
  }
  # --- End new string literal handling ---


  # Step 1: Handle Stata missing value literals '.', '.a', ..., '.z'
  r_expr = stringi::stri_replace_all_regex(r_expr, "(?<![0-9a-zA-Z_])\\.[a-zA-Z]?(?![0-9a-zA-Z_])", "NA_real_")

  # Step 2: Handle r() values using the mapping.
  if (!is.null(r_value_mappings) && length(r_value_mappings) > 0) {
    for (stata_r_name in names(r_value_mappings)) {
      stata_r_regex = gsub("(", "\\(", gsub(")", "\\)", stata_r_name, fixed=TRUE), fixed=TRUE)
      r_expr = stringi::stri_replace_all_regex(r_expr, stata_r_regex, r_value_mappings[[stata_r_name]])
    }
  }

  # Step 3: Translate Stata logical operators and missing value comparisons.
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\b[a-zA-Z_][a-zA-Z0-9_.]*\\b)\\s*==\\s*NA_real_", "sfun_missing($1)")
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\b[a-zA-Z_][a-zA-Z0-9_.]*\\b)\\s*!=\\s*NA_real_", "!sfun_missing($1)")
  r_expr = stringi::stri_replace_all_regex(r_expr, "(?<![<>=!~])\\s*=\\s*(?![=])", " == ")
  r_expr = stringi::stri_replace_all_regex(r_expr, "\\s+~=\\s+", " != ")


  # Step 4: Translate Stata special variables and indexing (e.g., _n, _N, var[_n-1])
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\w+)\\[_n\\s*-\\s*(\\d+)\\]", "dplyr::lag(`$1`, n = $2)")
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\w+)\\[_n\\s*\\+\\s*(\\d+)\\]", "dplyr::lead(`$1`, n = $2)")
  r_expr = stringi::stri_replace_all_regex(r_expr, "(\\w+)\\[_n\\]", "`$1`")
  r_expr = stringi::stri_replace_all_regex(r_expr, "\\b_n\\b", "dplyr::row_number()")
  r_expr = stringi::stri_replace_all_regex(r_expr, "\\b_N\\b", "dplyr::n()")


  # Step 5: Iteratively translate Stata functions (e.g., cond(), round(), log(), etc.)
  old_r_expr = ""
  while (dplyr::coalesce(r_expr != old_r_expr, FALSE)) {
    old_r_expr = r_expr

    # Fix: Use the new sfun_stata_cond helper for robust cond() translation
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bcond\\(([^,]+),([^,]+),([^)]+)\\)", "sfun_stata_cond($1, $2, $3)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bround\\(([^,]+),([^)]+)\\)", "sfun_stata_round($1, $2)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bround\\(([^)]+)\\)", "sfun_stata_round($1, 1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bmod\\(([^,]+),([^)]+)\\)", "($1 %% $2)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bmissing\\(([^)]+)\\)", "sfun_missing($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\blog\\(([^)]+)\\)", "log($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bsqrt\\(([^)]+)\\)", "sqrt($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bint\\(([^)]+)\\)", "trunc($1)")

    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstrtrim\\(([^)]+)\\)", "stringi::stri_trim_right($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstritrim\\(([^)]+)\\)", "sfun_stritrim($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\blower\\(([^)]+)\\)", "stringi::stri_trans_tolower($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bupper\\(([^)]+)\\)", "stringi::stri_trans_toupper($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bsubstr\\(([^,]+),([^,]+),([^)]+)\\)", "stringi::stri_sub($1, from = $2, length = $3)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bsubinstr\\(([^,]+),([^,]+),([^,]+),([^)]+)\\)", "sfun_subinstr($1, $2, $3, $4)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstrpos\\(([^,]+),([^)]+)\\)", "sfun_strpos($1, $2)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\blength\\(([^)]+)\\)", "stringi::stri_length($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstrlen\\(([^)]+)\\)", "stringi::stri_length($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bstring\\(([^)]+)\\)", "sfun_string($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bruniform\\(\\)", "stats::runif(dplyr::n())")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bdate\\(([^,]+),([^,]+),([^)]+)\\)", "sfun_stata_date($1, $2, $3)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bdate\\(([^,]+),([^)]+)\\)", "sfun_stata_date($1, $2)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bmdy\\(([^,]+),([^,]+),([^)]+)\\)", "sfun_stata_mdy($1, $2, $3)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\byear\\(([^)]+)\\)", "as.numeric(format(as.Date($1, origin = '1960-01-01'), '%Y'))")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bmonth\\(([^)]+)\\)", "sfun_month($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bday\\(([^)]+)\\)", "sfun_day($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bqofd\\(([^)]+)\\)", "sfun_qofd($1)")
    r_expr = stringi::stri_replace_all_regex(r_expr, "\\bdow\\(([^)]+)\\)", "sfun_dow($1)")
  }

  if (is.na(r_expr) || r_expr == "") {
      warning(paste0("R expression became NA or empty after function translation. Original Stata expression: '", stata_expr, "'"))
      return("NA_real_") 
  }

  # Step 6: Quote bare variable names with backticks
  r_reserved_words = c(
    "TRUE", "FALSE", "NA_real_", "NA_character_", "NA_integer_", "NA", "NULL",
    "if_else", "coalesce", "row_number", "n", "lag", "lead", "select", "filter",
    "mutate", "group_by", "ungroup", "syms", "all_of", "everything", "matches",
    "pivot_wider", "pivot_longer", "read_dta", "write_dta", "labelled", "zap_labels",
    "zap_formats", "zap_missing", "as_factor", "parse_number",
    "mean", "sum", "median", "sd", "min", "max", "log", "sqrt", "trunc", "rank",
    "rowSums", "rowMeans", "setNames", "match", "tempfile", "file.path",
    "fmean", "fsum", "fN", "ffirst", "flast", "fmin", "fmax", "fmedian", "fsd",
    "fquantile", "fgroup_by", "fungroup", "fsubset", "frename", "bind_rows", "rep",
    "as_tibble", "inherits", "format", "as.Date", "as.numeric", "as.character", "as.integer",
    "sign", "floor", "abs", "pmax", "stringi", "base", "stats", "dplyr", "collapse", "haven",
    "readr", "tidyr", "labelled", "restorepoint", "stata2r_env",
    "sfun_missing", "sfun_stata_add", "sfun_stata_round", "sfun_string", "sfun_stritrim",
    "sfun_strpos", "sfun_subinstr", "sfun_stata_mdy", "sfun_stata_date", "sfun_day",
    "sfun_month", "sfun_qofd", "sfun_dow", "sfun_normalize_string_nas", "sfun_strip_stata_attributes",
    "sfun_compress_col_type", "sfun_is_stata_expression_string_typed", "as.logical",
    "sfun_stata_cond"
  )
  
  locations = stringi::stri_locate_all_regex(r_expr, "\\b([a-zA-Z_][a-zA-Z0-9_.]*)\\b")[[1]]
  
  if (!is.null(locations) && NROW(locations) > 0) {
      locations = locations[order(locations[,2], decreasing = TRUE), , drop = FALSE]
      
      for (k in seq_len(NROW(locations))) {
          start_pos = locations[k,1]
          end_pos = locations[k,2]
          current_word = stringi::stri_sub(r_expr, start_pos, end_pos)
          
          is_reserved = dplyr::coalesce(current_word %in% r_reserved_words, FALSE)
          is_numeric_literal = dplyr::coalesce(suppressWarnings(!is.na(as.numeric(current_word))), FALSE)
          
          is_already_backticked = FALSE
          # Check if the word is already backticked by looking at characters before and after
          if (dplyr::coalesce(start_pos > 1 && end_pos < stringi::stri_length(r_expr), FALSE)) { # end_pos < length to ensure there's a char after
            char_before = dplyr::coalesce(stringi::stri_sub(r_expr, start_pos - 1, start_pos - 1), "")
            char_after = dplyr::coalesce(stringi::stri_sub(r_expr, end_pos + 1, end_pos + 1), "")
            is_already_backticked = (char_before == "`" && char_after == "`")
          }
          
          if (isTRUE(!is_reserved) && isTRUE(!is_numeric_literal) && isTRUE(!is_already_backticked)) {
              r_expr = paste0(stringi::stri_sub(r_expr, 1, start_pos - 1),
                              "`", current_word, "`",
                              stringi::stri_sub(r_expr, end_pos + 1, stringi::stri_length(r_expr)))
          }
      }
  }


  # Step 7: Translate Stata '+' operator to sfun_stata_add for polymorphic behavior
  # Define a more robust pattern for operands that can be on either side of '+'
  # This pattern tries to capture common R-translated elements like quoted strings, numbers, NA/NULL,
  # backticked variable names, and function calls.
  operand_pattern = "(?:\"[^\"]*\"|'[^']*'|\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?|\\b(?:NA_real_|NULL)\\b|\\b(?:TRUE|FALSE)\\b|`[^`]+`|\\b[a-zA-Z_][a-zA-Z0-9_.]*\\s*\\(.*?\\)\\s*)"
  
  old_r_expr_add = ""
  # Loop to apply replacements until no more '+' can be replaced, handling nested sfun_stata_add
  while (dplyr::coalesce(r_expr != old_r_expr_add, FALSE)) {
    old_r_expr_add = r_expr
    # Regex to find '+' that is not part of '++', '+=', '!=', '>=', '<='
    # Ensure it's not preceded by <, >, =, !, ~
    # Ensure it's not followed by + or =
    add_regex_middle_part = "\\s*(?<![<>=!~])\\+\\s*(?!\\s*\\+|\\s*=\\s*)"
    add_regex_full = paste0("(", operand_pattern, ")", add_regex_middle_part, "(", operand_pattern, ")")
    r_expr = stringi::stri_replace_all_regex(r_expr, add_regex_full, "sfun_stata_add($1, $2)")
  }


  # --- New: Restore string literals from placeholders ---
  # Iterate in reverse order of placeholder creation to handle potential nested replacements
  # though for string literals, simple fixed replacement is usually fine.
  # Sorting by the length of the placeholder name (descending) ensures longer placeholders are replaced first,
  # preventing partial matches if placeholders were substrings of each other.
  # Here, placeholder names are unique and fixed length prefix, so simple iteration is fine.
  if (length(string_literal_map) > 0) {
      # Use a loop over sorted names to ensure deterministic order if needed, but for fixed string replacement, it's not critical.
      # For robustness, we could sort by length then alphabetically.
      sorted_placeholders = names(string_literal_map)[order(stringi::stri_length(names(string_literal_map)), names(string_literal_map), decreasing = TRUE)]
      for (placeholder in sorted_placeholders) {
          r_expr = stringi::stri_replace_all_fixed(r_expr, placeholder, string_literal_map[[placeholder]])
      }
  }
  # --- End new string literal restoration ---

  return(r_expr)
}

```
!END_CHANGE_FILE R/stata_expression_translator.R

!CHANGE_FILE R/t_generate.R
```R
t_generate = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_generate")
  # Parse `rest_of_cmd` for new variable name, expression, and if condition
  # Example: "newvar = expression [if condition]"

  # Capture explicit type declaration (e.g., `str10`)
  explicit_type_match = stringi::stri_match_first_regex(rest_of_cmd, "^\\s*(byte|int|long|float|double|str\\d+|strL)\\s+")
  declared_type_str = NA_character_
  if (!is.na(explicit_type_match[1,1])) {
    declared_type_str = explicit_type_match[1,2]
  }

  # Strip type if present (e.g. gen double newvar = ...)
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^\\s*(?:byte|int|long|float|double|str\\d+|strL)\\s+", "")

  match = stringi::stri_match_first_regex(rest_of_cmd_no_type, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  # NEW: Defensive check for successful parsing of core components
  # Ensure all parts are character, even if NA
  new_var = NA_character_
  stata_expr = NA_character_
  stata_if_cond = NA_character_

  if (!is.na(match[1,1])) { # If the overall regex matched
      new_var = dplyr::coalesce(stringi::stri_trim_both(match[1,2]), NA_character_)
      stata_expr = dplyr::coalesce(stringi::stri_trim_both(match[1,3]), NA_character_)
      stata_if_cond = dplyr::coalesce(stringi::stri_trim_both(match[1,4]), NA_character_)
  } else {
      # If no match, return a parsing error
      return(paste0("# Failed to parse generate command structure: ", rest_of_cmd))
  }

  # Context for expression translation (e.g. _n, _N behavior)
  # is_by_group TRUE if cmd_obj$by_group_vars is not NA
  current_context = list(is_by_group = cmd_obj$is_by_prefix && length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1]))
  
  # Translate the Stata expression to R first
  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, current_context)

  # Ensure r_expr is a character string literal, even if it represents NA (logical)
  # If r_expr is NA from translation (e.g., if stata_expr was empty), treat it as NA_real_ string.
  if (is.na(r_expr)) { 
      r_expr = "NA_real_"
  }


  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    # The 'if' condition for generate/replace is evaluated row-wise on the whole dataset, not per group.
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  # Determine group_vars for dplyr::group_by
  group_vars_list_bare = character(0) 
  
  if (cmd_obj$is_by_prefix) {
    if (length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1])) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[!is.na(group_vars_list) & group_vars_list != ""]
      if (length(group_vars_list) > 0) {
        group_vars_list_bare = group_vars_list # Assign just the bare names
      }
    }
  }

  # Determine if the target variable will be a string type based on EXPLICIT Stata declaration.
  # If no explicit type, let R infer from the translated expression.
  is_stata_expr_string_typed = sfun_is_stata_expression_string_typed(stata_expr)

  # Apply explicit type casting if declared in Stata command, overriding inferred type
  if (!is.na(declared_type_str)) {
      if (stringi::stri_startswith_fixed(declared_type_str, "str")) {
          is_stata_expr_string_typed = TRUE
      } else { # byte, int, long, float, double
          is_stata_expr_string_typed = FALSE
      }
  }

  # Step 1: Calculate the value for the new variable, potentially conditionally
  calculated_value_expr_raw = r_expr # This is the R translation of stata_expr

  if (is_stata_expr_string_typed) {
      # If Stata expression is numeric NA (.), it translates to NA_real_.
      # When assigned to a string variable, Stata treats '.' as "".
      if (calculated_value_expr_raw == "NA_real_") { # Check against the literal string "NA_real_"
          calculated_value_expr = '""'
      } else {
          calculated_value_expr = paste0("as.character(", calculated_value_expr_raw, ")")
      }
  } else { # Numeric output
      # Ensure logicals become 0/1. Stata converts TRUE/FALSE to 1/0 for numeric types.
      # This handles `gen newvar = x==y` resulting in numeric 0/1.
      # If it's a logical expression (contains logical operators/TRUE/FALSE), cast to numeric.
      is_a_logical_expression = isTRUE(
          stringi::stri_detect_regex(calculated_value_expr_raw, "\\bTRUE\\b|\\bFALSE\\b|==|!=|<=|>=|<|>|&|\\||\\bsfun_missing\\b") &&
          !stringi::stri_detect_fixed(calculated_value_expr_raw, "dplyr::if_else")
      )

      if (is_a_logical_expression) {
          calculated_value_expr = paste0("as.numeric(", calculated_value_expr_raw, ")")
      } else {
          calculated_value_expr = calculated_value_expr_raw
      }
  }

  # The value to assign if the condition is false/missing.
  na_or_empty_str_for_false_cond = if (is_stata_expr_string_typed) '""' else "NA_real_"


  # Apply condition only if it exists
  if (!is.na(r_if_cond) && r_if_cond != "") {
    calc_expr = paste0("dplyr::if_else(as.logical(dplyr::coalesce(", r_if_cond, ", FALSE)), ", calculated_value_expr, ", ", na_or_empty_str_for_false_cond, ")")
  } else {
    calc_expr = calculated_value_expr
  }

  # Step 2: Build the R code string using pipes for the mutate operation
  pipe_elements = list("data") # Elements for the pipe chain, starting from `data`

  # Add grouping and mutate steps
  if (length(group_vars_list_bare) > 0) {
      group_by_call_str = paste0('dplyr::group_by(!!!dplyr::syms(c("', paste0(group_vars_list_bare, collapse='", "'), '")))')
      pipe_elements = c(pipe_elements, group_by_call_str)
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", new_var, "` = ", calc_expr, ")"))
      pipe_elements = c(pipe_elements, "dplyr::ungroup()")
  } else {
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", new_var, "` = ", calc_expr, ")"))
  }

  # This is the final assignment line for the current command
  # It takes 'data' (potentially already arranged) and pipes it through the rest
  r_code_lines = c(paste0("data = ", paste(pipe_elements, collapse = " %>% \n  ")))
  
  return(paste(r_code_lines, collapse="\n"))
}


```
!END_CHANGE_FILE R/t_generate.R

!CHANGE_FILE R/t_recode.R
```R
# Translate Stata 'recode' command
# Stata: recode varlist (rule1)(rule2)... [if] [in] [, options]
# Example: recode income (0=.) (100 thru 200 = 150) (300 301 305 = 300) (else=copy), gen(newincome)

t_recode = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_recode") # Added restore.point
  rest_of_cmd_trimmed = stringi::stri_trim_both(rest_of_cmd)

  # Parse varlist, rules, if/in, options (especially gen())
  # This parsing is quite complex due to nested parentheses and optional parts.
  # Let's try to split varlist first, then find rules in parentheses.
  # Example: `recode var1 var2 (0=.) (1/10=1) (else=copy) if cond, gen(new1 new2)`

  # Split at first parenthesis to get varlist
  parts_varlist = stringi::stri_split_fixed(rest_of_cmd_trimmed, "(", n=2)[[1]]
  if (length(parts_varlist) != 2) {
      return(paste0("# Failed to parse recode command (missing rules): ", rest_of_cmd))
  }
  varlist_str = stringi::stri_trim_both(parts_varlist[1])
  vars_to_recode = stringi::stri_split_regex(varlist_str, "\\s+")[[1]]
  vars_to_recode = vars_to_recode[vars_to_recode != ""]

  if (length(vars_to_recode) == 0) {
      return(paste0("# recode command requires varlist: ", rest_of_cmd))
  }

  rules_and_rest = paste0("(", parts_varlist[2]) # Put the '(' back

  # Separate if/in and options from rules
  stata_if_in_cond = NA_character_
  options_str = NA_character_

  # Look for `if` or `in` first
  if_in_match = stringi::stri_match_first_regex(rules_and_rest, "\\s+(?:if\\s+|in\\s+)(.*)$")
  if(!is.na(if_in_match[1,1])) {
      stata_if_in_cond = if_in_match[1,2]
      rules_and_rest = stringi::stri_replace_last_regex(rules_and_rest, "\\s+(?:if\\s+|in\\s+)(.*)$", "")
      rules_and_rest = stringi::stri_trim_both(rules_and_rest)
  }

  # Look for options after the if/in part or after rules
  options_match = stringi::stri_match_first_regex(rules_and_rest, ",\\s*(.*)$")
  if (!is.na(options_match[1,1])) {
      options_str = stringi::stri_trim_both(options_match[1,2]) # Corrected to take group 2 for options string
      rules_part = stringi::stri_replace_last_regex(rules_and_rest, ",\\s*(.*)$", "")
      rules_part = stringi::stri_trim_both(rules_part)
  } else {
      rules_part = rules_and_rest
  }

  # Now parse the rules part: (rule1)(rule2)...
  # Find all rules within parentheses
  rule_matches = stringi::stri_match_all_regex(rules_part, "\\(([^)]*)\\)")[[1]] # Match content inside ()
  if (NROW(rule_matches) == 0) {
      return(paste0("# Failed to parse recode rules: ", rules_part))
  }
  recode_rules_raw = rule_matches[,2] # Extract the content within parentheses


  # Parse options, specifically `gen()`
  gen_vars = NA_character_
  if (!is.na(options_str)) {
      gen_opt_match = stringi::stri_match_first_regex(options_str, "\\bgen\\s*\\(([^)]+)\\)")
      if (!is.na(gen_opt_match[1,1])) {
           gen_vars = stringi::stri_trim_both(gen_opt_match[1,2])
       }
  }

  new_vars = NULL
  if (!is.na(gen_vars)) {
      new_vars = stringi::stri_split_regex(gen_vars, "\\s+")[[1]]
      new_vars = new_vars[new_vars != ""]
      if (length(new_vars) != length(vars_to_recode)) {
          return(paste0("# recode gen() option requires same number of new variables as old variables."))
      }
  } else {
      # If no gen() option, recode is done in place. New vars are the same as old vars.
      new_vars = vars_to_recode
  }

  # --- Determine the target variable type and collect labels if applicable ---
  # These flags will track if *any* rule implies a string or labelled numeric output.
  # The final type will be determined based on the presence of these flags.
  any_rule_implies_string_output = FALSE
  any_rule_implies_labelled_numeric_output = FALSE
  collected_labels_for_numeric_target = list() # temp storage for value-label pairs

  for (rule_raw in recode_rules_raw) {
      rule_str_trimmed = stringi::stri_trim_both(rule_raw)
      parts_eq = stringi::stri_split_fixed(rule_str_trimmed, "=", n=2)[[1]]
      if (length(parts_eq) != 2) next # Skip malformed rules
      new_part_raw = stringi::stri_trim_both(parts_eq[2])

      # 1. Check if new value is a plain string literal (e.g., "new_string_value")
      if ( (dplyr::coalesce(stringi::stri_startswith_fixed(new_part_raw, '"') && stringi::stri_endswith_fixed(new_part_raw, '"'), FALSE)) ||
           (dplyr::coalesce(stringi::stri_startswith_fixed(new_part_raw, "'") && stringi::stri_endswith_fixed(new_part_raw, "'"), FALSE)) ) {
          any_rule_implies_string_output = TRUE
      }

      # 2. Check for 'value "label"' syntax (e.g., 1 "Very Low")
      label_match = stringi::stri_match_first_regex(new_part_raw, "^\\s*([^\\s]+)\\s+(?:\"([^\"]*)\"|'([^']*)')\\s*$")
      if (!is.na(label_match[1,1])) {
          any_rule_implies_labelled_numeric_output = TRUE
          numeric_val_part = stringi::stri_trim_both(label_match[1,2])
          string_label_part = ifelse(!is.na(label_match[1,3]), label_match[1,3], label_match[1,4])

          r_numeric_val = NA_real_
          # Robustly handle numeric_val_part, which can be NA from regex if not present.
          numeric_val_part_safe = dplyr::coalesce(numeric_val_part, "") 

          if (numeric_val_part_safe == ".") r_numeric_val = NA_real_ # Stata system missing
          else if (stringi::stri_detect_regex(numeric_val_part_safe, "^\\.[a-zA-Z]$")) r_numeric_val = NA_real_ # Stata extended missing
          else if (numeric_val_part_safe != "") r_numeric_val = as.numeric(numeric_val_part_safe) # Convert numeric strings to numeric
          # If numeric_val_part_safe is "", r_numeric_val remains NA_real_, which is fine.

          if (!is.na(r_numeric_val) && !is.na(string_label_part)) {
            # Use a temporary list to store key-value pairs to handle duplicates
            # Store as c(label, value) and process later.
            collected_labels_for_numeric_target[[length(collected_labels_for_numeric_target) + 1]] = list(label = string_label_part, value = r_numeric_val)
          }
      }
  }

  # Final determination of R type:
  # If any rule implies a string, the variable will be string.
  # Otherwise, if any rule implies a labelled numeric, it will be labelled numeric.
  # Otherwise, it will be plain numeric.
  final_r_var_type_is_string = any_rule_implies_string_output
  final_r_var_type_is_labelled_numeric = !final_r_var_type_is_string && any_rule_implies_labelled_numeric_output

  # Process collected_labels_for_numeric_target if final_r_var_type_is_labelled_numeric is TRUE
  final_labels_map = stats::setNames(numeric(0), character(0)) # Initialize empty named numeric vector
  if (final_r_var_type_is_labelled_numeric && length(collected_labels_for_numeric_target) > 0) {
      temp_df_labels = data.frame(
          label = sapply(collected_labels_for_numeric_target, `[[`, "label"),
          value = sapply(collected_labels_for_numeric_target, `[[`, "value"),
          stringsAsFactors = FALSE
      )
      
      # Stata's recode behavior for labels:
      # If multiple rules map to the same *numeric value*, the label for that value is taken from the *last* rule that defines it.
      # The order of labels in the metadata is typically sorted by value.
      
      # To replicate "last defined label for value": Sort by value (desc), then original_order (desc), then remove duplicates, then re-sort by value (asc).
      temp_df_labels$original_order = seq_len(NROW(temp_df_labels))
      temp_df_labels = temp_df_labels[order(temp_df_labels$value, -temp_df_labels$original_order), ] # Sort by value (asc), then original_order (desc) for tie-breaking
      temp_df_labels = temp_df_labels[!duplicated(temp_df_labels$value, fromLast = TRUE), ] # Keep the last unique for value (which is the last from original order)
      temp_df_labels = temp_df_labels[order(temp_df_labels$value), ] # Final sort by value (asc) for consistent output
      
      final_labels_map = stats::setNames(temp_df_labels$value, temp_df_labels$label)
  }

  # Translate the if/in condition for subsetting
  r_subset_cond = NA_character_
  if (!is.na(stata_if_in_cond) && stata_if_in_cond != "") {
      r_subset_cond = translate_stata_expression_with_r_values(stata_if_in_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
      if (is.na(r_subset_cond) || r_subset_cond == "") {
           return(paste0("# Failed to translate if/in condition for recode: ", stata_if_in_cond))
       }
  }


  # Translate rules into R case_when clauses
  translate_recode_rule = function(rule_str, source_var_r, final_r_var_type_is_string) { 
      restore.point("translate_recode_rule_inner")
      rule_str = stringi::stri_trim_both(rule_str)
      parts_eq = stringi::stri_split_fixed(rule_str, "=", n=2)[[1]]
      if (length(parts_eq) != 2) {
          return(paste0("## Error parsing rule: ", rule_str))
      }
      old_part_raw = stringi::stri_trim_both(parts_eq[1])
      new_part_raw = stringi::stri_trim_both(parts_eq[2])

      # Translate old_part into R condition (left side of case_when ~ )
      r_condition = ""
      if (old_part_raw == "else") {
          r_condition = "TRUE" # This rule is the fallback
      } else if (old_part_raw == "missing" || dplyr::coalesce(stringi::stri_detect_regex(old_part_raw, "^\\.\\w?$"), FALSE)) { # Added regex for .a, .b, etc.
           r_condition = paste0("sfun_missing(", source_var_r, ")") # Missing value rule (all Stata missing types to R's NA)
      } else if (old_part_raw == "nonmissing") {
           r_condition = paste0("!sfun_missing(", source_var_r, ")") # Non-missing value rule
      } else if (grepl("\\s+thru\\s+", old_part_raw)) {
           # Range: val1 thru val2
           range_parts = stringi::stri_split_regex(old_part_raw, "\\s+thru\\s+", n=2)[[1]]
           val1 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[1]), context=list(is_by_group=FALSE))
           val2 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[2]), context=list(is_by_group=FALSE))
           if (is.na(val1) || is.na(val2)) return(paste0("## Error translating range values in rule: ", rule_str))
           r_condition = paste0(source_var_r, " >= ", val1, " & ", source_var_r, " <= ", val2)
      } else if (grepl("/", old_part_raw)) {
          # Range: val1/val2
           range_parts = stringi::stri_split_regex(old_part_raw, "/", n=2)[[1]]
           val1 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[1]), context=list(is_by_group=FALSE))
           val2 = translate_stata_expression_to_r(stringi::stri_trim_both(range_parts[2]), context=list(is_by_group=FALSE))
           if (is.na(val1) || is.na(val2)) return(paste0("## Error translating range values in rule: ", rule_str))
           r_condition = paste0(source_var_r, " >= ", val1, " & ", source_var_r, " <= ", val2) # Stata / is inclusive range
      }
      else {
          # List of values or single value
          old_values = stringi::stri_split_regex(old_part_raw, "\\s+")[[1]]
          old_values = old_values[!is.na(old_values) & old_values != ""] # Filter out NA or empty strings
          r_values = sapply(old_values, function(val) {
               # Use translate_stata_expression_to_r for each value in the list
               # Stata missing values like '.' or '.a' should be handled as NA in R
               # The `if (val == ".")` and `if (stringi::stri_detect_regex(val, "^\\.[a-zA-Z]$"))`
               # need to be robust to `val` being NA.
               if (is.na(val)) return("NA_real_") # Added robustness for NA input to internal function
               if (val == ".") return("NA_real_")
               if (dplyr::coalesce(stringi::stri_detect_regex(val, "^\\.[a-zA-Z]$"), FALSE)) return("NA_real_") # Added coalesce
               translated_val = translate_stata_expression_to_r(val, context=list(is_by_group=FALSE))
               translated_val
          })
          r_values = r_values[!is.na(r_values)] # Filter out any NA from translation for safety
          if (length(r_values) == 0) return(paste0("## Error translating old values in rule: ", rule_str))
          r_condition = paste0(source_var_r, " %in% c(", paste(r_values, collapse = ", "), ")")
      }


      # Translate new_part into R value (right side of case_when ~ )
      r_new_value = ""
      if (new_part_raw == "copy") {
          r_new_value = source_var_r # Use the original variable value
          if (final_r_var_type_is_string) {
            r_new_value = paste0("as.character(", r_new_value, ")")
          }
      } else {
          # Check for numeric value with optional label, e.g., '1 "Very Low"'
          label_match = stringi::stri_match_first_regex(new_part_raw, "^\\s*([^\\s]+)\\s+(?:\"([^\"]*)\"|'([^']*)')\\s*$")
          if (!is.na(label_match[1,1])) {
              # It's a "value label" syntax
              if (final_r_var_type_is_string) {
                  string_label_part = ifelse(!is.na(label_match[1,3]), label_match[1,3], label_match[1,4])
                  r_new_value = quote_for_r_literal(string_label_part) 
              } else {
                  numeric_val_part = stringi::stri_trim_both(label_match[1,2])
                  r_new_value = translate_stata_expression_to_r(numeric_val_part, context=list(is_by_group=FALSE))
              }
          } else {
              # It's a plain expression or literal (numeric or string)
              r_new_value = translate_stata_expression_to_r(new_part_raw, context=list(is_by_group=FALSE))
              if (final_r_var_type_is_string) {
                  if (r_new_value == "NA_real_") {
                      r_new_value = '""' # Stata recode for missing numeric to empty string for string variables
                  } else if (!dplyr::coalesce(stringi::stri_startswith_fixed(r_new_value, '"'), FALSE) && !dplyr::coalesce(stringi::stri_startswith_fixed(r_new_value, "'"), FALSE)) {
                      r_new_value = paste0("as.character(", r_new_value, ")")
                  }
              }
          }
      }

      return(paste0(r_condition, " ~ ", r_new_value))
  }

  # Generate case_when expression for each variable
  mutate_exprs = character(length(vars_to_recode))
  r_code_lines = c()

  for (k in seq_along(vars_to_recode)) {
      old_var = vars_to_recode[k]
      new_var = new_vars[k]
      source_var_r = old_var # R variable name for the source column

      r_rules = sapply(recode_rules_raw, translate_recode_rule, source_var_r = source_var_r, final_r_var_type_is_string = final_r_var_type_is_string)

      case_when_expr = paste0("dplyr::case_when(\n    ", paste(r_rules, collapse = ",\n    "), "\n  )")

      if (!is.na(r_subset_cond) && r_subset_cond != "") {
          final_value_expr = paste0("dplyr::if_else(as.logical(dplyr::coalesce(", r_subset_cond, ", FALSE)),\n",
                                    "    ", case_when_expr, ",\n",
                                    "    `", source_var_r, "`)") # Keep original value if condition not met.
      } else {
          final_value_expr = case_when_expr
      }

      if (final_r_var_type_is_string) {
          final_value_expr = paste0("as.character(", final_value_expr, ")")
      } else if (final_r_var_type_is_labelled_numeric) {
          final_value_expr = paste0("as.integer(", final_value_expr, ")")
      }


      mutate_exprs[k] = paste0("`", new_var, "` = ", final_value_expr)
  }

  mutate_exprs_str = paste(mutate_exprs, collapse = ",\n  ")

  r_code_lines = c(r_code_lines, paste0("data = dplyr::mutate(data, ", mutate_exprs_str, ")"))

  if (final_r_var_type_is_labelled_numeric && length(final_labels_map) > 0) {
      # Ensure labels are sorted by value for consistent haven::labelled behavior
      sorted_labels = final_labels_map[order(unname(final_labels_map))]
      labels_vector_r_code = paste0("stats::setNames(c(", paste0(unname(sorted_labels), collapse=", "), "), c(", paste0('"', names(sorted_labels), '"', collapse=", "), "))")

      for (new_var in new_vars) {
          r_code_lines = c(r_code_lines, paste0("data[['", new_var, "']] = haven::labelled(data[['", new_var, "']], labels = ", labels_vector_r_code, ")"))
      }
  }


  r_code_str = paste(r_code_lines, collapse="\n")

   options_str_cleaned = options_str
   if (!is.na(options_str_cleaned)) {
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "\\bgen\\s*\\([^)]+\\)", "")
        options_str_cleaned = stringi::stri_trim_both(stringi::stri_replace_all_regex(options_str_cleaned, ",+", ","))
        options_str_cleaned = stringi::stri_replace_first_regex(options_str_cleaned, "^,+", "")
   }

   if (!is.na(options_str_cleaned) && options_str_cleaned != "") {
        r_code_str = paste0(r_code_str, paste0("\n# Other options ignored: ", options_str_cleaned))
   }


  return(r_code_str)
}

```
!END_CHANGE_FILE R/t_recode.R

!CHANGE_FILE R/t_replace.R
```R
t_replace = function(rest_of_cmd, cmd_obj, cmd_df, line_num, context) {
  restore.point("t_replace")
  # Capture explicit type declaration (e.g., `str10`)
  explicit_type_match = stringi::stri_match_first_regex(rest_of_cmd, "^(?:byte|int|long|float|double|str\\d+|strL)\\s+")
  declared_type_str = NA_character_
  if (!is.na(explicit_type_match[1,1])) {
    declared_type_str = explicit_type_match[1,2]
  }

  # Strip type if present (e.g. replace double oldvar = ...)
  rest_of_cmd_no_type = stringi::stri_replace_first_regex(rest_of_cmd, "^(?:byte|int|long|float|double|str\\d+|strL)\\s+", "")

  match = stringi::stri_match_first_regex(rest_of_cmd_no_type, "^\\s*([^=\\s]+)\\s*=\\s*(.*?)(?:\\s+if\\s+(.*))?$")

  # Defensive assignment for potentially NA match groups
  var_to_replace = NA_character_
  stata_expr = NA_character_
  stata_if_cond = NA_character_

  if (!is.na(match[1,1])) { # If the overall regex matched
      var_to_replace = dplyr::coalesce(stringi::stri_trim_both(match[1,2]), NA_character_)
      stata_expr = dplyr::coalesce(stringi::stri_trim_both(match[1,3]), NA_character_)
      stata_if_cond = dplyr::coalesce(stringi::stri_trim_both(match[1,4]), NA_character_)
  } else {
      # If no match, return a parsing error
      return(paste0("# Failed to parse replace command structure: ", rest_of_cmd))
  }


  current_context = list(is_by_group = cmd_obj$is_by_prefix && length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1]))
  # Translate the Stata expression to R first
  r_expr = translate_stata_expression_with_r_values(stata_expr, line_num, cmd_df, current_context)

  # Ensure r_expr is a character string literal, even if it represents NA (logical)
  if (is.na(r_expr)) { # Check for logical NA, not string "NA"
      r_expr = "NA_real_"
  }

  r_if_cond = NA_character_
  if (!is.na(stata_if_cond) && stata_if_cond != "") {
    r_if_cond = translate_stata_expression_with_r_values(stata_if_cond, line_num, cmd_df, context = list(is_by_group = FALSE))
  }

  # Determine group_vars for dplyr::group_by
  group_vars_list_bare = character(0)

  if (cmd_obj$is_by_prefix) {
    if (length(cmd_obj$by_group_vars) > 0 && !is.na(cmd_obj$by_group_vars[1])) {
      group_vars_list = stringi::stri_split_fixed(cmd_obj$by_group_vars, ",")[[1]]
      group_vars_list = group_vars_list[!is.na(group_vars_list) & group_vars_list != ""]
      if (length(group_vars_list) > 0) {
        group_vars_list_bare = group_vars_list # Assign just the bare names
      }
    }
  }

  # Determine if the target variable will be a string type based on EXPLICIT Stata declaration.
  # If no explicit type, let R infer from the translated expression.
  is_stata_expr_string_typed = sfun_is_stata_expression_string_typed(stata_expr)

  # Apply explicit type casting if declared in Stata command, overriding inferred type
  if (!is.na(declared_type_str)) {
      if (stringi::stri_startswith_fixed(declared_type_str, "str")) {
          is_stata_expr_string_typed = TRUE
      } else { # byte, int, long, float, double
          is_stata_expr_string_typed = FALSE
      }
  }

  # Step 1: Calculate the value for the new variable, potentially conditionally
  calculated_value_expr_raw = r_expr # This is the R translation of stata_expr

  if (is_stata_expr_string_typed) {
      # If Stata expression is numeric NA (.), it translates to NA_real_.
      # When assigned to a string variable, Stata treats '.' as "".
      if (calculated_value_expr_raw == "NA_real_") { # Check against the literal string "NA_real_"
          calculated_value_expr = '""'
      } else {
          calculated_value_expr = paste0("as.character(", calculated_value_expr_raw, ")")
      }
  } else { # Numeric output
      # Ensure logicals become 0/1. Stata converts TRUE/FALSE to 1/0 for numeric types.
      # This handles `gen newvar = x==y` resulting in numeric 0/1.
      # If it's a logical expression, cast to numeric.
      is_a_logical_expression = isTRUE(
          stringi::stri_detect_regex(calculated_value_expr_raw, "\\bTRUE\\b|\\bFALSE\\b|==|!=|<=|>=|<|>|&|\\||\\bsfun_missing\\b") &&
          !stringi::stri_detect_fixed(calculated_value_expr_raw, "dplyr::if_else")
      )

      if (is_a_logical_expression) {
          calculated_value_expr = paste0("as.numeric(", calculated_value_expr_raw, ")")
      } else {
          calculated_value_expr = calculated_value_expr_raw
      }
  }


  # For 'replace' command, if condition is FALSE or NA, the value should be left unchanged.
  # Use dplyr::coalesce(condition, FALSE) to treat NA condition as FALSE.
  # Apply condition only if it exists
  if (!is.na(r_if_cond) && r_if_cond != "") {
    calc_expr = paste0("dplyr::if_else(as.logical(dplyr::coalesce(", r_if_cond, ", FALSE)), ", calculated_value_expr, ", data$`", var_to_replace, "`)")
  } else {
    calc_expr = calculated_value_expr
  }

  # Step 2: Build the R code string using pipes for the mutate operation
  pipe_elements = list("data") # Elements for the pipe chain, starting from `data`

  if (length(group_vars_list_bare) > 0) { # Check if group_vars_list_bare is not empty
      group_by_call_str = paste0('dplyr::group_by(!!!dplyr::syms(c("', paste0(group_vars_list_bare, collapse='", "'), '")))')
      pipe_elements = c(pipe_elements, group_by_call_str)
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", var_to_replace, "` = ", calc_expr, ")"))
      pipe_elements = c(pipe_elements, "dplyr::ungroup()")
  } else {
      pipe_elements = c(pipe_elements, paste0("dplyr::mutate(`", var_to_replace, "` = ", calc_expr, ")"))
  }

  r_code_lines = c(paste0("data = ", paste(pipe_elements, collapse = " %>% \n  ")))

  return(paste(r_code_lines, collapse="\n"))
}


```
!END_CHANGE_FILE R/t_replace.R
